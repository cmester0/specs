(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Require Import Cis1.
Export Cis1.

Require Import Concordium_contracts_common.
Export Concordium_contracts_common.

Require Import Map.
Export Map.

Require Import Set.
Export Set.

Notation "'t_ContractTokenId'" := (t_TokenIdUnit).

Equations v_TOKEN_ID_WCCD {L : {fset Location}} {I : Interface} : both L I (t_TokenIdUnit) :=
  v_TOKEN_ID_WCCD  :=
    TokenIdUnit : both L I (t_TokenIdUnit).
Fail Next Obligation.

Equations v_TOKEN_METADATA_URL {L : {fset Location}} {I : Interface} : both L I (chString) :=
  v_TOKEN_METADATA_URL  :=
    solve_lift (ret_both (https://some.example/token/wccd : chString)) : both L I (chString).
Fail Next Obligation.

Definition t_AddressState : choice_type :=
  (int64 × t_HashSet (t_Address) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)).
Equations f_balance {L : {fset Location}} {I : Interface} (s : both L I (t_AddressState)) : both L I (int64) :=
  f_balance s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : int64))) : both L I (int64).
Fail Next Obligation.
Equations f_operators {L : {fset Location}} {I : Interface} (s : both L I (t_AddressState)) : both L I (t_HashSet (t_Address) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)) :=
  f_operators s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_HashSet (t_Address) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)))) : both L I (t_HashSet (t_Address) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)).
Fail Next Obligation.
Equations Build_t_AddressState {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_balance : both L0 I0 (int64)} {f_operators : both L1 I1 (t_HashSet (t_Address) (t_BuildHasherDefault (t_FnvHasher)) (t_Global))} : both (L0:|:L1) (I0:|:I1) (t_AddressState) :=
  Build_t_AddressState  :=
    bind_both f_operators (fun f_operators =>
      bind_both f_balance (fun f_balance =>
        solve_lift (ret_both ((f_balance,f_operators) : (t_AddressState))))) : both (L0:|:L1) (I0:|:I1) (t_AddressState).
Fail Next Obligation.
Notation "'Build_t_AddressState' '[' x ']' '(' 'f_balance' ':=' y ')'" := (Build_t_AddressState (f_balance := y) (f_operators := f_operators x)).
Notation "'Build_t_AddressState' '[' x ']' '(' 'f_operators' ':=' y ')'" := (Build_t_AddressState (f_balance := f_balance x) (f_operators := y)).

Definition t_State : choice_type :=
  (t_HashMap (t_Address) (t_AddressState) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)).
Equations f_token {L : {fset Location}} {I : Interface} (s : both L I (t_State)) : both L I (t_HashMap (t_Address) (t_AddressState) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)) :=
  f_token s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_HashMap (t_Address) (t_AddressState) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)))) : both L I (t_HashMap (t_Address) (t_AddressState) (t_BuildHasherDefault (t_FnvHasher)) (t_Global)).
Fail Next Obligation.
Equations Build_t_State {L0 : {fset Location}} {I0 : Interface} {f_token : both L0 I0 (t_HashMap (t_Address) (t_AddressState) (t_BuildHasherDefault (t_FnvHasher)) (t_Global))} : both L0 I0 (t_State) :=
  Build_t_State  :=
    bind_both f_token (fun f_token =>
      solve_lift (ret_both ((f_token) : (t_State)))) : both L0 I0 (t_State).
Fail Next Obligation.
Notation "'Build_t_State' '[' x ']' '(' 'f_token' ':=' y ')'" := (Build_t_State (f_token := y)).

Definition t_UnwrapParams : choice_type :=
  (int64 × t_Address × t_Receiver × t_AdditionalData).
Equations f_amount {L : {fset Location}} {I : Interface} (s : both L I (t_UnwrapParams)) : both L I (int64) :=
  f_amount s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst x)) : int64))) : both L I (int64).
Fail Next Obligation.
Equations f_owner {L : {fset Location}} {I : Interface} (s : both L I (t_UnwrapParams)) : both L I (t_Address) :=
  f_owner s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations f_receiver {L : {fset Location}} {I : Interface} (s : both L I (t_UnwrapParams)) : both L I (t_Receiver) :=
  f_receiver s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_Receiver))) : both L I (t_Receiver).
Fail Next Obligation.
Equations f_data {L : {fset Location}} {I : Interface} (s : both L I (t_UnwrapParams)) : both L I (t_AdditionalData) :=
  f_data s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_AdditionalData))) : both L I (t_AdditionalData).
Fail Next Obligation.
Equations Build_t_UnwrapParams {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {f_amount : both L0 I0 (int64)} {f_owner : both L1 I1 (t_Address)} {f_receiver : both L2 I2 (t_Receiver)} {f_data : both L3 I3 (t_AdditionalData)} : both (L0:|:L1:|:L2:|:L3) (I0:|:I1:|:I2:|:I3) (t_UnwrapParams) :=
  Build_t_UnwrapParams  :=
    bind_both f_data (fun f_data =>
      bind_both f_receiver (fun f_receiver =>
        bind_both f_owner (fun f_owner =>
          bind_both f_amount (fun f_amount =>
            solve_lift (ret_both ((f_amount,f_owner,f_receiver,f_data) : (t_UnwrapParams))))))) : both (L0:|:L1:|:L2:|:L3) (I0:|:I1:|:I2:|:I3) (t_UnwrapParams).
Fail Next Obligation.
Notation "'Build_t_UnwrapParams' '[' x ']' '(' 'f_amount' ':=' y ')'" := (Build_t_UnwrapParams (f_amount := y) (f_owner := f_owner x) (f_receiver := f_receiver x) (f_data := f_data x)).
Notation "'Build_t_UnwrapParams' '[' x ']' '(' 'f_owner' ':=' y ')'" := (Build_t_UnwrapParams (f_amount := f_amount x) (f_owner := y) (f_receiver := f_receiver x) (f_data := f_data x)).
Notation "'Build_t_UnwrapParams' '[' x ']' '(' 'f_receiver' ':=' y ')'" := (Build_t_UnwrapParams (f_amount := f_amount x) (f_owner := f_owner x) (f_receiver := y) (f_data := f_data x)).
Notation "'Build_t_UnwrapParams' '[' x ']' '(' 'f_data' ':=' y ')'" := (Build_t_UnwrapParams (f_amount := f_amount x) (f_owner := f_owner x) (f_receiver := f_receiver x) (f_data := y)).

Definition t_WrapParams : choice_type :=
  (t_Receiver × t_AdditionalData).
Equations f_to {L : {fset Location}} {I : Interface} (s : both L I (t_WrapParams)) : both L I (t_Receiver) :=
  f_to s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : t_Receiver))) : both L I (t_Receiver).
Fail Next Obligation.
Equations f_data {L : {fset Location}} {I : Interface} (s : both L I (t_WrapParams)) : both L I (t_AdditionalData) :=
  f_data s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_AdditionalData))) : both L I (t_AdditionalData).
Fail Next Obligation.
Equations Build_t_WrapParams {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_to : both L0 I0 (t_Receiver)} {f_data : both L1 I1 (t_AdditionalData)} : both (L0:|:L1) (I0:|:I1) (t_WrapParams) :=
  Build_t_WrapParams  :=
    bind_both f_data (fun f_data =>
      bind_both f_to (fun f_to =>
        solve_lift (ret_both ((f_to,f_data) : (t_WrapParams))))) : both (L0:|:L1) (I0:|:I1) (t_WrapParams).
Fail Next Obligation.
Notation "'Build_t_WrapParams' '[' x ']' '(' 'f_to' ':=' y ')'" := (Build_t_WrapParams (f_to := y) (f_data := f_data x)).
Notation "'Build_t_WrapParams' '[' x ']' '(' 'f_data' ':=' y ')'" := (Build_t_WrapParams (f_to := f_to x) (f_data := y)).

Definition t_CustomContractError : choice_type :=
  chFin (mkpos 3).
Equations CustomContractError_ParseParams {L : {fset Location}} {I : Interface} : both L I t_CustomContractError :=
  CustomContractError_ParseParams  :=
    solve_lift ret_both (fintype.Ordinal (n:=3) (m:=0) eq_refl : t_CustomContractError) : both L I t_CustomContractError.
Fail Next Obligation.
Equations CustomContractError_LogFull {L : {fset Location}} {I : Interface} : both L I t_CustomContractError :=
  CustomContractError_LogFull  :=
    solve_lift ret_both (fintype.Ordinal (n:=3) (m:=1) eq_refl : t_CustomContractError) : both L I t_CustomContractError.
Fail Next Obligation.
Equations CustomContractError_LogMalformed {L : {fset Location}} {I : Interface} : both L I t_CustomContractError :=
  CustomContractError_LogMalformed  :=
    solve_lift ret_both (fintype.Ordinal (n:=3) (m:=2) eq_refl : t_CustomContractError) : both L I t_CustomContractError.
Fail Next Obligation.

#[global] Program Instance t_CustomContractError_t_From : t_From t_CustomContractError t_ParseError :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (fe : both L1 I1 (t_ParseError)) => CustomContractError_ParseParams : both (L1 :|: fset []) I1 (t_CustomContractError) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_CustomContractError_t_From.

Notation "'t_ContractError'" := (t_Cis1Error (t_CustomContractError)).

Definition t_ContractResult {v_A : _} `{ t_Sized (v_A)} : choice_type :=
  t_Result (v_A) (t_Cis1Error (t_CustomContractError)).

#[global] Program Instance t_CustomContractError_t_From : t_From t_CustomContractError t_LogError :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (le : both L1 I1 (t_LogError)) => solve_lift matchb le with
  | LogError_Full  =>
    CustomContractError_LogFull
  | LogError_Malformed  =>
    CustomContractError_LogMalformed
  end : both (L1 :|: fset []) I1 (t_CustomContractError) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_CustomContractError_t_From.

#[global] Program Instance t_Cis1Error (t_CustomContractError)_t_From : t_From t_Cis1Error (t_CustomContractError) t_CustomContractError :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (c : both L1 I1 (t_CustomContractError)) => Cis1Error_Custom (solve_lift c) : both (L1 :|: fset []) I1 (t_Cis1Error (t_CustomContractError)) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Cis1Error (t_CustomContractError)_t_From.

Equations new {L : {fset Location}} {I : Interface} : both L I (t_State) :=
  new  :=
    solve_lift (Build_t_State (f_token := f_default)) : both L I (t_State).
Fail Next Obligation.

Equations balance {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_State)) (token_id : both L2 I2 (t_TokenIdUnit)) (address : both L3 I3 (t_Address)) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_Result (int64) (t_Cis1Error (t_CustomContractError))) :=
  balance self token_id address  :=
    Result_Ok (solve_lift (unwrap_or (map (get (f_token self) address) (fun s =>
      f_balance s)) (ret_both (0 : int64)))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_Result (int64) (t_Cis1Error (t_CustomContractError))).
Fail Next Obligation.

Equations is_operator {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_State)) (address : both L2 I2 (t_Address)) (owner : both L3 I3 (t_Address)) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) ('bool) :=
  is_operator self address owner  :=
    solve_lift (unwrap_or (map (get (f_token self) owner) (fun address_state =>
      contains (f_operators address_state) address)) (ret_both (false : 'bool))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) ('bool).
Fail Next Obligation.

Equations transfer {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} (self : both L1 I1 (t_State)) (token_id : both L2 I2 (t_TokenIdUnit)) (amount : both L3 I3 (int64)) (from : both L4 I4 (t_Address)) (to : both L5 I5 (t_Address)) : both (L1 :|: L2 :|: L3 :|: L4 :|: L5) (I1 :|: I2 :|: I3 :|: I4 :|: I5) (t_Result ('unit) (t_Cis1Error (t_CustomContractError))) :=
  transfer self token_id amount from to  :=
    solve_lift (run (letm[choice_typeMonad.result_bind_code ((t_State × t_Result ('unit) (t_Cis1Error (t_CustomContractError))))] _ := ifb amount =.? (ret_both (0 : int64))
    then letm[choice_typeMonad.result_bind_code ((t_State × t_Result ('unit) (t_Cis1Error (t_CustomContractError))))] hoist85 := v_Break (prod_b (self,Result_Ok (ret_both (tt : 'unit)))) in
      ControlFlow_Continue (never_to_any hoist85)
    else ControlFlow_Continue (ret_both (tt : 'unit)) in
    ControlFlow_Continue (failure (ret_both ((RefMut) The mutation of this &mut is not allowed here.
 : chString)) (ret_both ({
        let from_state: &mut hacspec_wccd::t_AddressState = {
            (match core::ops::try_trait::f_branch(core::option::ok_or(
                hashbrown::map::get_mut(&mut (proj_hacspec_wccd::f_token(self)), &(deref(from))),
                hacspec_wccd::cis1::Cis1Error_InsufficientFunds(),
            )) {
                core::ops::control_flow::ControlFlow_Break(residual) => {
                    rust_primitives::hax::never_to_any(
                        (return Tuple2(self, core::ops::try_trait::f_from_residual(residual))),
                    )
                }
                core::ops::control_flow::ControlFlow_Continue(val) => val,
            })
        };
        {
            let _: tuple0 = {
                {
                    (if core::ops::bit::Not::not(core::cmp::PartialOrd::ge(
                        proj_hacspec_wccd::f_balance(deref(from_state)),
                        amount,
                    )) {
                        rust_primitives::hax::never_to_any({
                            {
                                (return Tuple2(
                                    self,
                                    core::result::Result_Err(
                                        hacspec_wccd::cis1::Cis1Error_InsufficientFunds(),
                                    ),
                                ))
                            }
                        })
                    })
                }
            };
            {
                let _: tuple0 = {
                    (deref(from_state).f_balance = core::ops::arith::Sub::sub(
                        proj_hacspec_wccd::f_balance(deref(from_state)),
                        amount,
                    ))
                };
                {
                    let to_state: &mut hacspec_wccd::t_AddressState = {
                        hashbrown::map::or_insert_with(
                            hashbrown::map::entry(
                                &mut (proj_hacspec_wccd::f_token(self)),
                                deref(to),
                            ),
                            (|| hacspec_wccd::AddressState {
                                f_balance: 0,
                                f_operators: core::default::f_default(),
                            }),
                        )
                    };
                    {
                        let _: tuple0 = {
                            (deref(to_state).f_balance = core::ops::arith::Add::add(
                                proj_hacspec_wccd::f_balance(deref(to_state)),
                                amount,
                            ))
                        };
                        {
                            let output: core::result::t_Result<
                                tuple0,
                                hacspec_wccd::cis1::t_Cis1Error<
                                    hacspec_wccd::t_CustomContractError,
                                >,
                            > = {
                                {
                                    core::result::Result_Ok(Tuple0())
                                }
                            };
                            Tuple2(self, output)
                        }
                    }
                }
            }
        }
    } : chString))))) : both (L1 :|: L2 :|: L3 :|: L4 :|: L5) (I1 :|: I2 :|: I3 :|: I4 :|: I5) (t_Result ('unit) (t_Cis1Error (t_CustomContractError))).
Fail Next Obligation.

Equations add_operator {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_State)) (owner : both L2 I2 (t_Address)) (operator : both L3 I3 (t_Address)) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) ('unit) :=
  add_operator self owner operator  :=
    solve_lift (failure (ret_both ((RefMut) The mutation of this &mut is not allowed here.
 : chString)) (ret_both ({
        let address_state: &mut hacspec_wccd::t_AddressState = {
            hashbrown::map::or_insert_with(
                hashbrown::map::entry(&mut (proj_hacspec_wccd::f_token(self)), deref(owner)),
                (|| hacspec_wccd::AddressState {
                    f_balance: 0,
                    f_operators: core::default::f_default(),
                }),
            )
        };
        {
            let _: bool = {
                hashbrown::set::insert(
                    &mut (proj_hacspec_wccd::f_operators(deref(address_state))),
                    deref(operator),
                )
            };
            self
        }
    } : chString))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) ('unit).
Fail Next Obligation.

Equations remove_operator {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_State)) (owner : both L2 I2 (t_Address)) (operator : both L3 I3 (t_Address)) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_State) :=
  remove_operator self owner operator  :=
    letb _ := failure (ret_both ((RefMut) Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: expected an arrow type here
 : chString)) (ret_both (core::option::map(
        hashbrown::map::get_mut(&mut (proj_hacspec_wccd::f_token(self)), &(deref(owner))),
        (|address_state| {
            hashbrown::set::remove(
                &mut (proj_hacspec_wccd::f_operators(deref(address_state))),
                &(deref(operator)),
            )
        }),
    ) : chString)) in
    solve_lift self : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_State).
Fail Next Obligation.

Equations mint {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (self : both L1 I1 (t_State)) (token_id : both L2 I2 (t_TokenIdUnit)) (amount : both L3 I3 (int64)) (owner : both L4 I4 (t_Address)) : both (L1 :|: L2 :|: L3 :|: L4) (I1 :|: I2 :|: I3 :|: I4) (t_Result ('unit) (t_Cis1Error (t_CustomContractError))) :=
  mint self token_id amount owner  :=
    solve_lift (failure (ret_both ((RefMut) The mutation of this &mut is not allowed here.
 : chString)) (ret_both ({
        let address_state: &mut hacspec_wccd::t_AddressState = {
            hashbrown::map::or_insert_with(
                hashbrown::map::entry(&mut (proj_hacspec_wccd::f_token(self)), deref(owner)),
                (|| hacspec_wccd::AddressState {
                    f_balance: 0,
                    f_operators: core::default::f_default(),
                }),
            )
        };
        {
            let _: tuple0 = {
                (deref(address_state).f_balance = core::ops::arith::Add::add(
                    proj_hacspec_wccd::f_balance(deref(address_state)),
                    amount,
                ))
            };
            {
                let output: core::result::t_Result<
                    tuple0,
                    hacspec_wccd::cis1::t_Cis1Error<hacspec_wccd::t_CustomContractError>,
                > = {
                    {
                        core::result::Result_Ok(Tuple0())
                    }
                };
                Tuple2(self, output)
            }
        }
    } : chString))) : both (L1 :|: L2 :|: L3 :|: L4) (I1 :|: I2 :|: I3 :|: I4) (t_Result ('unit) (t_Cis1Error (t_CustomContractError))).
Fail Next Obligation.

Equations burn {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (self : both L1 I1 (t_State)) (token_id : both L2 I2 (t_TokenIdUnit)) (amount : both L3 I3 (int64)) (owner : both L4 I4 (t_Address)) : both (L1 :|: L2 :|: L3 :|: L4) (I1 :|: I2 :|: I3 :|: I4) (t_Result ('unit) (t_Cis1Error (t_CustomContractError))) :=
  burn self token_id amount owner  :=
    solve_lift (run (letm[choice_typeMonad.result_bind_code ((t_State × t_Result ('unit) (t_Cis1Error (t_CustomContractError))))] _ := ifb amount =.? (ret_both (0 : int64))
    then letm[choice_typeMonad.result_bind_code ((t_State × t_Result ('unit) (t_Cis1Error (t_CustomContractError))))] hoist86 := v_Break (prod_b (self,Result_Ok (ret_both (tt : 'unit)))) in
      ControlFlow_Continue (never_to_any hoist86)
    else ControlFlow_Continue (ret_both (tt : 'unit)) in
    ControlFlow_Continue (failure (ret_both ((RefMut) The mutation of this &mut is not allowed here.
 : chString)) (ret_both ({
        let from_state: &mut hacspec_wccd::t_AddressState = {
            (match core::ops::try_trait::f_branch(core::option::ok_or(
                hashbrown::map::get_mut(&mut (proj_hacspec_wccd::f_token(self)), &(deref(owner))),
                hacspec_wccd::cis1::Cis1Error_InsufficientFunds(),
            )) {
                core::ops::control_flow::ControlFlow_Break(residual) => {
                    rust_primitives::hax::never_to_any(
                        (return Tuple2(self, core::ops::try_trait::f_from_residual(residual))),
                    )
                }
                core::ops::control_flow::ControlFlow_Continue(val) => val,
            })
        };
        {
            let _: tuple0 = {
                {
                    (if core::ops::bit::Not::not(core::cmp::PartialOrd::ge(
                        proj_hacspec_wccd::f_balance(deref(from_state)),
                        amount,
                    )) {
                        rust_primitives::hax::never_to_any({
                            {
                                (return Tuple2(
                                    self,
                                    core::result::Result_Err(
                                        hacspec_wccd::cis1::Cis1Error_InsufficientFunds(),
                                    ),
                                ))
                            }
                        })
                    })
                }
            };
            {
                let _: tuple0 = {
                    (deref(from_state).f_balance = core::ops::arith::Sub::sub(
                        proj_hacspec_wccd::f_balance(deref(from_state)),
                        amount,
                    ))
                };
                {
                    let output: core::result::t_Result<
                        tuple0,
                        hacspec_wccd::cis1::t_Cis1Error<hacspec_wccd::t_CustomContractError>,
                    > = {
                        {
                            core::result::Result_Ok(Tuple0())
                        }
                    };
                    Tuple2(self, output)
                }
            }
        }
    } : chString))))) : both (L1 :|: L2 :|: L3 :|: L4) (I1 :|: I2 :|: I3 :|: I4) (t_Result ('unit) (t_Cis1Error (t_CustomContractError))).
Fail Next Obligation.

Equations contract_init {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {impl_108907986_ : _} {impl_88511815_ : _} `{ t_Sized (impl_108907986_)} `{ t_Sized (impl_88511815_)} `{ t_HasInitContext (impl_108907986_) ('unit)} `{ t_HasLogger (impl_88511815_)} (ctx : both L1 I1 (impl_108907986_)) (logger : both L2 I2 (impl_88511815_)) : both (L1 :|: L2) (I1 :|: I2) ((impl_88511815_ × t_Result (t_State) (t_Reject))) :=
  contract_init ctx logger  :=
    letb state := new in
    letb invoker := Address_Account (f_init_origin ctx) in
    letb output := Result_Ok state in
    solve_lift (prod_b (logger,output)) : both (L1 :|: L2) (I1 :|: I2) ((impl_88511815_ × t_Result (t_State) (t_Reject))).
Fail Next Obligation.

Definition state_ret_loc {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} : Location :=
  (t_State;0%nat).
Equations contract_wrap {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} (ctx : both L1 I1 (impl_574521470_)) (amount : both L2 I2 (t_Amount)) (logger : both L3 I3 (impl_88511815_)) (state : both L4 I4 (t_State)) : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [state_ret_loc]) (I1 :|: I2 :|: I3 :|: I4) (t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))) :=
  contract_wrap ctx amount logger state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))] (params:t_WrapParams) := matchb f_branch out with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))] hoist87 := v_Break (f_from_residual residual) in
      ControlFlow_Continue (never_to_any hoist87)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    letb sender := f_sender ctx in
    letb receive_address := address (f_to params) in
    letb '(tmp0,out) := mint state v_TOKEN_ID_WCCD (f_micro_ccd amount) receive_address in
    letb state := tmp0 in
    letb hoist89 := out in
    letb hoist90 := f_branch hoist89 in
    letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))] _ := matchb hoist90 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))] hoist88 := v_Break (f_from_residual residual) in
      ControlFlow_Continue (never_to_any hoist88)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb state_ret loc(state_ret_loc) := f_clone state in
    matchb f_to params with
    | Receiver_Contract address function =>
      letb parameter := Build_t_OnReceivingCis1Params (f_token_id := v_TOKEN_ID_WCCD) (f_amount := f_micro_ccd amount) (f_from := sender) (f_contract_name := new_unchecked (f_from (ret_both (init_CIS1-wCCD : chString)))) (f_data := f_data params) in
      letb param_bytes := to_bytes parameter in
      Result_Ok (prod_b (f_send_raw address (as_ref function) zero (f_deref param_bytes),state_ret))
    | _ =>
      Result_Ok (prod_b (f_accept,state_ret))
    end))) : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [state_ret_loc]) (I1 :|: I2 :|: I3 :|: I4) (t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))).
Fail Next Obligation.

Definition state_ret_loc {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} : Location :=
  (t_State;1%nat).
Equations contract_unwrap {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} (ctx : both L1 I1 (impl_574521470_)) (logger : both L2 I2 (impl_88511815_)) (state : both L3 I3 (t_State)) : both (L1 :|: L2 :|: L3 :|: fset [state_ret_loc]) (I1 :|: I2 :|: I3) ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))) :=
  contract_unwrap ctx logger state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] (params:t_UnwrapParams) := matchb f_branch out with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist91 := v_Break (prod_b (logger,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist91)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    letb sender := f_sender ctx in
    letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] _ := ifb not (orb (sender =.? (f_owner params)) (is_operator state sender (f_owner params)))
    then letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist92 := v_Break (prod_b (logger,Result_Err Cis1Error_Unauthorized)) in
      ControlFlow_Continue (never_to_any hoist92)
    else ControlFlow_Continue (ret_both (tt : 'unit)) in
    letb '(tmp0,out) := burn state v_TOKEN_ID_WCCD (f_amount params) (f_owner params) in
    letb state := tmp0 in
    letb hoist94 := out in
    letb hoist95 := f_branch hoist94 in
    letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] _ := matchb hoist95 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist93 := v_Break (prod_b (logger,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist93)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb unwrapped_amount := from_micro_ccd (f_amount params) in
    letb action := matchb f_receiver params with
    | Receiver_Account address =>
      f_simple_transfer address unwrapped_amount
    | Receiver_Contract address function =>
      f_send_raw address (as_ref function) unwrapped_amount (f_as_ref (f_data params))
    end in
    letb state_ret loc(state_ret_loc) := f_clone state in
    letb output := Result_Ok (prod_b (action,state_ret)) in
    prod_b (logger,output)))) : both (L1 :|: L2 :|: L3 :|: fset [state_ret_loc]) (I1 :|: I2 :|: I3) ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))).
Fail Next Obligation.

Notation "'t_TransferParameter'" := (t_TransferParams (t_TokenIdUnit)).

Definition actions_loc {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} : Location :=
  (v_A;2%nat).
Definition cursor_loc {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} : Location :=
  (f_ParamType;3%nat).
Definition state_ret_loc {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} : Location :=
  (t_State;4%nat).
Equations contract_transfer {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} (ctx : both L1 I1 (impl_574521470_)) (logger : both L2 I2 (impl_88511815_)) (state : both L3 I3 (t_State)) : both (L1 :|: L2 :|: L3 :|: fset [actions_loc;cursor_loc;state_ret_loc]) (I1 :|: I2 :|: I3) ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))) :=
  contract_transfer ctx logger state  :=
    solve_lift (run (letb cursor loc(cursor_loc) := f_parameter_cursor ctx in
    letb '(tmp0,out) := f_get cursor in
    letb cursor := tmp0 in
    letb hoist97 := out in
    letb hoist98 := f_branch hoist97 in
    letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] (transfers_length:int8) := matchb hoist98 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist96 := v_Break (prod_b (logger,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist96)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb sender := f_sender ctx in
    letb actions loc(actions_loc) := f_accept in
    letb '(actions,cursor,state) := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : int8)) (f_end := transfers_length))) (fun _ =>
      ssp (fun '(actions,cursor,state) =>
        letb '(tmp0,out) := f_get cursor in
        letb cursor := tmp0 in
        letb hoist100 := out in
        letb hoist101 := f_branch hoist100 in
        letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] {|
          f_token_id := token_id;
          f_amount := amount;
          f_from := from;
          f_to := to;
          f_data := data;
        |} := matchb hoist101 with
        | ControlFlow_Break residual =>
          letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist99 := v_Break (prod_b (logger,f_from_residual residual)) in
          ControlFlow_Continue (never_to_any hoist99)
        | ControlFlow_Continue val =>
          ControlFlow_Continue val
        end in
        letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] _ := ifb not (orb (from =.? sender) (is_operator state sender from))
        then letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist102 := v_Break (prod_b (logger,Result_Err Cis1Error_Unauthorized)) in
          ControlFlow_Continue (never_to_any hoist102)
        else ControlFlow_Continue (ret_both (tt : 'unit)) in
        letb to_address := address to in
        letb '(tmp0,out) := transfer state token_id amount from to_address in
        letb state := tmp0 in
        letb hoist104 := out in
        letb hoist105 := f_branch hoist104 in
        letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] _ := matchb hoist105 with
        | ControlFlow_Break residual =>
          letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist103 := v_Break (prod_b (logger,f_from_residual residual)) in
          ControlFlow_Continue (never_to_any hoist103)
        | ControlFlow_Continue val =>
          ControlFlow_Continue val
        end in
        ControlFlow_Continue (solve_lift matchb to with
        | Receiver_Contract address function =>
          letb parameter := Build_t_OnReceivingCis1Params (f_token_id := token_id) (f_amount := amount) (f_from := from) (f_contract_name := new_unchecked (f_from (ret_both (init_CIS1-Multi : chString)))) (f_data := data) in
          letb action := f_accept in
          letb actions := f_and_then actions action in
          prod_b (actions,cursor,state)
        | _ =>
          prod_b (actions,cursor,state)
        end) : both (*5*)(L1:|:L2:|:L3:|:L1:|:L2:|:L1:|:L3:|:fset [actions_loc;cursor_loc;cursor_loc;actions_loc;cursor_loc]) (I1:|:I2:|:I3:|:I1:|:I2:|:I1:|:I3) (t_ControlFlow ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))) ((v_A × f_ParamType × t_State))))) (prod_b (actions,cursor,state)) in
    letb state_ret loc(state_ret_loc) := f_clone state in
    letb output := Result_Ok (prod_b (actions,state_ret)) in
    prod_b (logger,output)))) : both (L1 :|: L2 :|: L3 :|: fset [actions_loc;cursor_loc;state_ret_loc]) (I1 :|: I2 :|: I3) ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))).
Fail Next Obligation.

Definition state_ret_loc {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} : Location :=
  (t_State;5%nat).
Equations contract_update_operator {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} (ctx : both L1 I1 (impl_574521470_)) (logger : both L2 I2 (impl_88511815_)) (state : both L3 I3 (t_State)) : both (L1 :|: L2 :|: L3 :|: fset [state_ret_loc]) (I1 :|: I2 :|: I3) ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))) :=
  contract_update_operator ctx logger state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] UpdateOperatorParams params := matchb f_branch out with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError))))] hoist106 := v_Break (prod_b (logger,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist106)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb sender := f_sender ctx in
    letb state := foldi_both_list (f_into_iter params) (fun param =>
      ssp (fun state =>
        solve_lift matchb f_update param with
        | OperatorUpdate_Add  =>
          add_operator state sender (f_operator param)
        | OperatorUpdate_Remove  =>
          remove_operator state sender (f_operator param)
        end : both (*0*)(L1:|:L2:|:L3:|:L1:|:L2:|:L3:|:fset []) (I1:|:I2:|:I3:|:I1:|:I2:|:I3) (t_State))) state in
    letb state_ret loc(state_ret_loc) := f_clone state in
    letb output := Result_Ok (prod_b (f_accept,state_ret)) in
    prod_b (logger,output)))) : both (L1 :|: L2 :|: L3 :|: fset [state_ret_loc]) (I1 :|: I2 :|: I3) ((impl_88511815_ × t_Result ((v_A × t_State)) (t_Cis1Error (t_CustomContractError)))).
Fail Next Obligation.

Notation "'t_ContractBalanceOfQueryParams'" := (t_BalanceOfQueryParams (t_TokenIdUnit)).

Equations contract_balance_of {L : {fset Location}} {I : Interface} {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} : both L I (t_Never) :=
  contract_balance_of  :=
    solve_lift (failure (ret_both ((AST import) Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: [import_thir:literal] got an error literal: this means the Rust compiler or Hax's frontend probably reported errors above.
 : chString)) (ret_both ({ Types.attributes = [];
  contents =
  Types.Literal {
    lit =
    { Types.node = Types.Err;
      span =
      { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/wccd.rs"));
        hi = { Types.col = "0"; line = "1" };
        lo = { Types.col = "0"; line = "1" } }
      };
    neg = false};
  hir_id = None;
  span =
  { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/wccd.rs"));
    hi = { Types.col = "61"; line = "540" };
    lo = { Types.col = "0"; line = "537" } };
  ty = Types.Never } : chString))) : both L I (t_Never).
Fail Next Obligation.

Equations contract_operator_of {L : {fset Location}} {I : Interface} {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} : both L I (t_Never) :=
  contract_operator_of  :=
    solve_lift (failure (ret_both ((AST import) Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: [import_thir:literal] got an error literal: this means the Rust compiler or Hax's frontend probably reported errors above.
 : chString)) (ret_both ({ Types.attributes = [];
  contents =
  Types.Literal {
    lit =
    { Types.node = Types.Err;
      span =
      { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/wccd.rs"));
        hi = { Types.col = "0"; line = "1" };
        lo = { Types.col = "0"; line = "1" } }
      };
    neg = false};
  hir_id = None;
  span =
  { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/wccd.rs"));
    hi = { Types.col = "61"; line = "580" };
    lo = { Types.col = "0"; line = "577" } };
  ty = Types.Never } : chString))) : both L I (t_Never).
Fail Next Obligation.

Notation "'t_ContractTokenMetadataQueryParams'" := (t_TokenMetadataQueryParams (t_TokenIdUnit)).

Equations contract_token_metadata {L : {fset Location}} {I : Interface} {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} : both L I (t_Never) :=
  contract_token_metadata  :=
    solve_lift (failure (ret_both ((AST import) Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: [import_thir:literal] got an error literal: this means the Rust compiler or Hax's frontend probably reported errors above.
 : chString)) (ret_both ({ Types.attributes = [];
  contents =
  Types.Literal {
    lit =
    { Types.node = Types.Err;
      span =
      { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/wccd.rs"));
        hi = { Types.col = "0"; line = "1" };
        lo = { Types.col = "0"; line = "1" } }
      };
    neg = false};
  hir_id = None;
  span =
  { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/wccd.rs"));
    hi = { Types.col = "61"; line = "623" };
    lo = { Types.col = "0"; line = "620" } };
  ty = Types.Never } : chString))) : both L I (t_Never).
Fail Next Obligation.

(** Concert lib part **)
From ConCert.Utils Require Import Extras.
Export Extras.
From ConCert.Utils Require Import Automation.
Export Automation.
From ConCert.Execution Require Import Serializable.
Export Serializable.
From ConCert.Execution Require Import Blockchain.
Export Blockchain.
From ConCert.Execution Require Import ContractCommon.
Export ContractCommon.
From ConCert.Execution Require Import Serializable.
Export Serializable.
Require Import ConCertLib.
Export ConCertLib.

Definition state_CIS1-wCCD : choice_type :=
  t_State.

Definition init_CIS1-wCCD (chain : Chain) (ctx : ContractCallContext) (st : state_CIS1-wCCD) : ResultMonad.result (state_CIS1-wCCD) (t_ParseError) :=
  ResultMonad.Ok st.

#[global] Program Instance t_WrapParams_t_HasReceiveContext : t_HasReceiveContext t_WrapParams 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance t_WrapParams_t_Sized : t_Sized t_WrapParams :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
Definition receive_CIS1-wCCD_wrap {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} (ctx : both L0 I0 (t_WrapParams)) (st : both L1 I1 (state_CIS1-wCCD)) : both _ _ (t_Result ((v_A × state_CIS1-wCCD)) (t_ParseError)) :=
  contract_wrap ctx st.

#[global] Program Instance t_UnwrapParams_t_HasReceiveContext : t_HasReceiveContext t_UnwrapParams 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance t_UnwrapParams_t_Sized : t_Sized t_UnwrapParams :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
Definition receive_CIS1-wCCD_unwrap {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} (ctx : both L0 I0 (t_UnwrapParams)) (st : both L1 I1 (state_CIS1-wCCD)) : both _ _ (t_Result ((v_A × state_CIS1-wCCD)) (t_ParseError)) :=
  contract_unwrap ctx st.

#[global] Program Instance t_TransferParameter_t_HasReceiveContext : t_HasReceiveContext t_TransferParameter 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance t_TransferParameter_t_Sized : t_Sized t_TransferParameter :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
Definition receive_CIS1-wCCD_transfer {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} (ctx : both L0 I0 (t_TransferParameter)) (st : both L1 I1 (state_CIS1-wCCD)) : both _ _ (t_Result ((v_A × state_CIS1-wCCD)) (t_ParseError)) :=
  contract_transfer ctx st.

#[global] Program Instance t_UpdateOperatorParams_t_HasReceiveContext : t_HasReceiveContext t_UpdateOperatorParams 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance t_UpdateOperatorParams_t_Sized : t_Sized t_UpdateOperatorParams :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
Definition receive_CIS1-wCCD_updateOperator {v_A : _} {impl_574521470_ : _} {impl_88511815_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_Sized (impl_88511815_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} `{ t_HasLogger (impl_88511815_)} {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} (ctx : both L0 I0 (t_UpdateOperatorParams)) (st : both L1 I1 (state_CIS1-wCCD)) : both _ _ (t_Result ((v_A × state_CIS1-wCCD)) (t_ParseError)) :=
  contract_update_operator ctx st.

#[global] Program Instance t_ContractBalanceOfQueryParams_t_HasReceiveContext : t_HasReceiveContext t_ContractBalanceOfQueryParams 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance t_ContractBalanceOfQueryParams_t_Sized : t_Sized t_ContractBalanceOfQueryParams :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
Definition receive_CIS1-wCCD_balanceOf {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} (ctx : both L0 I0 (t_ContractBalanceOfQueryParams)) (st : both L1 I1 (state_CIS1-wCCD)) : both _ _ (t_Result ((v_A × state_CIS1-wCCD)) (t_ParseError)) :=
  contract_balance_of ctx st.

#[global] Program Instance t_OperatorOfQueryParams_t_HasReceiveContext : t_HasReceiveContext t_OperatorOfQueryParams 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance t_OperatorOfQueryParams_t_Sized : t_Sized t_OperatorOfQueryParams :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
Definition receive_CIS1-wCCD_operatorOf {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} (ctx : both L0 I0 (t_OperatorOfQueryParams)) (st : both L1 I1 (state_CIS1-wCCD)) : both _ _ (t_Result ((v_A × state_CIS1-wCCD)) (t_ParseError)) :=
  contract_operator_of ctx st.

#[global] Program Instance t_ContractTokenMetadataQueryParams_t_HasReceiveContext : t_HasReceiveContext t_ContractTokenMetadataQueryParams 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance t_ContractTokenMetadataQueryParams_t_Sized : t_Sized t_ContractTokenMetadataQueryParams :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
Definition receive_CIS1-wCCD_tokenMetadata {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} (ctx : both L0 I0 (t_ContractTokenMetadataQueryParams)) (st : both L1 I1 (state_CIS1-wCCD)) : both _ _ (t_Result ((v_A × state_CIS1-wCCD)) (t_ParseError)) :=
  contract_token_metadata ctx st.

Inductive Msg_CIS1-wCCD: Type :=
| msg_CIS1-wCCD_wrap : t_WrapParams -> Msg_CIS1-wCCD
| msg_CIS1-wCCD_unwrap : t_UnwrapParams -> Msg_CIS1-wCCD
| msg_CIS1-wCCD_transfer : t_TransferParameter -> Msg_CIS1-wCCD
| msg_CIS1-wCCD_updateOperator : t_UpdateOperatorParams -> Msg_CIS1-wCCD
| msg_CIS1-wCCD_balanceOf : t_ContractBalanceOfQueryParams -> Msg_CIS1-wCCD
| msg_CIS1-wCCD_operatorOf : t_OperatorOfQueryParams -> Msg_CIS1-wCCD
| msg_CIS1-wCCD_tokenMetadata : t_ContractTokenMetadataQueryParams -> Msg_CIS1-wCCD.
#[global] Program Instance state_CIS1-wCCD_t_HasReceiveContext : t_HasReceiveContext state_CIS1-wCCD 'unit :=
  {| get := (fun  (x : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result x t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance state_CIS1-wCCD_t_Sized : t_Sized state_CIS1-wCCD :=
  {| Sized := (fun  (x : _) => x : _)|}.
Fail Next Obligation.
#[global] Program Instance state_CIS1-wCCD_t_HasActions : t_HasActions state_CIS1-wCCD :=
  _.
Fail Next Obligation.
Equations receive_CIS1-wCCD (chain : Chain) (ctx : ContractCallContext) (st : state_CIS1-wCCD) (msg : Datatypes.option Msg_CIS1-wCCD) : ResultMonad.result (state_CIS1-wCCD * list ActionBody) t_ParseError :=
  receive_CIS1-wCCD chain ctx st msg  :=
    matchb msg with
    | Some (msg_CIS1-wCCD_wrap val) =>
      match (is_pure (both_prog (receive_CIS1-wCCD_wrap (ret_both val) (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | Some (msg_CIS1-wCCD_unwrap val) =>
      match (is_pure (both_prog (receive_CIS1-wCCD_unwrap (ret_both val) (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | Some (msg_CIS1-wCCD_transfer val) =>
      match (is_pure (both_prog (receive_CIS1-wCCD_transfer (ret_both val) (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | Some (msg_CIS1-wCCD_updateOperator val) =>
      match (is_pure (both_prog (receive_CIS1-wCCD_updateOperator (ret_both val) (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | Some (msg_CIS1-wCCD_balanceOf val) =>
      match (is_pure (both_prog (receive_CIS1-wCCD_balanceOf (ret_both val) (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | Some (msg_CIS1-wCCD_operatorOf val) =>
      match (is_pure (both_prog (receive_CIS1-wCCD_operatorOf (ret_both val) (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | Some (msg_CIS1-wCCD_tokenMetadata val) =>
      match (is_pure (both_prog (receive_CIS1-wCCD_tokenMetadata (ret_both val) (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | _ =>
      ResultMonad.Err tt
    end : ResultMonad.result (state_CIS1-wCCD * list ActionBody) t_ParseError.
Fail Next Obligation.
#[global] Program Instance state_CIS1-wCCD_Serializable : Serializable state_CIS1-wCCD :=
  _.
Fail Next Obligation.
#[global] Program Instance Msg_CIS1-wCCD_Serializable : Serializable Msg_CIS1-wCCD :=
  Derive Serializable Msg_OVN_rect<msg_CIS1-wCCD_wrap,msg_CIS1-wCCD_unwrap,msg_CIS1-wCCD_transfer,msg_CIS1-wCCD_updateOperator,msg_CIS1-wCCD_balanceOf,msg_CIS1-wCCD_operatorOf,msg_CIS1-wCCD_tokenMetadata>.
Fail Next Obligation.
Definition contract_CIS1-wCCD : Contract (state_CIS1-wCCD) (Msg_CIS1-wCCD) (state_CIS1-wCCD) (t_ParseError) :=
  build_contract init_CIS1-wCCD receive_CIS1-wCCD.
