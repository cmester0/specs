(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_concordium.
Export Hacspec_concordium.

Require Import Box.
Export Box.

Require Import TryFrom.
Export TryFrom.

Require Import NonZeroI32.
Export NonZeroI32.

Equations v_TRANSFER_EVENT_TAG {L : {fset Location}} {I : Interface} : both L I (int8) :=
  v_TRANSFER_EVENT_TAG  :=
    solve_lift (ret_both (255 : int8)) : both L I (int8).
Fail Next Obligation.

Equations v_MINT_EVENT_TAG {L : {fset Location}} {I : Interface} : both L I (int8) :=
  v_MINT_EVENT_TAG  :=
    solve_lift ((ret_both (255 : int8)) .- (ret_both (1 : int8))) : both L I (int8).
Fail Next Obligation.

Equations v_BURN_EVENT_TAG {L : {fset Location}} {I : Interface} : both L I (int8) :=
  v_BURN_EVENT_TAG  :=
    solve_lift ((ret_both (255 : int8)) .- (ret_both (2 : int8))) : both L I (int8).
Fail Next Obligation.

Equations v_UPDATE_OPERATOR_EVENT_TAG {L : {fset Location}} {I : Interface} : both L I (int8) :=
  v_UPDATE_OPERATOR_EVENT_TAG  :=
    solve_lift ((ret_both (255 : int8)) .- (ret_both (3 : int8))) : both L I (int8).
Fail Next Obligation.

Equations v_TOKEN_METADATA_EVENT_TAG {L : {fset Location}} {I : Interface} : both L I (int8) :=
  v_TOKEN_METADATA_EVENT_TAG  :=
    solve_lift ((ret_both (255 : int8)) .- (ret_both (4 : int8))) : both L I (int8).
Fail Next Obligation.

Notation "'t_Sha256'" := (nseq int8 32).

Definition t_MetadataUrl : choice_type :=
  (t_String × t_Option (nseq int8 32)).
Equations f_url {L : {fset Location}} {I : Interface} (s : both L I (t_MetadataUrl)) : both L I (t_String) :=
  f_url s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : t_String))) : both L I (t_String).
Fail Next Obligation.
Equations f_hash {L : {fset Location}} {I : Interface} (s : both L I (t_MetadataUrl)) : both L I (t_Option (nseq int8 32)) :=
  f_hash s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Option (nseq int8 32)))) : both L I (t_Option (nseq int8 32)).
Fail Next Obligation.
Equations Build_t_MetadataUrl {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_url : both L0 I0 (t_String)} {f_hash : both L1 I1 (t_Option (nseq int8 32))} : both (L0:|:L1) (I0:|:I1) (t_MetadataUrl) :=
  Build_t_MetadataUrl  :=
    bind_both f_hash (fun f_hash =>
      bind_both f_url (fun f_url =>
        solve_lift (ret_both ((f_url,f_hash) : (t_MetadataUrl))))) : both (L0:|:L1) (I0:|:I1) (t_MetadataUrl).
Fail Next Obligation.
Notation "'Build_t_MetadataUrl' '[' x ']' '(' 'f_url' ':=' y ')'" := (Build_t_MetadataUrl (f_url := y) (f_hash := f_hash x)).
Notation "'Build_t_MetadataUrl' '[' x ']' '(' 'f_hash' ':=' y ')'" := (Build_t_MetadataUrl (f_url := f_url x) (f_hash := y)).

Class t_IsTokenId (Self : choice_type) := {
}.

Definition t_TokenIdVec : choice_type :=
  (t_Vec (int8) (t_Global)).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_TokenIdVec)) : both L I (t_Vec (int8) (t_Global)) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_Vec (int8) (t_Global)))) : both L I (t_Vec (int8) (t_Global)).
Fail Next Obligation.
Equations Build_t_TokenIdVec {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (t_Vec (int8) (t_Global))} : both L0 I0 (t_TokenIdVec) :=
  Build_t_TokenIdVec  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TokenIdVec)))) : both L0 I0 (t_TokenIdVec).
Fail Next Obligation.
Notation "'Build_t_TokenIdVec' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TokenIdVec (0 := y)).

#[global] Program Instance t_TokenIdVec_t_IsTokenId : t_IsTokenId t_TokenIdVec :=
  _.
Fail Next Obligation.
Hint Unfold t_TokenIdVec_t_IsTokenId.

#[global] Program Instance t_TokenIdVec_t_SchemaType : t_SchemaType t_TokenIdVec :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U8 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdVec_t_SchemaType.

Definition t_TokenIdFixed {v_N : both (fset []) (fset []) (uint_size)} : choice_type :=
  (nseq int8 (is_pure (v_N))).
Equations 0 {L : {fset Location}} {I : Interface} {v_N : both (fset []) (fset []) (uint_size)} (s : both L I (t_TokenIdFixed)) : both L I (nseq int8 (is_pure (v_N))) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : nseq int8 (is_pure (v_N))))) : both L I (nseq int8 (is_pure (v_N))).
Fail Next Obligation.
Equations Build_t_TokenIdFixed {L0 : {fset Location}} {I0 : Interface} {v_N : both (fset []) (fset []) (uint_size)} {0 : both L0 I0 (nseq int8 (is_pure (v_N)))} : both L0 I0 (t_TokenIdFixed) :=
  Build_t_TokenIdFixed  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TokenIdFixed)))) : both L0 I0 (t_TokenIdFixed).
Fail Next Obligation.
Notation "'Build_t_TokenIdFixed' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TokenIdFixed (0 := y)).

#[global] Program Instance t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_IsTokenId {v_N : both (fset []) (fset []) (uint_size)} : t_IsTokenId t_TokenIdFixed (both (fset []) (fset []) (uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_IsTokenId.

#[global] Program Instance t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_SchemaType {v_N : both (fset []) (fset []) (uint_size)} : t_SchemaType t_TokenIdFixed (both (fset []) (fset []) (uint_size)) :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U8 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_SchemaType.

#[global] Program Instance t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_From {v_N : both (fset []) (fset []) (uint_size)} : t_From t_TokenIdFixed (both (fset []) (fset []) (uint_size)) nseq int8 (is_pure (v_N)) :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (id : both L1 I1 (nseq int8 (is_pure (v_N)))) => TokenIdFixed (solve_lift id) : both (L1 :|: fset []) I1 (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_From.

#[global] Program Instance t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_Serial {v_N : both (fset []) (fset []) (uint_size)} : t_Serial t_TokenIdFixed (both (fset []) (fset []) (uint_size)) :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_TokenIdFixed (both (fset []) (fset []) (uint_size)))) (out : both L2 I2 (v_W)) => solve_lift (run (letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] len := matchb f_branch (map_err (f_try_from v_N) (fun _ =>
      f_default)) with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist1 := v_Break (prod_b (out,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist1)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  letb '(tmp0,out) := f_write_u8 out len in
  letb out := tmp0 in
  letb hoist3 := out in
  letb hoist4 := f_branch hoist3 in
  letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist4 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist2 := v_Break (prod_b (out,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist2)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb out := foldi_both_list (f_into_iter (0 self)) (fun byte =>
    ssp (fun out =>
      letb '(tmp0,out) := f_write_u8 out byte in
      letb out := tmp0 in
      letb hoist6 := out in
      letb hoist7 := f_branch hoist6 in
      solve_lift matchb hoist7 with
      | ControlFlow_Break residual =>
        letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist5 := v_Break (prod_b (out,f_from_residual residual)) in
        ControlFlow_Continue out
      | ControlFlow_Continue val =>
        ControlFlow_Continue out
      end : both (*0*)(L1:|:L2:|:L1:|:L2:|:fset []) (I1:|:I2:|:I1:|:I2) (t_ControlFlow ((v_W × t_Result ('unit) (f_Err))) (v_W)))) out in
  letb output := Result_Ok (ret_both (tt : 'unit)) in
  prod_b (out,output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) ((v_W × t_Result ('unit) (f_Err))) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_Serial.

#[global] Program Instance t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_Deserial {v_N : both (fset []) (fset []) (uint_size)} : t_Deserial t_TokenIdFixed (both (fset []) (fset []) (uint_size)) :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (source : both L1 I1 (v_R)) => solve_lift (run (letb '(tmp0,out) := f_read_u8 source in
  letb source := tmp0 in
  letb hoist9 := out in
  letb hoist10 := f_branch hoist9 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) (t_ParseError)))] byte_length := ControlFlow_Continue matchb hoist10 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) (t_ParseError)))] hoist8 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist8)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) (t_ParseError)))] _ := ControlFlow_Continue (ifb (f_from byte_length) <> v_N
  then letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) (t_ParseError)))] hoist11 := v_Break (prod_b (source,Result_Err f_default)) in
    ControlFlow_Continue (never_to_any hoist11)
  else ControlFlow_Continue (ret_both (tt : 'unit))) in
  letb '(tmp0,out) := f_get source in
  letb source := tmp0 in
  letb hoist13 := out in
  letb hoist14 := f_branch hoist13 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) (t_ParseError)))] (bytes:nseq int8 (is_pure (v_N))) := matchb hoist14 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) (t_ParseError)))] hoist12 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist12)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb output := Result_Ok (TokenIdFixed bytes) in
  prod_b (source,output)))) : both (L1 :|: fset []) I1 ((v_R × t_Result (t_TokenIdFixed (both (fset []) (fset []) (uint_size))) (t_ParseError))) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdFixed (both (fset []) (fset []) (uint_size))_t_Deserial.

Definition t_TokenIdU64 : choice_type :=
  (int64).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_TokenIdU64)) : both L I (int64) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : int64))) : both L I (int64).
Fail Next Obligation.
Equations Build_t_TokenIdU64 {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (int64)} : both L0 I0 (t_TokenIdU64) :=
  Build_t_TokenIdU64  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TokenIdU64)))) : both L0 I0 (t_TokenIdU64).
Fail Next Obligation.
Notation "'Build_t_TokenIdU64' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TokenIdU64 (0 := y)).

#[global] Program Instance t_TokenIdU64_t_IsTokenId : t_IsTokenId t_TokenIdU64 :=
  _.
Fail Next Obligation.
Hint Unfold t_TokenIdU64_t_IsTokenId.

#[global] Program Instance t_TokenIdU64_t_SchemaType : t_SchemaType t_TokenIdU64 :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U8 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU64_t_SchemaType.

#[global] Program Instance t_TokenIdU64_t_From : t_From t_TokenIdU64 int64 :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (id : both L1 I1 (int64)) => TokenIdU64 (solve_lift id) : both (L1 :|: fset []) I1 (t_TokenIdU64) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU64_t_From.

#[global] Program Instance t_TokenIdU64_t_Serial : t_Serial t_TokenIdU64 :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_TokenIdU64)) (out : both L2 I2 (v_W)) => solve_lift (run (letb '(tmp0,out) := f_write_u8 out (ret_both (8 : int8)) in
  letb out := tmp0 in
  letb hoist16 := out in
  letb hoist17 := f_branch hoist16 in
  letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist17 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist15 := v_Break (prod_b (out,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist15)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb '(tmp0,out) := f_write_u64 out (0 self) in
  letb out := tmp0 in
  letb output := out in
  prod_b (out,output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) ((v_W × t_Result ('unit) (f_Err))) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU64_t_Serial.

#[global] Program Instance t_TokenIdU64_t_Deserial : t_Deserial t_TokenIdU64 :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (source : both L1 I1 (v_R)) => solve_lift (run (letb '(tmp0,out) := f_read_u8 source in
  letb source := tmp0 in
  letb hoist19 := out in
  letb hoist20 := f_branch hoist19 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU64) (t_ParseError)))] byte_length := matchb hoist20 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU64) (t_ParseError)))] hoist18 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist18)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU64) (t_ParseError)))] '(source,output) := ifb byte_length =.? (ret_both (8 : int8))
  then letb '(tmp0,out) := f_read_u64 source in
    letb source := tmp0 in
    letb hoist22 := out in
    letb hoist23 := f_branch hoist22 in
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU64) (t_ParseError)))] hoist24 := matchb hoist23 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU64) (t_ParseError)))] hoist21 := v_Break (prod_b (source,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist21)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hoist25 := TokenIdU64 hoist24 in
    prod_b (source,Result_Ok hoist25))
  else ControlFlow_Continue (prod_b (source,Result_Err f_default)) in
  ControlFlow_Continue (prod_b (source,output)))) : both (L1 :|: fset []) I1 ((v_R × t_Result (t_TokenIdU64) (t_ParseError))) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU64_t_Deserial.

Definition t_TokenIdU32 : choice_type :=
  (int32).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_TokenIdU32)) : both L I (int32) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : int32))) : both L I (int32).
Fail Next Obligation.
Equations Build_t_TokenIdU32 {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (int32)} : both L0 I0 (t_TokenIdU32) :=
  Build_t_TokenIdU32  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TokenIdU32)))) : both L0 I0 (t_TokenIdU32).
Fail Next Obligation.
Notation "'Build_t_TokenIdU32' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TokenIdU32 (0 := y)).

#[global] Program Instance t_TokenIdU32_t_IsTokenId : t_IsTokenId t_TokenIdU32 :=
  _.
Fail Next Obligation.
Hint Unfold t_TokenIdU32_t_IsTokenId.

#[global] Program Instance t_TokenIdU32_t_SchemaType : t_SchemaType t_TokenIdU32 :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U8 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU32_t_SchemaType.

#[global] Program Instance t_TokenIdU32_t_From : t_From t_TokenIdU32 int32 :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (id : both L1 I1 (int32)) => TokenIdU32 (solve_lift id) : both (L1 :|: fset []) I1 (t_TokenIdU32) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU32_t_From.

#[global] Program Instance t_TokenIdU32_t_Serial : t_Serial t_TokenIdU32 :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_TokenIdU32)) (out : both L2 I2 (v_W)) => solve_lift (run (letb '(tmp0,out) := f_write_u8 out (ret_both (4 : int8)) in
  letb out := tmp0 in
  letb hoist27 := out in
  letb hoist28 := f_branch hoist27 in
  letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist28 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist26 := v_Break (prod_b (out,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist26)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb '(tmp0,out) := f_write_u32 out (0 self) in
  letb out := tmp0 in
  letb output := out in
  prod_b (out,output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) ((v_W × t_Result ('unit) (f_Err))) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU32_t_Serial.

#[global] Program Instance t_TokenIdU32_t_Deserial : t_Deserial t_TokenIdU32 :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (source : both L1 I1 (v_R)) => solve_lift (run (letb '(tmp0,out) := f_read_u8 source in
  letb source := tmp0 in
  letb hoist30 := out in
  letb hoist31 := f_branch hoist30 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU32) (t_ParseError)))] byte_length := matchb hoist31 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU32) (t_ParseError)))] hoist29 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist29)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU32) (t_ParseError)))] '(source,output) := ifb byte_length =.? (ret_both (4 : int8))
  then letb '(tmp0,out) := f_read_u32 source in
    letb source := tmp0 in
    letb hoist33 := out in
    letb hoist34 := f_branch hoist33 in
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU32) (t_ParseError)))] hoist35 := matchb hoist34 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU32) (t_ParseError)))] hoist32 := v_Break (prod_b (source,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist32)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hoist36 := TokenIdU32 hoist35 in
    prod_b (source,Result_Ok hoist36))
  else ControlFlow_Continue (prod_b (source,Result_Err f_default)) in
  ControlFlow_Continue (prod_b (source,output)))) : both (L1 :|: fset []) I1 ((v_R × t_Result (t_TokenIdU32) (t_ParseError))) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU32_t_Deserial.

Definition t_TokenIdU16 : choice_type :=
  (int16).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_TokenIdU16)) : both L I (int16) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : int16))) : both L I (int16).
Fail Next Obligation.
Equations Build_t_TokenIdU16 {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (int16)} : both L0 I0 (t_TokenIdU16) :=
  Build_t_TokenIdU16  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TokenIdU16)))) : both L0 I0 (t_TokenIdU16).
Fail Next Obligation.
Notation "'Build_t_TokenIdU16' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TokenIdU16 (0 := y)).

#[global] Program Instance t_TokenIdU16_t_IsTokenId : t_IsTokenId t_TokenIdU16 :=
  _.
Fail Next Obligation.
Hint Unfold t_TokenIdU16_t_IsTokenId.

#[global] Program Instance t_TokenIdU16_t_SchemaType : t_SchemaType t_TokenIdU16 :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U8 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU16_t_SchemaType.

#[global] Program Instance t_TokenIdU16_t_From : t_From t_TokenIdU16 int16 :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (id : both L1 I1 (int16)) => TokenIdU16 (solve_lift id) : both (L1 :|: fset []) I1 (t_TokenIdU16) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU16_t_From.

#[global] Program Instance t_TokenIdU16_t_Serial : t_Serial t_TokenIdU16 :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_TokenIdU16)) (out : both L2 I2 (v_W)) => solve_lift (run (letb '(tmp0,out) := f_write_u8 out (ret_both (2 : int8)) in
  letb out := tmp0 in
  letb hoist38 := out in
  letb hoist39 := f_branch hoist38 in
  letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist39 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist37 := v_Break (prod_b (out,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist37)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb '(tmp0,out) := f_write_u16 out (0 self) in
  letb out := tmp0 in
  letb output := out in
  prod_b (out,output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) ((v_W × t_Result ('unit) (f_Err))) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU16_t_Serial.

#[global] Program Instance t_TokenIdU16_t_Deserial : t_Deserial t_TokenIdU16 :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (source : both L1 I1 (v_R)) => solve_lift (run (letb '(tmp0,out) := f_read_u8 source in
  letb source := tmp0 in
  letb hoist41 := out in
  letb hoist42 := f_branch hoist41 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU16) (t_ParseError)))] byte_length := matchb hoist42 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU16) (t_ParseError)))] hoist40 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist40)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU16) (t_ParseError)))] '(source,output) := ifb byte_length =.? (ret_both (2 : int8))
  then letb '(tmp0,out) := f_read_u16 source in
    letb source := tmp0 in
    letb hoist44 := out in
    letb hoist45 := f_branch hoist44 in
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU16) (t_ParseError)))] hoist46 := matchb hoist45 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU16) (t_ParseError)))] hoist43 := v_Break (prod_b (source,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist43)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hoist47 := TokenIdU16 hoist46 in
    prod_b (source,Result_Ok hoist47))
  else ControlFlow_Continue (prod_b (source,Result_Err f_default)) in
  ControlFlow_Continue (prod_b (source,output)))) : both (L1 :|: fset []) I1 ((v_R × t_Result (t_TokenIdU16) (t_ParseError))) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU16_t_Deserial.

Definition t_TokenIdU8 : choice_type :=
  (int8).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_TokenIdU8)) : both L I (int8) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : int8))) : both L I (int8).
Fail Next Obligation.
Equations Build_t_TokenIdU8 {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (int8)} : both L0 I0 (t_TokenIdU8) :=
  Build_t_TokenIdU8  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TokenIdU8)))) : both L0 I0 (t_TokenIdU8).
Fail Next Obligation.
Notation "'Build_t_TokenIdU8' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TokenIdU8 (0 := y)).

#[global] Program Instance t_TokenIdU8_t_IsTokenId : t_IsTokenId t_TokenIdU8 :=
  _.
Fail Next Obligation.
Hint Unfold t_TokenIdU8_t_IsTokenId.

#[global] Program Instance t_TokenIdU8_t_SchemaType : t_SchemaType t_TokenIdU8 :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U8 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU8_t_SchemaType.

#[global] Program Instance t_TokenIdU8_t_From : t_From t_TokenIdU8 int8 :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (id : both L1 I1 (int8)) => TokenIdU8 (solve_lift id) : both (L1 :|: fset []) I1 (t_TokenIdU8) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU8_t_From.

#[global] Program Instance t_TokenIdU8_t_Serial : t_Serial t_TokenIdU8 :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_TokenIdU8)) (out : both L2 I2 (v_W)) => solve_lift (run (letb '(tmp0,out) := f_write_u8 out (ret_both (1 : int8)) in
  letb out := tmp0 in
  letb hoist49 := out in
  letb hoist50 := f_branch hoist49 in
  letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist50 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist48 := v_Break (prod_b (out,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist48)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb '(tmp0,out) := f_write_u8 out (0 self) in
  letb out := tmp0 in
  letb output := out in
  prod_b (out,output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) ((v_W × t_Result ('unit) (f_Err))) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU8_t_Serial.

#[global] Program Instance t_TokenIdU8_t_Deserial : t_Deserial t_TokenIdU8 :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (source : both L1 I1 (v_R)) => solve_lift (run (letb '(tmp0,out) := f_read_u8 source in
  letb source := tmp0 in
  letb hoist52 := out in
  letb hoist53 := f_branch hoist52 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU8) (t_ParseError)))] byte_length := matchb hoist53 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU8) (t_ParseError)))] hoist51 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist51)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU8) (t_ParseError)))] '(source,output) := ifb byte_length =.? (ret_both (1 : int8))
  then letb '(tmp0,out) := f_read_u8 source in
    letb source := tmp0 in
    letb hoist55 := out in
    letb hoist56 := f_branch hoist55 in
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU8) (t_ParseError)))] hoist57 := matchb hoist56 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdU8) (t_ParseError)))] hoist54 := v_Break (prod_b (source,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist54)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hoist58 := TokenIdU8 hoist57 in
    prod_b (source,Result_Ok hoist58))
  else ControlFlow_Continue (prod_b (source,Result_Err f_default)) in
  ControlFlow_Continue (prod_b (source,output)))) : both (L1 :|: fset []) I1 ((v_R × t_Result (t_TokenIdU8) (t_ParseError))) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdU8_t_Deserial.

Definition t_TokenIdUnit : choice_type :=
  'unit.
Equations Build_t_TokenIdUnit : both (fset []) (fset []) (t_TokenIdUnit) :=
  Build_t_TokenIdUnit  :=
    solve_lift (ret_both ((_) : (t_TokenIdUnit))) : both (fset []) (fset []) (t_TokenIdUnit).
Fail Next Obligation.

#[global] Program Instance t_TokenIdUnit_t_IsTokenId : t_IsTokenId t_TokenIdUnit :=
  _.
Fail Next Obligation.
Hint Unfold t_TokenIdUnit_t_IsTokenId.

#[global] Program Instance t_TokenIdUnit_t_SchemaType : t_SchemaType t_TokenIdUnit :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U8 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdUnit_t_SchemaType.

#[global] Program Instance t_TokenIdUnit_t_Serial : t_Serial t_TokenIdUnit :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_TokenIdUnit)) (out : both L2 I2 (v_W)) => letb '(tmp0,out) := f_write_u8 out (ret_both (0 : int8)) in
  letb out := tmp0 in
  letb output := out in
  solve_lift (prod_b (out,output)) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) ((v_W × t_Result ('unit) (f_Err))) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdUnit_t_Serial.

#[global] Program Instance t_TokenIdUnit_t_Deserial : t_Deserial t_TokenIdUnit :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (source : both L1 I1 (v_R)) => solve_lift (run (letb '(tmp0,out) := f_read_u8 source in
  letb source := tmp0 in
  letb hoist60 := out in
  letb hoist61 := f_branch hoist60 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdUnit) (t_ParseError)))] byte_length := matchb hoist61 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_TokenIdUnit) (t_ParseError)))] hoist59 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist59)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb output := ifb byte_length =.? (ret_both (0 : int8))
  then Result_Ok TokenIdUnit
  else Result_Err f_default in
  prod_b (source,output)))) : both (L1 :|: fset []) I1 ((v_R × t_Result (t_TokenIdUnit) (t_ParseError))) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_TokenIdUnit_t_Deserial.

Notation "'t_TokenAmount'" := (int64).

Definition t_TransferEvent {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (v_T × int64 × t_Address × t_Address).
Equations f_token_id {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TransferEvent)) : both L I (v_T) :=
  f_token_id s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst x)) : v_T))) : both L I (v_T).
Fail Next Obligation.
Equations f_amount {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TransferEvent)) : both L I (int64) :=
  f_amount s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : int64))) : both L I (int64).
Fail Next Obligation.
Equations f_from {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TransferEvent)) : both L I (t_Address) :=
  f_from s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations f_to {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TransferEvent)) : both L I (t_Address) :=
  f_to s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations Build_t_TransferEvent {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_token_id : both L0 I0 (v_T)} {f_amount : both L1 I1 (int64)} {f_from : both L2 I2 (t_Address)} {f_to : both L3 I3 (t_Address)} : both (L0:|:L1:|:L2:|:L3) (I0:|:I1:|:I2:|:I3) (t_TransferEvent) :=
  Build_t_TransferEvent  :=
    bind_both f_to (fun f_to =>
      bind_both f_from (fun f_from =>
        bind_both f_amount (fun f_amount =>
          bind_both f_token_id (fun f_token_id =>
            solve_lift (ret_both ((f_token_id,f_amount,f_from,f_to) : (t_TransferEvent))))))) : both (L0:|:L1:|:L2:|:L3) (I0:|:I1:|:I2:|:I3) (t_TransferEvent).
Fail Next Obligation.
Notation "'Build_t_TransferEvent' '[' x ']' '(' 'f_token_id' ':=' y ')'" := (Build_t_TransferEvent (f_token_id := y) (f_amount := f_amount x) (f_from := f_from x) (f_to := f_to x)).
Notation "'Build_t_TransferEvent' '[' x ']' '(' 'f_amount' ':=' y ')'" := (Build_t_TransferEvent (f_token_id := f_token_id x) (f_amount := y) (f_from := f_from x) (f_to := f_to x)).
Notation "'Build_t_TransferEvent' '[' x ']' '(' 'f_from' ':=' y ')'" := (Build_t_TransferEvent (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := y) (f_to := f_to x)).
Notation "'Build_t_TransferEvent' '[' x ']' '(' 'f_to' ':=' y ')'" := (Build_t_TransferEvent (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := f_from x) (f_to := y)).

Definition t_MintEvent {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (v_T × int64 × t_Address).
Equations f_token_id {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_MintEvent)) : both L I (v_T) :=
  f_token_id s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : v_T))) : both L I (v_T).
Fail Next Obligation.
Equations f_amount {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_MintEvent)) : both L I (int64) :=
  f_amount s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : int64))) : both L I (int64).
Fail Next Obligation.
Equations f_owner {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_MintEvent)) : both L I (t_Address) :=
  f_owner s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations Build_t_MintEvent {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_token_id : both L0 I0 (v_T)} {f_amount : both L1 I1 (int64)} {f_owner : both L2 I2 (t_Address)} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_MintEvent) :=
  Build_t_MintEvent  :=
    bind_both f_owner (fun f_owner =>
      bind_both f_amount (fun f_amount =>
        bind_both f_token_id (fun f_token_id =>
          solve_lift (ret_both ((f_token_id,f_amount,f_owner) : (t_MintEvent)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_MintEvent).
Fail Next Obligation.
Notation "'Build_t_MintEvent' '[' x ']' '(' 'f_token_id' ':=' y ')'" := (Build_t_MintEvent (f_token_id := y) (f_amount := f_amount x) (f_owner := f_owner x)).
Notation "'Build_t_MintEvent' '[' x ']' '(' 'f_amount' ':=' y ')'" := (Build_t_MintEvent (f_token_id := f_token_id x) (f_amount := y) (f_owner := f_owner x)).
Notation "'Build_t_MintEvent' '[' x ']' '(' 'f_owner' ':=' y ')'" := (Build_t_MintEvent (f_token_id := f_token_id x) (f_amount := f_amount x) (f_owner := y)).

Definition t_BurnEvent {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (v_T × int64 × t_Address).
Equations f_token_id {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BurnEvent)) : both L I (v_T) :=
  f_token_id s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : v_T))) : both L I (v_T).
Fail Next Obligation.
Equations f_amount {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BurnEvent)) : both L I (int64) :=
  f_amount s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : int64))) : both L I (int64).
Fail Next Obligation.
Equations f_owner {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BurnEvent)) : both L I (t_Address) :=
  f_owner s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations Build_t_BurnEvent {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_token_id : both L0 I0 (v_T)} {f_amount : both L1 I1 (int64)} {f_owner : both L2 I2 (t_Address)} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_BurnEvent) :=
  Build_t_BurnEvent  :=
    bind_both f_owner (fun f_owner =>
      bind_both f_amount (fun f_amount =>
        bind_both f_token_id (fun f_token_id =>
          solve_lift (ret_both ((f_token_id,f_amount,f_owner) : (t_BurnEvent)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_BurnEvent).
Fail Next Obligation.
Notation "'Build_t_BurnEvent' '[' x ']' '(' 'f_token_id' ':=' y ')'" := (Build_t_BurnEvent (f_token_id := y) (f_amount := f_amount x) (f_owner := f_owner x)).
Notation "'Build_t_BurnEvent' '[' x ']' '(' 'f_amount' ':=' y ')'" := (Build_t_BurnEvent (f_token_id := f_token_id x) (f_amount := y) (f_owner := f_owner x)).
Notation "'Build_t_BurnEvent' '[' x ']' '(' 'f_owner' ':=' y ')'" := (Build_t_BurnEvent (f_token_id := f_token_id x) (f_amount := f_amount x) (f_owner := y)).

Definition t_OperatorUpdate : choice_type :=
  chFin (mkpos 2).
Equations OperatorUpdate_Remove {L : {fset Location}} {I : Interface} : both L I t_OperatorUpdate :=
  OperatorUpdate_Remove  :=
    solve_lift ret_both (fintype.Ordinal (n:=2) (m:=0) eq_refl : t_OperatorUpdate) : both L I t_OperatorUpdate.
Fail Next Obligation.
Equations OperatorUpdate_Add {L : {fset Location}} {I : Interface} : both L I t_OperatorUpdate :=
  OperatorUpdate_Add  :=
    solve_lift ret_both (fintype.Ordinal (n:=2) (m:=1) eq_refl : t_OperatorUpdate) : both L I t_OperatorUpdate.
Fail Next Obligation.

Definition t_UpdateOperatorEvent : choice_type :=
  (t_OperatorUpdate × t_Address × t_Address).
Equations f_update {L : {fset Location}} {I : Interface} (s : both L I (t_UpdateOperatorEvent)) : both L I (t_OperatorUpdate) :=
  f_update s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : t_OperatorUpdate))) : both L I (t_OperatorUpdate).
Fail Next Obligation.
Equations f_owner {L : {fset Location}} {I : Interface} (s : both L I (t_UpdateOperatorEvent)) : both L I (t_Address) :=
  f_owner s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations f_operator {L : {fset Location}} {I : Interface} (s : both L I (t_UpdateOperatorEvent)) : both L I (t_Address) :=
  f_operator s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations Build_t_UpdateOperatorEvent {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {f_update : both L0 I0 (t_OperatorUpdate)} {f_owner : both L1 I1 (t_Address)} {f_operator : both L2 I2 (t_Address)} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_UpdateOperatorEvent) :=
  Build_t_UpdateOperatorEvent  :=
    bind_both f_operator (fun f_operator =>
      bind_both f_owner (fun f_owner =>
        bind_both f_update (fun f_update =>
          solve_lift (ret_both ((f_update,f_owner,f_operator) : (t_UpdateOperatorEvent)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_UpdateOperatorEvent).
Fail Next Obligation.
Notation "'Build_t_UpdateOperatorEvent' '[' x ']' '(' 'f_update' ':=' y ')'" := (Build_t_UpdateOperatorEvent (f_update := y) (f_owner := f_owner x) (f_operator := f_operator x)).
Notation "'Build_t_UpdateOperatorEvent' '[' x ']' '(' 'f_owner' ':=' y ')'" := (Build_t_UpdateOperatorEvent (f_update := f_update x) (f_owner := y) (f_operator := f_operator x)).
Notation "'Build_t_UpdateOperatorEvent' '[' x ']' '(' 'f_operator' ':=' y ')'" := (Build_t_UpdateOperatorEvent (f_update := f_update x) (f_owner := f_owner x) (f_operator := y)).

Definition t_TokenMetadataEvent {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (v_T × t_MetadataUrl).
Equations f_token_id {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TokenMetadataEvent)) : both L I (v_T) :=
  f_token_id s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : v_T))) : both L I (v_T).
Fail Next Obligation.
Equations f_metadata_url {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TokenMetadataEvent)) : both L I (t_MetadataUrl) :=
  f_metadata_url s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_MetadataUrl))) : both L I (t_MetadataUrl).
Fail Next Obligation.
Equations Build_t_TokenMetadataEvent {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_token_id : both L0 I0 (v_T)} {f_metadata_url : both L1 I1 (t_MetadataUrl)} : both (L0:|:L1) (I0:|:I1) (t_TokenMetadataEvent) :=
  Build_t_TokenMetadataEvent  :=
    bind_both f_metadata_url (fun f_metadata_url =>
      bind_both f_token_id (fun f_token_id =>
        solve_lift (ret_both ((f_token_id,f_metadata_url) : (t_TokenMetadataEvent))))) : both (L0:|:L1) (I0:|:I1) (t_TokenMetadataEvent).
Fail Next Obligation.
Notation "'Build_t_TokenMetadataEvent' '[' x ']' '(' 'f_token_id' ':=' y ')'" := (Build_t_TokenMetadataEvent (f_token_id := y) (f_metadata_url := f_metadata_url x)).
Notation "'Build_t_TokenMetadataEvent' '[' x ']' '(' 'f_metadata_url' ':=' y ')'" := (Build_t_TokenMetadataEvent (f_token_id := f_token_id x) (f_metadata_url := y)).

Definition t_Cis1Event {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  chFin (mkpos 5).
Equations Cis1Event_Transfer {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_TransferEvent (v_T) (both L I t_Cis1Event) :=
  Cis1Event_Transfer  :=
    solve_lift ret_both (fintype.Ordinal (n:=5) (m:=0) eq_refl : t_Cis1Event) : t_TransferEvent (v_T) (both L I t_Cis1Event).
Fail Next Obligation.
Equations Cis1Event_Mint {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_MintEvent (v_T) (both L I t_Cis1Event) :=
  Cis1Event_Mint  :=
    solve_lift ret_both (fintype.Ordinal (n:=5) (m:=1) eq_refl : t_Cis1Event) : t_MintEvent (v_T) (both L I t_Cis1Event).
Fail Next Obligation.
Equations Cis1Event_Burn {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_BurnEvent (v_T) (both L I t_Cis1Event) :=
  Cis1Event_Burn  :=
    solve_lift ret_both (fintype.Ordinal (n:=5) (m:=2) eq_refl : t_Cis1Event) : t_BurnEvent (v_T) (both L I t_Cis1Event).
Fail Next Obligation.
Equations Cis1Event_UpdateOperator {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_UpdateOperatorEvent (both L I t_Cis1Event) :=
  Cis1Event_UpdateOperator  :=
    solve_lift ret_both (fintype.Ordinal (n:=5) (m:=3) eq_refl : t_Cis1Event) : t_UpdateOperatorEvent (both L I t_Cis1Event).
Fail Next Obligation.
Equations Cis1Event_TokenMetadata {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_TokenMetadataEvent (v_T) (both L I t_Cis1Event) :=
  Cis1Event_TokenMetadata  :=
    solve_lift ret_both (fintype.Ordinal (n:=5) (m:=4) eq_refl : t_Cis1Event) : t_TokenMetadataEvent (v_T) (both L I t_Cis1Event).
Fail Next Obligation.

#[global] Program Instance t_Cis1Event (v_T)_t_Serial {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_Serial t_Cis1Event (v_T) :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Cis1Event (v_T))) (out : both L2 I2 (v_W)) => solve_lift (run (letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] '(out,output) := matchb self with
  | Cis1Event_Transfer event =>
    letb '(tmp0,out) := f_write_u8 out v_TRANSFER_EVENT_TAG in
    letb out := tmp0 in
    letb hoist63 := out in
    letb hoist64 := f_branch hoist63 in
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist64 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist62 := v_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist62)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := f_serial event out in
    letb out := tmp0 in
    prod_b (out,out))
  | Cis1Event_Mint event =>
    letb '(tmp0,out) := f_write_u8 out v_MINT_EVENT_TAG in
    letb out := tmp0 in
    letb hoist66 := out in
    letb hoist67 := f_branch hoist66 in
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist67 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist65 := v_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist65)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := f_serial event out in
    letb out := tmp0 in
    prod_b (out,out))
  | Cis1Event_Burn event =>
    letb '(tmp0,out) := f_write_u8 out v_BURN_EVENT_TAG in
    letb out := tmp0 in
    letb hoist69 := out in
    letb hoist70 := f_branch hoist69 in
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist70 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist68 := v_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist68)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := f_serial event out in
    letb out := tmp0 in
    prod_b (out,out))
  | Cis1Event_UpdateOperator event =>
    letb '(tmp0,out) := f_write_u8 out v_UPDATE_OPERATOR_EVENT_TAG in
    letb out := tmp0 in
    letb hoist72 := out in
    letb hoist73 := f_branch hoist72 in
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist73 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist71 := v_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist71)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := f_serial event out in
    letb out := tmp0 in
    prod_b (out,out))
  | Cis1Event_TokenMetadata event =>
    letb '(tmp0,out) := f_write_u8 out v_TOKEN_METADATA_EVENT_TAG in
    letb out := tmp0 in
    letb hoist75 := out in
    letb hoist76 := f_branch hoist75 in
    letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] _ := matchb hoist76 with
    | ControlFlow_Break residual =>
      letm[choice_typeMonad.result_bind_code ((v_W × t_Result ('unit) (f_Err)))] hoist74 := v_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist74)
    | ControlFlow_Continue val =>
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := f_serial event out in
    letb out := tmp0 in
    prod_b (out,out))
  end in
  ControlFlow_Continue (prod_b (out,output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) ((v_W × t_Result ('unit) (f_Err))) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_Cis1Event (v_T)_t_Serial.

#[global] Program Instance t_Cis1Event (v_T)_t_Deserial {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_Deserial t_Cis1Event (v_T) :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (source : both L1 I1 (v_R)) => solve_lift (run (letb '(tmp0,out) := f_read_u8 source in
  letb source := tmp0 in
  letb hoist78 := out in
  letb hoist79 := f_branch hoist78 in
  letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_Cis1Event (v_T)) (t_ParseError)))] tag := matchb hoist79 with
  | ControlFlow_Break residual =>
    letm[choice_typeMonad.result_bind_code ((v_R × t_Result (t_Cis1Event (v_T)) (t_ParseError)))] hoist77 := v_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist77)
  | ControlFlow_Continue val =>
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb '(source,output) := matchb tag with
  | 255 =>
    letb '(tmp0,out) := f_deserial source in
    letb source := tmp0 in
    letb hoist80 := out in
    prod_b (source,map hoist80 v_Transfer)
  | 254 =>
    letb '(tmp0,out) := f_deserial source in
    letb source := tmp0 in
    letb hoist81 := out in
    prod_b (source,map hoist81 v_Mint)
  | 253 =>
    letb '(tmp0,out) := f_deserial source in
    letb source := tmp0 in
    letb hoist82 := out in
    prod_b (source,map hoist82 v_Burn)
  | 252 =>
    letb '(tmp0,out) := f_deserial source in
    letb source := tmp0 in
    letb hoist83 := out in
    prod_b (source,map hoist83 v_UpdateOperator)
  | 251 =>
    letb '(tmp0,out) := f_deserial source in
    letb source := tmp0 in
    letb hoist84 := out in
    prod_b (source,map hoist84 v_TokenMetadata)
  | _ =>
    prod_b (source,Result_Err f_default)
  end in
  prod_b (source,output)))) : both (L1 :|: fset []) I1 ((v_R × t_Result (t_Cis1Event (v_T)) (t_ParseError))) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_Cis1Event (v_T)_t_Deserial.

Definition t_Cis1Error {v_R : _} `{ t_Sized (v_R)} : choice_type :=
  chFin (mkpos 4).
Equations Cis1Error_InvalidTokenId {L : {fset Location}} {I : Interface} {v_R : _} `{ t_Sized (v_R)} : both L I t_Cis1Error :=
  Cis1Error_InvalidTokenId  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=0) eq_refl : t_Cis1Error) : both L I t_Cis1Error.
Fail Next Obligation.
Equations Cis1Error_InsufficientFunds {L : {fset Location}} {I : Interface} {v_R : _} `{ t_Sized (v_R)} : both L I t_Cis1Error :=
  Cis1Error_InsufficientFunds  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=1) eq_refl : t_Cis1Error) : both L I t_Cis1Error.
Fail Next Obligation.
Equations Cis1Error_Unauthorized {L : {fset Location}} {I : Interface} {v_R : _} `{ t_Sized (v_R)} : both L I t_Cis1Error :=
  Cis1Error_Unauthorized  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=2) eq_refl : t_Cis1Error) : both L I t_Cis1Error.
Fail Next Obligation.
Equations Cis1Error_Custom {L : {fset Location}} {I : Interface} {v_R : _} `{ t_Sized (v_R)} : v_R (both L I t_Cis1Error) :=
  Cis1Error_Custom  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=3) eq_refl : t_Cis1Error) : v_R (both L I t_Cis1Error).
Fail Next Obligation.

#[global] Program Instance t_Reject_t_From {v_R : _} `{ t_Sized (v_R)} `{ t_Into (v_R) (t_Reject)} : t_From t_Reject t_Cis1Error (v_R) :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (err : both L1 I1 (t_Cis1Error (v_R))) => letb error_code := matchb err with
  | Cis1Error_InvalidTokenId  =>
    failure (ret_both ((AST import) Unsafe blocks are not allowed.
 : chString)) (ret_both ({ Types.attributes = [];
  contents =
  Types.Block {
    expr =
    (Some { Types.attributes = [];
            contents =
            Types.Call {
              args =
              [{ Types.attributes = [];
                 contents =
                 Types.Literal {
                   lit =
                   { Types.node = (Types.Int ("42000001", Types.Unsuffixed));
                     span =
                     { Types.filename =
                       (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                       hi = { Types.col = "85"; line = "655" };
                       lo = { Types.col = "77"; line = "655" } }
                     };
                   neg = true};
                 hir_id = (Some ("104", "17"));
                 span =
                 { Types.filename =
                   (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                   hi = { Types.col = "85"; line = "655" };
                   lo = { Types.col = "76"; line = "655" } };
                 ty = (Types.Int Types.I32) }
                ];
              fn_span =
              { Types.filename =
                (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                hi = { Types.col = "86"; line = "655" };
                lo = { Types.col = "50"; line = "655" } };
              from_hir_call = true;
              fun' =
              { Types.attributes = [];
                contents =
                Types.GlobalName {
                  id =
                  { Types.index = (1, 22145); krate = "core";
                    path =
                    [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
                      { Types.data = (Types.TypeNs "nonzero");
                        disambiguator = 0 };
                      { Types.data = Types.Impl; disambiguator = 56 };
                      { Types.data = (Types.ValueNs "new_unchecked");
                        disambiguator = 0 }
                      ]
                    }};
                hir_id = None;
                span =
                { Types.filename =
                  (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                  hi = { Types.col = "75"; line = "655" };
                  lo = { Types.col = "50"; line = "655" } };
                ty =
                (Types.Arrow
                   { Types.bound_vars = [];
                     value =
                     { Types.abi = Types.Abi {todo = "Rust"};
                       c_variadic = false; inputs = [(Types.Int Types.I32)];
                       output =
                       Types.Adt {
                         def_id =
                         { Types.index = (1, 22484); krate = "core";
                           path =
                           [{ Types.data = (Types.TypeNs "num");
                              disambiguator = 0 };
                             { Types.data = (Types.TypeNs "nonzero");
                               disambiguator = 0 };
                             { Types.data = (Types.TypeNs "NonZeroI32");
                               disambiguator = 0 }
                             ]
                           };
                         generic_args = []};
                       unsafety = Types.Unsafe }
                     })
                };
              impl = None;
              ty =
              (Types.Arrow
                 { Types.bound_vars = [];
                   value =
                   { Types.abi = Types.Abi {todo = "Rust"};
                     c_variadic = false; inputs = [(Types.Int Types.I32)];
                     output =
                     Types.Adt {
                       def_id =
                       { Types.index = (1, 22484); krate = "core";
                         path =
                         [{ Types.data = (Types.TypeNs "num");
                            disambiguator = 0 };
                           { Types.data = (Types.TypeNs "nonzero");
                             disambiguator = 0 };
                           { Types.data = (Types.TypeNs "NonZeroI32");
                             disambiguator = 0 }
                           ]
                         };
                       generic_args = []};
                     unsafety = Types.Unsafe }
                   })};
            hir_id = (Some ("104", "12"));
            span =
            { Types.filename =
              (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
              hi = { Types.col = "86"; line = "655" };
              lo = { Types.col = "50"; line = "655" } };
            ty =
            Types.Adt {
              def_id =
              { Types.index = (1, 22484); krate = "core";
                path =
                [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
                  { Types.data = (Types.TypeNs "nonzero"); disambiguator = 0
                    };
                  { Types.data = (Types.TypeNs "NonZeroI32");
                    disambiguator = 0 }
                  ]
                };
              generic_args = []}
            });
    opt_destruction_scope = None;
    region_scope = { Types.data = Types.Node; id = "19" };
    safety_mode = Types.ExplicitUnsafe;
    span =
    { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
      hi = { Types.col = "88"; line = "655" };
      lo = { Types.col = "41"; line = "655" } };
    stmts = []; targeted_by_break = false};
  hir_id = (Some ("104", "11"));
  span =
  { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
    hi = { Types.col = "88"; line = "655" };
    lo = { Types.col = "41"; line = "655" } };
  ty =
  Types.Adt {
    def_id =
    { Types.index = (1, 22484); krate = "core";
      path =
      [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
        { Types.data = (Types.TypeNs "nonzero"); disambiguator = 0 };
        { Types.data = (Types.TypeNs "NonZeroI32"); disambiguator = 0 }]
      };
    generic_args = []}
  } : chString))
  | Cis1Error_InsufficientFunds  =>
    failure (ret_both ((AST import) Unsafe blocks are not allowed.
 : chString)) (ret_both ({ Types.attributes = [];
  contents =
  Types.Block {
    expr =
    (Some { Types.attributes = [];
            contents =
            Types.Call {
              args =
              [{ Types.attributes = [];
                 contents =
                 Types.Literal {
                   lit =
                   { Types.node = (Types.Int ("42000002", Types.Unsuffixed));
                     span =
                     { Types.filename =
                       (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                       hi = { Types.col = "88"; line = "656" };
                       lo = { Types.col = "80"; line = "656" } }
                     };
                   neg = true};
                 hir_id = (Some ("104", "30"));
                 span =
                 { Types.filename =
                   (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                   hi = { Types.col = "88"; line = "656" };
                   lo = { Types.col = "79"; line = "656" } };
                 ty = (Types.Int Types.I32) }
                ];
              fn_span =
              { Types.filename =
                (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                hi = { Types.col = "89"; line = "656" };
                lo = { Types.col = "53"; line = "656" } };
              from_hir_call = true;
              fun' =
              { Types.attributes = [];
                contents =
                Types.GlobalName {
                  id =
                  { Types.index = (1, 22145); krate = "core";
                    path =
                    [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
                      { Types.data = (Types.TypeNs "nonzero");
                        disambiguator = 0 };
                      { Types.data = Types.Impl; disambiguator = 56 };
                      { Types.data = (Types.ValueNs "new_unchecked");
                        disambiguator = 0 }
                      ]
                    }};
                hir_id = None;
                span =
                { Types.filename =
                  (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                  hi = { Types.col = "78"; line = "656" };
                  lo = { Types.col = "53"; line = "656" } };
                ty =
                (Types.Arrow
                   { Types.bound_vars = [];
                     value =
                     { Types.abi = Types.Abi {todo = "Rust"};
                       c_variadic = false; inputs = [(Types.Int Types.I32)];
                       output =
                       Types.Adt {
                         def_id =
                         { Types.index = (1, 22484); krate = "core";
                           path =
                           [{ Types.data = (Types.TypeNs "num");
                              disambiguator = 0 };
                             { Types.data = (Types.TypeNs "nonzero");
                               disambiguator = 0 };
                             { Types.data = (Types.TypeNs "NonZeroI32");
                               disambiguator = 0 }
                             ]
                           };
                         generic_args = []};
                       unsafety = Types.Unsafe }
                     })
                };
              impl = None;
              ty =
              (Types.Arrow
                 { Types.bound_vars = [];
                   value =
                   { Types.abi = Types.Abi {todo = "Rust"};
                     c_variadic = false; inputs = [(Types.Int Types.I32)];
                     output =
                     Types.Adt {
                       def_id =
                       { Types.index = (1, 22484); krate = "core";
                         path =
                         [{ Types.data = (Types.TypeNs "num");
                            disambiguator = 0 };
                           { Types.data = (Types.TypeNs "nonzero");
                             disambiguator = 0 };
                           { Types.data = (Types.TypeNs "NonZeroI32");
                             disambiguator = 0 }
                           ]
                         };
                       generic_args = []};
                     unsafety = Types.Unsafe }
                   })};
            hir_id = (Some ("104", "25"));
            span =
            { Types.filename =
              (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
              hi = { Types.col = "89"; line = "656" };
              lo = { Types.col = "53"; line = "656" } };
            ty =
            Types.Adt {
              def_id =
              { Types.index = (1, 22484); krate = "core";
                path =
                [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
                  { Types.data = (Types.TypeNs "nonzero"); disambiguator = 0
                    };
                  { Types.data = (Types.TypeNs "NonZeroI32");
                    disambiguator = 0 }
                  ]
                };
              generic_args = []}
            });
    opt_destruction_scope = None;
    region_scope = { Types.data = Types.Node; id = "32" };
    safety_mode = Types.ExplicitUnsafe;
    span =
    { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
      hi = { Types.col = "91"; line = "656" };
      lo = { Types.col = "44"; line = "656" } };
    stmts = []; targeted_by_break = false};
  hir_id = (Some ("104", "24"));
  span =
  { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
    hi = { Types.col = "91"; line = "656" };
    lo = { Types.col = "44"; line = "656" } };
  ty =
  Types.Adt {
    def_id =
    { Types.index = (1, 22484); krate = "core";
      path =
      [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
        { Types.data = (Types.TypeNs "nonzero"); disambiguator = 0 };
        { Types.data = (Types.TypeNs "NonZeroI32"); disambiguator = 0 }]
      };
    generic_args = []}
  } : chString))
  | Cis1Error_Unauthorized  =>
    failure (ret_both ((AST import) Unsafe blocks are not allowed.
 : chString)) (ret_both ({ Types.attributes = [];
  contents =
  Types.Block {
    expr =
    (Some { Types.attributes = [];
            contents =
            Types.Call {
              args =
              [{ Types.attributes = [];
                 contents =
                 Types.Literal {
                   lit =
                   { Types.node = (Types.Int ("42000003", Types.Unsuffixed));
                     span =
                     { Types.filename =
                       (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                       hi = { Types.col = "83"; line = "657" };
                       lo = { Types.col = "75"; line = "657" } }
                     };
                   neg = true};
                 hir_id = (Some ("104", "43"));
                 span =
                 { Types.filename =
                   (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                   hi = { Types.col = "83"; line = "657" };
                   lo = { Types.col = "74"; line = "657" } };
                 ty = (Types.Int Types.I32) }
                ];
              fn_span =
              { Types.filename =
                (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                hi = { Types.col = "84"; line = "657" };
                lo = { Types.col = "48"; line = "657" } };
              from_hir_call = true;
              fun' =
              { Types.attributes = [];
                contents =
                Types.GlobalName {
                  id =
                  { Types.index = (1, 22145); krate = "core";
                    path =
                    [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
                      { Types.data = (Types.TypeNs "nonzero");
                        disambiguator = 0 };
                      { Types.data = Types.Impl; disambiguator = 56 };
                      { Types.data = (Types.ValueNs "new_unchecked");
                        disambiguator = 0 }
                      ]
                    }};
                hir_id = None;
                span =
                { Types.filename =
                  (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
                  hi = { Types.col = "73"; line = "657" };
                  lo = { Types.col = "48"; line = "657" } };
                ty =
                (Types.Arrow
                   { Types.bound_vars = [];
                     value =
                     { Types.abi = Types.Abi {todo = "Rust"};
                       c_variadic = false; inputs = [(Types.Int Types.I32)];
                       output =
                       Types.Adt {
                         def_id =
                         { Types.index = (1, 22484); krate = "core";
                           path =
                           [{ Types.data = (Types.TypeNs "num");
                              disambiguator = 0 };
                             { Types.data = (Types.TypeNs "nonzero");
                               disambiguator = 0 };
                             { Types.data = (Types.TypeNs "NonZeroI32");
                               disambiguator = 0 }
                             ]
                           };
                         generic_args = []};
                       unsafety = Types.Unsafe }
                     })
                };
              impl = None;
              ty =
              (Types.Arrow
                 { Types.bound_vars = [];
                   value =
                   { Types.abi = Types.Abi {todo = "Rust"};
                     c_variadic = false; inputs = [(Types.Int Types.I32)];
                     output =
                     Types.Adt {
                       def_id =
                       { Types.index = (1, 22484); krate = "core";
                         path =
                         [{ Types.data = (Types.TypeNs "num");
                            disambiguator = 0 };
                           { Types.data = (Types.TypeNs "nonzero");
                             disambiguator = 0 };
                           { Types.data = (Types.TypeNs "NonZeroI32");
                             disambiguator = 0 }
                           ]
                         };
                       generic_args = []};
                     unsafety = Types.Unsafe }
                   })};
            hir_id = (Some ("104", "38"));
            span =
            { Types.filename =
              (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
              hi = { Types.col = "84"; line = "657" };
              lo = { Types.col = "48"; line = "657" } };
            ty =
            Types.Adt {
              def_id =
              { Types.index = (1, 22484); krate = "core";
                path =
                [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
                  { Types.data = (Types.TypeNs "nonzero"); disambiguator = 0
                    };
                  { Types.data = (Types.TypeNs "NonZeroI32");
                    disambiguator = 0 }
                  ]
                };
              generic_args = []}
            });
    opt_destruction_scope = None;
    region_scope = { Types.data = Types.Node; id = "45" };
    safety_mode = Types.ExplicitUnsafe;
    span =
    { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
      hi = { Types.col = "86"; line = "657" };
      lo = { Types.col = "39"; line = "657" } };
    stmts = []; targeted_by_break = false};
  hir_id = (Some ("104", "37"));
  span =
  { Types.filename = (Types.Real (Types.LocalPath "wCCD/src/cis1.rs"));
    hi = { Types.col = "86"; line = "657" };
    lo = { Types.col = "39"; line = "657" } };
  ty =
  Types.Adt {
    def_id =
    { Types.index = (1, 22484); krate = "core";
      path =
      [{ Types.data = (Types.TypeNs "num"); disambiguator = 0 };
        { Types.data = (Types.TypeNs "nonzero"); disambiguator = 0 };
        { Types.data = (Types.TypeNs "NonZeroI32"); disambiguator = 0 }]
      };
    generic_args = []}
  } : chString))
  | Cis1Error_Custom reject =>
    f_error_code (f_into reject)
  end in
  solve_lift (Build_t_Reject (f_error_code := error_code)) : both (L1 :|: fset []) I1 (t_Reject) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Reject_t_From.

#[global] Program Instance t_Cis1Error (v_X)_t_From {v_X : _} `{ t_Sized (v_X)} `{ t_From (v_X) (t_LogError)} : t_From t_Cis1Error (v_X) t_LogError :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (err : both L1 I1 (t_LogError)) => Cis1Error_Custom (solve_lift (f_from err)) : both (L1 :|: fset []) I1 (t_Cis1Error (v_X)) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Cis1Error (v_X)_t_From.

#[global] Program Instance t_Cis1Error (v_X)_t_From {v_X : _} `{ t_Sized (v_X)} `{ t_From (v_X) (t_ParseError)} : t_From t_Cis1Error (v_X) t_ParseError :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (err : both L1 I1 (t_ParseError)) => Cis1Error_Custom (solve_lift (f_from err)) : both (L1 :|: fset []) I1 (t_Cis1Error (v_X)) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Cis1Error (v_X)_t_From.

Definition t_Receiver : choice_type :=
  chFin (mkpos 2).
Equations Receiver_Account {L : {fset Location}} {I : Interface} : t_AccountAddress (both L I t_Receiver) :=
  Receiver_Account  :=
    solve_lift ret_both (fintype.Ordinal (n:=2) (m:=0) eq_refl : t_Receiver) : t_AccountAddress (both L I t_Receiver).
Fail Next Obligation.
Equations Receiver_Contract {L : {fset Location}} {I : Interface} : (t_ContractAddress × t_OwnedReceiveName) -> both L I t_Receiver :=
  Receiver_Contract  :=
    solve_lift ret_both (fintype.Ordinal (n:=2) (m:=1) eq_refl : t_Receiver) : (t_ContractAddress × t_OwnedReceiveName) -> both L I t_Receiver.
Fail Next Obligation.

Equations from_account {L1 : {fset Location}} {I1 : Interface} (address : both L1 I1 (t_AccountAddress)) : both L1 I1 (t_Receiver) :=
  from_account address  :=
    Receiver_Account (solve_lift address) : both L1 I1 (t_Receiver).
Fail Next Obligation.

Equations from_contract {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (address : both L1 I1 (t_ContractAddress)) (function : both L2 I2 (t_OwnedReceiveName)) : both (L1 :|: L2) (I1 :|: I2) (t_Receiver) :=
  from_contract address function  :=
    Receiver_Contract (solve_lift address) (solve_lift function) : both (L1 :|: L2) (I1 :|: I2) (t_Receiver).
Fail Next Obligation.

Equations address {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Receiver)) : both L1 I1 (t_Address) :=
  address self  :=
    solve_lift matchb self with
    | Receiver_Account address =>
      Address_Account address
    | Receiver_Contract address =>
      Address_Contract address
    end : both L1 I1 (t_Address).
Fail Next Obligation.

#[global] Program Instance t_Receiver_t_SchemaType : t_SchemaType t_Receiver :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_Enum (solve_lift (into_vec (unsize (box_new (array_from_list [prod_b (f_from (ret_both (Account : chString)),Fields_Unnamed (into_vec (unsize (box_new (array_from_list [f_get_type])))));
    prod_b (f_from (ret_both (Contract : chString)),Fields_Unnamed (into_vec (unsize (box_new (array_from_list [f_get_type;
        f_get_type])))))]))))) : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_Receiver_t_SchemaType.

#[global] Program Instance t_Receiver_t_From : t_From t_Receiver t_AccountAddress :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (address : both L1 I1 (t_AccountAddress)) => solve_lift (from_account address) : both (L1 :|: fset []) I1 (t_Receiver) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Receiver_t_From.

Definition t_AdditionalData : choice_type :=
  (t_Vec (int8) (t_Global)).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_AdditionalData)) : both L I (t_Vec (int8) (t_Global)) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_Vec (int8) (t_Global)))) : both L I (t_Vec (int8) (t_Global)).
Fail Next Obligation.
Equations Build_t_AdditionalData {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (t_Vec (int8) (t_Global))} : both L0 I0 (t_AdditionalData) :=
  Build_t_AdditionalData  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_AdditionalData)))) : both L0 I0 (t_AdditionalData).
Fail Next Obligation.
Notation "'Build_t_AdditionalData' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_AdditionalData (0 := y)).

#[global] Program Instance t_AdditionalData_t_SchemaType : t_SchemaType t_AdditionalData :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U16 Type_U8 : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_AdditionalData_t_SchemaType.

Equations empty {L : {fset Location}} {I : Interface} : both L I (t_AdditionalData) :=
  empty  :=
    AdditionalData (solve_lift new) : both L I (t_AdditionalData).
Fail Next Obligation.

#[global] Program Instance t_AdditionalData_t_From : t_From t_AdditionalData t_Vec (int8) (t_Global) :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (data : both L1 I1 (t_Vec (int8) (t_Global))) => AdditionalData (solve_lift data) : both (L1 :|: fset []) I1 (t_AdditionalData) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_AdditionalData_t_From.

#[global] Program Instance t_AdditionalData_t_AsRef : t_AsRef t_AdditionalData seq int8 :=
  let f_as_ref := fun  {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_AdditionalData)) => solve_lift (f_deref (0 self)) : both (L1 :|: fset []) I1 (seq int8) in
  {| f_as_ref_loc := (fset [] : {fset Location});
  f_as_ref := (@f_as_ref)|}.
Fail Next Obligation.
Hint Unfold t_AdditionalData_t_AsRef.

Definition t_Transfer {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (v_T × int64 × t_Address × t_Receiver × t_AdditionalData).
Equations f_token_id {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_Transfer)) : both L I (v_T) :=
  f_token_id s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst x))) : v_T))) : both L I (v_T).
Fail Next Obligation.
Equations f_amount {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_Transfer)) : both L I (int64) :=
  f_amount s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : int64))) : both L I (int64).
Fail Next Obligation.
Equations f_from {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_Transfer)) : both L I (t_Address) :=
  f_from s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations f_to {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_Transfer)) : both L I (t_Receiver) :=
  f_to s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_Receiver))) : both L I (t_Receiver).
Fail Next Obligation.
Equations f_data {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_Transfer)) : both L I (t_AdditionalData) :=
  f_data s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_AdditionalData))) : both L I (t_AdditionalData).
Fail Next Obligation.
Equations Build_t_Transfer {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_token_id : both L0 I0 (v_T)} {f_amount : both L1 I1 (int64)} {f_from : both L2 I2 (t_Address)} {f_to : both L3 I3 (t_Receiver)} {f_data : both L4 I4 (t_AdditionalData)} : both (L0:|:L1:|:L2:|:L3:|:L4) (I0:|:I1:|:I2:|:I3:|:I4) (t_Transfer) :=
  Build_t_Transfer  :=
    bind_both f_data (fun f_data =>
      bind_both f_to (fun f_to =>
        bind_both f_from (fun f_from =>
          bind_both f_amount (fun f_amount =>
            bind_both f_token_id (fun f_token_id =>
              solve_lift (ret_both ((f_token_id,f_amount,f_from,f_to,f_data) : (t_Transfer)))))))) : both (L0:|:L1:|:L2:|:L3:|:L4) (I0:|:I1:|:I2:|:I3:|:I4) (t_Transfer).
Fail Next Obligation.
Notation "'Build_t_Transfer' '[' x ']' '(' 'f_token_id' ':=' y ')'" := (Build_t_Transfer (f_token_id := y) (f_amount := f_amount x) (f_from := f_from x) (f_to := f_to x) (f_data := f_data x)).
Notation "'Build_t_Transfer' '[' x ']' '(' 'f_amount' ':=' y ')'" := (Build_t_Transfer (f_token_id := f_token_id x) (f_amount := y) (f_from := f_from x) (f_to := f_to x) (f_data := f_data x)).
Notation "'Build_t_Transfer' '[' x ']' '(' 'f_from' ':=' y ')'" := (Build_t_Transfer (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := y) (f_to := f_to x) (f_data := f_data x)).
Notation "'Build_t_Transfer' '[' x ']' '(' 'f_to' ':=' y ')'" := (Build_t_Transfer (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := f_from x) (f_to := y) (f_data := f_data x)).
Notation "'Build_t_Transfer' '[' x ']' '(' 'f_data' ':=' y ')'" := (Build_t_Transfer (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := f_from x) (f_to := f_to x) (f_data := y)).

#[global] Program Instance t_Transfer (v_T)_t_SchemaType {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_SchemaType t_Transfer (v_T) :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_Struct (Fields_Named (solve_lift (into_vec (unsize (box_new (array_from_list [prod_b (f_from (ret_both (token_id : chString)),f_get_type);
    prod_b (f_from (ret_both (amount : chString)),f_get_type);
    prod_b (f_from (ret_both (from : chString)),f_get_type);
    prod_b (f_from (ret_both (to : chString)),f_get_type);
    prod_b (f_from (ret_both (data : chString)),f_get_type)])))))) : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_Transfer (v_T)_t_SchemaType.

Definition t_TransferParams {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (t_Vec (t_Transfer (v_T)) (t_Global)).
Equations 0 {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TransferParams)) : both L I (t_Vec (t_Transfer (v_T)) (t_Global)) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_Vec (t_Transfer (v_T)) (t_Global)))) : both L I (t_Vec (t_Transfer (v_T)) (t_Global)).
Fail Next Obligation.
Equations Build_t_TransferParams {L0 : {fset Location}} {I0 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {0 : both L0 I0 (t_Vec (t_Transfer (v_T)) (t_Global))} : both L0 I0 (t_TransferParams) :=
  Build_t_TransferParams  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TransferParams)))) : both L0 I0 (t_TransferParams).
Fail Next Obligation.
Notation "'Build_t_TransferParams' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TransferParams (0 := y)).

#[global] Program Instance t_TransferParams (v_T)_t_SchemaType {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_SchemaType t_TransferParams (v_T) :=
  let f_get_type := fun  {L : {fset Location}} {I : Interface} => Type_List SizeLength_U16 (solve_lift f_get_type) : both (L :|: fset []) I (t_Type) in
  {| f_get_type_loc := (fset [] : {fset Location});
  f_get_type := (@f_get_type)|}.
Fail Next Obligation.
Hint Unfold t_TransferParams (v_T)_t_SchemaType.

#[global] Program Instance t_TransferParams (v_T)_t_From {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_From t_TransferParams (v_T) t_Vec (t_Transfer (v_T)) (t_Global) :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (transfers : both L1 I1 (t_Vec (t_Transfer (v_T)) (t_Global))) => TransferParams (solve_lift transfers) : both (L1 :|: fset []) I1 (t_TransferParams (v_T)) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_TransferParams (v_T)_t_From.

#[global] Program Instance t_TransferParams (v_T)_t_AsRef {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_AsRef t_TransferParams (v_T) seq t_Transfer (v_T) :=
  let f_as_ref := fun  {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_TransferParams (v_T))) => solve_lift (f_deref (0 self)) : both (L1 :|: fset []) I1 (seq t_Transfer (v_T)) in
  {| f_as_ref_loc := (fset [] : {fset Location});
  f_as_ref := (@f_as_ref)|}.
Fail Next Obligation.
Hint Unfold t_TransferParams (v_T)_t_AsRef.

Definition t_UpdateOperator : choice_type :=
  (t_OperatorUpdate × t_Address).
Equations f_update {L : {fset Location}} {I : Interface} (s : both L I (t_UpdateOperator)) : both L I (t_OperatorUpdate) :=
  f_update s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : t_OperatorUpdate))) : both L I (t_OperatorUpdate).
Fail Next Obligation.
Equations f_operator {L : {fset Location}} {I : Interface} (s : both L I (t_UpdateOperator)) : both L I (t_Address) :=
  f_operator s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations Build_t_UpdateOperator {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_update : both L0 I0 (t_OperatorUpdate)} {f_operator : both L1 I1 (t_Address)} : both (L0:|:L1) (I0:|:I1) (t_UpdateOperator) :=
  Build_t_UpdateOperator  :=
    bind_both f_operator (fun f_operator =>
      bind_both f_update (fun f_update =>
        solve_lift (ret_both ((f_update,f_operator) : (t_UpdateOperator))))) : both (L0:|:L1) (I0:|:I1) (t_UpdateOperator).
Fail Next Obligation.
Notation "'Build_t_UpdateOperator' '[' x ']' '(' 'f_update' ':=' y ')'" := (Build_t_UpdateOperator (f_update := y) (f_operator := f_operator x)).
Notation "'Build_t_UpdateOperator' '[' x ']' '(' 'f_operator' ':=' y ')'" := (Build_t_UpdateOperator (f_update := f_update x) (f_operator := y)).

Definition t_UpdateOperatorParams : choice_type :=
  (t_Vec (t_UpdateOperator) (t_Global)).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_UpdateOperatorParams)) : both L I (t_Vec (t_UpdateOperator) (t_Global)) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_Vec (t_UpdateOperator) (t_Global)))) : both L I (t_Vec (t_UpdateOperator) (t_Global)).
Fail Next Obligation.
Equations Build_t_UpdateOperatorParams {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (t_Vec (t_UpdateOperator) (t_Global))} : both L0 I0 (t_UpdateOperatorParams) :=
  Build_t_UpdateOperatorParams  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_UpdateOperatorParams)))) : both L0 I0 (t_UpdateOperatorParams).
Fail Next Obligation.
Notation "'Build_t_UpdateOperatorParams' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_UpdateOperatorParams (0 := y)).

Definition t_BalanceOfQuery {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (v_T × t_Address).
Equations f_token_id {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BalanceOfQuery)) : both L I (v_T) :=
  f_token_id s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : v_T))) : both L I (v_T).
Fail Next Obligation.
Equations f_address {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BalanceOfQuery)) : both L I (t_Address) :=
  f_address s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations Build_t_BalanceOfQuery {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_token_id : both L0 I0 (v_T)} {f_address : both L1 I1 (t_Address)} : both (L0:|:L1) (I0:|:I1) (t_BalanceOfQuery) :=
  Build_t_BalanceOfQuery  :=
    bind_both f_address (fun f_address =>
      bind_both f_token_id (fun f_token_id =>
        solve_lift (ret_both ((f_token_id,f_address) : (t_BalanceOfQuery))))) : both (L0:|:L1) (I0:|:I1) (t_BalanceOfQuery).
Fail Next Obligation.
Notation "'Build_t_BalanceOfQuery' '[' x ']' '(' 'f_token_id' ':=' y ')'" := (Build_t_BalanceOfQuery (f_token_id := y) (f_address := f_address x)).
Notation "'Build_t_BalanceOfQuery' '[' x ']' '(' 'f_address' ':=' y ')'" := (Build_t_BalanceOfQuery (f_token_id := f_token_id x) (f_address := y)).

Definition t_BalanceOfQueryParams {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (t_ContractAddress × t_OwnedReceiveName × t_Vec (t_BalanceOfQuery (v_T)) (t_Global)).
Equations f_result_contract {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BalanceOfQueryParams)) : both L I (t_ContractAddress) :=
  f_result_contract s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : t_ContractAddress))) : both L I (t_ContractAddress).
Fail Next Obligation.
Equations f_result_function {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BalanceOfQueryParams)) : both L I (t_OwnedReceiveName) :=
  f_result_function s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_OwnedReceiveName))) : both L I (t_OwnedReceiveName).
Fail Next Obligation.
Equations f_queries {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BalanceOfQueryParams)) : both L I (t_Vec (t_BalanceOfQuery (v_T)) (t_Global)) :=
  f_queries s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Vec (t_BalanceOfQuery (v_T)) (t_Global)))) : both L I (t_Vec (t_BalanceOfQuery (v_T)) (t_Global)).
Fail Next Obligation.
Equations Build_t_BalanceOfQueryParams {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_result_contract : both L0 I0 (t_ContractAddress)} {f_result_function : both L1 I1 (t_OwnedReceiveName)} {f_queries : both L2 I2 (t_Vec (t_BalanceOfQuery (v_T)) (t_Global))} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_BalanceOfQueryParams) :=
  Build_t_BalanceOfQueryParams  :=
    bind_both f_queries (fun f_queries =>
      bind_both f_result_function (fun f_result_function =>
        bind_both f_result_contract (fun f_result_contract =>
          solve_lift (ret_both ((f_result_contract,f_result_function,f_queries) : (t_BalanceOfQueryParams)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_BalanceOfQueryParams).
Fail Next Obligation.
Notation "'Build_t_BalanceOfQueryParams' '[' x ']' '(' 'f_result_contract' ':=' y ')'" := (Build_t_BalanceOfQueryParams (f_result_contract := y) (f_result_function := f_result_function x) (f_queries := f_queries x)).
Notation "'Build_t_BalanceOfQueryParams' '[' x ']' '(' 'f_result_function' ':=' y ')'" := (Build_t_BalanceOfQueryParams (f_result_contract := f_result_contract x) (f_result_function := y) (f_queries := f_queries x)).
Notation "'Build_t_BalanceOfQueryParams' '[' x ']' '(' 'f_queries' ':=' y ')'" := (Build_t_BalanceOfQueryParams (f_result_contract := f_result_contract x) (f_result_function := f_result_function x) (f_queries := y)).

Definition t_BalanceOfQueryResult {v_T : _} `{ t_Sized (v_T)} : choice_type :=
  (t_BalanceOfQuery (v_T) × int64).

Definition t_BalanceOfQueryResponse {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (t_Vec ((t_BalanceOfQuery (v_T) × int64)) (t_Global)).
Equations 0 {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_BalanceOfQueryResponse)) : both L I (t_Vec ((t_BalanceOfQuery (v_T) × int64)) (t_Global)) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_Vec ((t_BalanceOfQuery (v_T) × int64)) (t_Global)))) : both L I (t_Vec ((t_BalanceOfQuery (v_T) × int64)) (t_Global)).
Fail Next Obligation.
Equations Build_t_BalanceOfQueryResponse {L0 : {fset Location}} {I0 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {0 : both L0 I0 (t_Vec ((t_BalanceOfQuery (v_T) × int64)) (t_Global))} : both L0 I0 (t_BalanceOfQueryResponse) :=
  Build_t_BalanceOfQueryResponse  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_BalanceOfQueryResponse)))) : both L0 I0 (t_BalanceOfQueryResponse).
Fail Next Obligation.
Notation "'Build_t_BalanceOfQueryResponse' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_BalanceOfQueryResponse (0 := y)).

#[global] Program Instance t_BalanceOfQueryResponse (v_T)_t_From {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_From t_BalanceOfQueryResponse (v_T) t_Vec ((t_BalanceOfQuery (v_T) × int64)) (t_Global) :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (results : both L1 I1 (t_Vec ((t_BalanceOfQuery (v_T) × int64)) (t_Global))) => BalanceOfQueryResponse (solve_lift results) : both (L1 :|: fset []) I1 (t_BalanceOfQueryResponse (v_T)) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_BalanceOfQueryResponse (v_T)_t_From.

#[global] Program Instance t_BalanceOfQueryResponse (v_T)_t_AsRef {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_AsRef t_BalanceOfQueryResponse (v_T) seq (t_BalanceOfQuery (v_T) × int64) :=
  let f_as_ref := fun  {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_BalanceOfQueryResponse (v_T))) => solve_lift (f_deref (0 self)) : both (L1 :|: fset []) I1 (seq (t_BalanceOfQuery (v_T) × int64)) in
  {| f_as_ref_loc := (fset [] : {fset Location});
  f_as_ref := (@f_as_ref)|}.
Fail Next Obligation.
Hint Unfold t_BalanceOfQueryResponse (v_T)_t_AsRef.

Definition t_OperatorOfQuery : choice_type :=
  (t_Address × t_Address).
Equations f_owner {L : {fset Location}} {I : Interface} (s : both L I (t_OperatorOfQuery)) : both L I (t_Address) :=
  f_owner s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations f_address {L : {fset Location}} {I : Interface} (s : both L I (t_OperatorOfQuery)) : both L I (t_Address) :=
  f_address s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations Build_t_OperatorOfQuery {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_owner : both L0 I0 (t_Address)} {f_address : both L1 I1 (t_Address)} : both (L0:|:L1) (I0:|:I1) (t_OperatorOfQuery) :=
  Build_t_OperatorOfQuery  :=
    bind_both f_address (fun f_address =>
      bind_both f_owner (fun f_owner =>
        solve_lift (ret_both ((f_owner,f_address) : (t_OperatorOfQuery))))) : both (L0:|:L1) (I0:|:I1) (t_OperatorOfQuery).
Fail Next Obligation.
Notation "'Build_t_OperatorOfQuery' '[' x ']' '(' 'f_owner' ':=' y ')'" := (Build_t_OperatorOfQuery (f_owner := y) (f_address := f_address x)).
Notation "'Build_t_OperatorOfQuery' '[' x ']' '(' 'f_address' ':=' y ')'" := (Build_t_OperatorOfQuery (f_owner := f_owner x) (f_address := y)).

Definition t_OperatorOfQueryParams : choice_type :=
  (t_ContractAddress × t_OwnedReceiveName × t_Vec (t_OperatorOfQuery) (t_Global)).
Equations f_result_contract {L : {fset Location}} {I : Interface} (s : both L I (t_OperatorOfQueryParams)) : both L I (t_ContractAddress) :=
  f_result_contract s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : t_ContractAddress))) : both L I (t_ContractAddress).
Fail Next Obligation.
Equations f_result_function {L : {fset Location}} {I : Interface} (s : both L I (t_OperatorOfQueryParams)) : both L I (t_OwnedReceiveName) :=
  f_result_function s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_OwnedReceiveName))) : both L I (t_OwnedReceiveName).
Fail Next Obligation.
Equations f_queries {L : {fset Location}} {I : Interface} (s : both L I (t_OperatorOfQueryParams)) : both L I (t_Vec (t_OperatorOfQuery) (t_Global)) :=
  f_queries s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Vec (t_OperatorOfQuery) (t_Global)))) : both L I (t_Vec (t_OperatorOfQuery) (t_Global)).
Fail Next Obligation.
Equations Build_t_OperatorOfQueryParams {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {f_result_contract : both L0 I0 (t_ContractAddress)} {f_result_function : both L1 I1 (t_OwnedReceiveName)} {f_queries : both L2 I2 (t_Vec (t_OperatorOfQuery) (t_Global))} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_OperatorOfQueryParams) :=
  Build_t_OperatorOfQueryParams  :=
    bind_both f_queries (fun f_queries =>
      bind_both f_result_function (fun f_result_function =>
        bind_both f_result_contract (fun f_result_contract =>
          solve_lift (ret_both ((f_result_contract,f_result_function,f_queries) : (t_OperatorOfQueryParams)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_OperatorOfQueryParams).
Fail Next Obligation.
Notation "'Build_t_OperatorOfQueryParams' '[' x ']' '(' 'f_result_contract' ':=' y ')'" := (Build_t_OperatorOfQueryParams (f_result_contract := y) (f_result_function := f_result_function x) (f_queries := f_queries x)).
Notation "'Build_t_OperatorOfQueryParams' '[' x ']' '(' 'f_result_function' ':=' y ')'" := (Build_t_OperatorOfQueryParams (f_result_contract := f_result_contract x) (f_result_function := y) (f_queries := f_queries x)).
Notation "'Build_t_OperatorOfQueryParams' '[' x ']' '(' 'f_queries' ':=' y ')'" := (Build_t_OperatorOfQueryParams (f_result_contract := f_result_contract x) (f_result_function := f_result_function x) (f_queries := y)).

Notation "'t_OperatorOfQueryResult'" := ((t_OperatorOfQuery × 'bool)).

Definition t_OperatorOfQueryResponse : choice_type :=
  (t_Vec ((t_OperatorOfQuery × 'bool)) (t_Global)).
Equations 0 {L : {fset Location}} {I : Interface} (s : both L I (t_OperatorOfQueryResponse)) : both L I (t_Vec ((t_OperatorOfQuery × 'bool)) (t_Global)) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_Vec ((t_OperatorOfQuery × 'bool)) (t_Global)))) : both L I (t_Vec ((t_OperatorOfQuery × 'bool)) (t_Global)).
Fail Next Obligation.
Equations Build_t_OperatorOfQueryResponse {L0 : {fset Location}} {I0 : Interface} {0 : both L0 I0 (t_Vec ((t_OperatorOfQuery × 'bool)) (t_Global))} : both L0 I0 (t_OperatorOfQueryResponse) :=
  Build_t_OperatorOfQueryResponse  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_OperatorOfQueryResponse)))) : both L0 I0 (t_OperatorOfQueryResponse).
Fail Next Obligation.
Notation "'Build_t_OperatorOfQueryResponse' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_OperatorOfQueryResponse (0 := y)).

#[global] Program Instance t_OperatorOfQueryResponse_t_From : t_From t_OperatorOfQueryResponse t_Vec ((t_OperatorOfQuery × 'bool)) (t_Global) :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (results : both L1 I1 (t_Vec ((t_OperatorOfQuery × 'bool)) (t_Global))) => OperatorOfQueryResponse (solve_lift results) : both (L1 :|: fset []) I1 (t_OperatorOfQueryResponse) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_OperatorOfQueryResponse_t_From.

#[global] Program Instance t_OperatorOfQueryResponse_t_AsRef : t_AsRef t_OperatorOfQueryResponse seq (t_OperatorOfQuery × 'bool) :=
  let f_as_ref := fun  {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_OperatorOfQueryResponse)) => solve_lift (f_deref (0 self)) : both (L1 :|: fset []) I1 (seq (t_OperatorOfQuery × 'bool)) in
  {| f_as_ref_loc := (fset [] : {fset Location});
  f_as_ref := (@f_as_ref)|}.
Fail Next Obligation.
Hint Unfold t_OperatorOfQueryResponse_t_AsRef.

Definition t_TokenMetadataQueryParams {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (t_ContractAddress × t_OwnedReceiveName × t_Vec (v_T) (t_Global)).
Equations f_result_contract {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TokenMetadataQueryParams)) : both L I (t_ContractAddress) :=
  f_result_contract s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : t_ContractAddress))) : both L I (t_ContractAddress).
Fail Next Obligation.
Equations f_result_function {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TokenMetadataQueryParams)) : both L I (t_OwnedReceiveName) :=
  f_result_function s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_OwnedReceiveName))) : both L I (t_OwnedReceiveName).
Fail Next Obligation.
Equations f_queries {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TokenMetadataQueryParams)) : both L I (t_Vec (v_T) (t_Global)) :=
  f_queries s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Vec (v_T) (t_Global)))) : both L I (t_Vec (v_T) (t_Global)).
Fail Next Obligation.
Equations Build_t_TokenMetadataQueryParams {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_result_contract : both L0 I0 (t_ContractAddress)} {f_result_function : both L1 I1 (t_OwnedReceiveName)} {f_queries : both L2 I2 (t_Vec (v_T) (t_Global))} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_TokenMetadataQueryParams) :=
  Build_t_TokenMetadataQueryParams  :=
    bind_both f_queries (fun f_queries =>
      bind_both f_result_function (fun f_result_function =>
        bind_both f_result_contract (fun f_result_contract =>
          solve_lift (ret_both ((f_result_contract,f_result_function,f_queries) : (t_TokenMetadataQueryParams)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_TokenMetadataQueryParams).
Fail Next Obligation.
Notation "'Build_t_TokenMetadataQueryParams' '[' x ']' '(' 'f_result_contract' ':=' y ')'" := (Build_t_TokenMetadataQueryParams (f_result_contract := y) (f_result_function := f_result_function x) (f_queries := f_queries x)).
Notation "'Build_t_TokenMetadataQueryParams' '[' x ']' '(' 'f_result_function' ':=' y ')'" := (Build_t_TokenMetadataQueryParams (f_result_contract := f_result_contract x) (f_result_function := y) (f_queries := f_queries x)).
Notation "'Build_t_TokenMetadataQueryParams' '[' x ']' '(' 'f_queries' ':=' y ')'" := (Build_t_TokenMetadataQueryParams (f_result_contract := f_result_contract x) (f_result_function := f_result_function x) (f_queries := y)).

Definition t_TokenMetadataQueryResult {v_T : _} `{ t_Sized (v_T)} : choice_type :=
  (v_T × t_MetadataUrl).

Definition t_TokenMetadataQueryResponse {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (t_Vec ((v_T × t_MetadataUrl)) (t_Global)).
Equations 0 {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_TokenMetadataQueryResponse)) : both L I (t_Vec ((v_T × t_MetadataUrl)) (t_Global)) :=
  0 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (x : t_Vec ((v_T × t_MetadataUrl)) (t_Global)))) : both L I (t_Vec ((v_T × t_MetadataUrl)) (t_Global)).
Fail Next Obligation.
Equations Build_t_TokenMetadataQueryResponse {L0 : {fset Location}} {I0 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {0 : both L0 I0 (t_Vec ((v_T × t_MetadataUrl)) (t_Global))} : both L0 I0 (t_TokenMetadataQueryResponse) :=
  Build_t_TokenMetadataQueryResponse  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_TokenMetadataQueryResponse)))) : both L0 I0 (t_TokenMetadataQueryResponse).
Fail Next Obligation.
Notation "'Build_t_TokenMetadataQueryResponse' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_TokenMetadataQueryResponse (0 := y)).

#[global] Program Instance t_TokenMetadataQueryResponse (v_T)_t_From {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_From t_TokenMetadataQueryResponse (v_T) t_Vec ((v_T × t_MetadataUrl)) (t_Global) :=
  let f_from := fun  {L1 : {fset Location}} {I1 : Interface} (results : both L1 I1 (t_Vec ((v_T × t_MetadataUrl)) (t_Global))) => TokenMetadataQueryResponse (solve_lift results) : both (L1 :|: fset []) I1 (t_TokenMetadataQueryResponse (v_T)) in
  {| f_from_loc := (fset [] : {fset Location});
  f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_TokenMetadataQueryResponse (v_T)_t_From.

#[global] Program Instance t_TokenMetadataQueryResponse (v_T)_t_AsRef {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : t_AsRef t_TokenMetadataQueryResponse (v_T) seq (v_T × t_MetadataUrl) :=
  let f_as_ref := fun  {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_TokenMetadataQueryResponse (v_T))) => solve_lift (f_deref (0 self)) : both (L1 :|: fset []) I1 (seq (v_T × t_MetadataUrl)) in
  {| f_as_ref_loc := (fset [] : {fset Location});
  f_as_ref := (@f_as_ref)|}.
Fail Next Obligation.
Hint Unfold t_TokenMetadataQueryResponse (v_T)_t_AsRef.

Definition t_OnReceivingCis1Params {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} : choice_type :=
  (v_T × int64 × t_Address × t_OwnedContractName × t_AdditionalData).
Equations f_token_id {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_OnReceivingCis1Params)) : both L I (v_T) :=
  f_token_id s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst x))) : v_T))) : both L I (v_T).
Fail Next Obligation.
Equations f_amount {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_OnReceivingCis1Params)) : both L I (int64) :=
  f_amount s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : int64))) : both L I (int64).
Fail Next Obligation.
Equations f_from {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_OnReceivingCis1Params)) : both L I (t_Address) :=
  f_from s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : t_Address))) : both L I (t_Address).
Fail Next Obligation.
Equations f_contract_name {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_OnReceivingCis1Params)) : both L I (t_OwnedContractName) :=
  f_contract_name s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_OwnedContractName))) : both L I (t_OwnedContractName).
Fail Next Obligation.
Equations f_data {L : {fset Location}} {I : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} (s : both L I (t_OnReceivingCis1Params)) : both L I (t_AdditionalData) :=
  f_data s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_AdditionalData))) : both L I (t_AdditionalData).
Fail Next Obligation.
Equations Build_t_OnReceivingCis1Params {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {v_T : _} `{ t_Sized (v_T)} `{ t_IsTokenId (v_T)} {f_token_id : both L0 I0 (v_T)} {f_amount : both L1 I1 (int64)} {f_from : both L2 I2 (t_Address)} {f_contract_name : both L3 I3 (t_OwnedContractName)} {f_data : both L4 I4 (t_AdditionalData)} : both (L0:|:L1:|:L2:|:L3:|:L4) (I0:|:I1:|:I2:|:I3:|:I4) (t_OnReceivingCis1Params) :=
  Build_t_OnReceivingCis1Params  :=
    bind_both f_data (fun f_data =>
      bind_both f_contract_name (fun f_contract_name =>
        bind_both f_from (fun f_from =>
          bind_both f_amount (fun f_amount =>
            bind_both f_token_id (fun f_token_id =>
              solve_lift (ret_both ((f_token_id,f_amount,f_from,f_contract_name,f_data) : (t_OnReceivingCis1Params)))))))) : both (L0:|:L1:|:L2:|:L3:|:L4) (I0:|:I1:|:I2:|:I3:|:I4) (t_OnReceivingCis1Params).
Fail Next Obligation.
Notation "'Build_t_OnReceivingCis1Params' '[' x ']' '(' 'f_token_id' ':=' y ')'" := (Build_t_OnReceivingCis1Params (f_token_id := y) (f_amount := f_amount x) (f_from := f_from x) (f_contract_name := f_contract_name x) (f_data := f_data x)).
Notation "'Build_t_OnReceivingCis1Params' '[' x ']' '(' 'f_amount' ':=' y ')'" := (Build_t_OnReceivingCis1Params (f_token_id := f_token_id x) (f_amount := y) (f_from := f_from x) (f_contract_name := f_contract_name x) (f_data := f_data x)).
Notation "'Build_t_OnReceivingCis1Params' '[' x ']' '(' 'f_from' ':=' y ')'" := (Build_t_OnReceivingCis1Params (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := y) (f_contract_name := f_contract_name x) (f_data := f_data x)).
Notation "'Build_t_OnReceivingCis1Params' '[' x ']' '(' 'f_contract_name' ':=' y ')'" := (Build_t_OnReceivingCis1Params (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := f_from x) (f_contract_name := y) (f_data := f_data x)).
Notation "'Build_t_OnReceivingCis1Params' '[' x ']' '(' 'f_data' ':=' y ')'" := (Build_t_OnReceivingCis1Params (f_token_id := f_token_id x) (f_amount := f_amount x) (f_from := f_from x) (f_contract_name := f_contract_name x) (f_data := y)).
