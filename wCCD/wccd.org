
#+TITLE: Auction Smartcontract
#+AUTHOR: Lasse Letager Hansen

# rev: 4d4b024b547a1f120f6d6951cbc409c94f8f146a

# Use org-tanglesync !
# lentic

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file
# C-c C-v s   -  create results / run subtree

* General information
:PROPERTIES:
:header-args: sh :eval never :results output silent
:END:
** Resulting output
#+begin_src sh
cargo clean
#+end_src

#+begin_src sh
cargo install --path language
#+end_src

#+begin_src sh
cargo build
#+end_src

#+begin_src sh
cargo hacspec -e v --dir coq/src --org-file WCCD.org hacspec-wccd --vc-update --vc-dir coq/
#+end_src
* Config
#+begin_src toml :tangle ./Cargo.toml :mkdirp yes :eval never
[package]
name = "hacspec-wccd"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/wccd.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { git = "https://github.com/xldenis/creusot", rev = "7763b3ae77205fba83182b9a6c3e69ad0b12fec7" }
# hacspec = {optional = true}
concordium-contracts-common = { git = "https://github.com/Concordium/concordium-contracts-common", rev = "84ff7db509ca1fbf958b47e5e5903b7662295850" ,  version = "=2.0.0" , default-features = false } # 0cffb859f736ff6726fa38600428a415d800d7b6
hacspec-concordium = { path = "../concordium" }
hacspec-concordium-derive = { path = "../concordium-derive" }

[features]
hacspec = []
# use_attributes = ["hacspec-attributes", "hacspec-attributes/print_attributes"]

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
quickcheck = "1"
quickcheck_macros = "1"
#+end_src

* Cis1
** Rust code
:PROPERTIES:
:header-args: :tangle ./src/cis1.rs :mkdirp yes
:END:
*** Imports
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
extern crate hacspec_lib;

use hacspec_lib::*;

// #[cfg(not(feature = "hacspec"))]
// extern crate creusot_contracts;
#[cfg(test)]
#[cfg(not(feature = "hacspec"))]
use creusot_contracts::{ensures, requires};

use hacspec_concordium::*;

#[cfg(feature = "hacspec")]
use concert_lib::*;

#+end_src

#+begin_src rust :eval never
// #![cfg_attr(not(feature = "std"), no_std)]
// use concordium_std::*;
// #[cfg(not(feature = "std"))]
// use core::fmt;
// #[cfg(feature = "std")]
// use std::fmt;

#[cfg(not(feature = "hacspec"))]
use convert::TryFrom;

#[cfg(not(feature = "hacspec"))]
pub use hacspec_concordium::num::NonZeroI32;

#+end_src
*** Consts
#+begin_src rust :eval never
/// Tag for the CIS1 Transfer event.
pub const TRANSFER_EVENT_TAG: u8 = 255u8; // u8::MAX
/// Tag for the CIS1 Mint event.
pub const MINT_EVENT_TAG: u8 = 255u8 - 1u8; // u8::MAX
/// Tag for the CIS1 Burn event.
pub const BURN_EVENT_TAG: u8 = 255u8 - 2u8; // u8::MAX
/// Tag for the CIS1 UpdateOperator event.
pub const UPDATE_OPERATOR_EVENT_TAG: u8 = 255u8 - 3u8; // u8::MAX
/// Tag for the CIS1 TokenMetadata event.
pub const TOKEN_METADATA_EVENT_TAG: u8 = 255u8 - 4u8; // u8::MAX

#+end_src
*** Types
#+begin_src rust :eval never
/// Sha256 digest
#[cfg(feature = "hacspec")]
array!(Sha256, 32, u8);

#[cfg(not(feature = "hacspec"))]
pub type Sha256 = [u8; 32];

// pub type Sha256 = ([
//     0u8;0u8;0u8;0u8;0u8;0u8;0u8;0u8;
//     0u8;0u8;0u8;0u8;0u8;0u8;0u8;0u8;
//     0u8;0u8;0u8;0u8;0u8;0u8;0u8;0u8;
//     0u8;0u8;0u8;0u8;0u8;0u8;0u8;0u8];

#[cfg(feature = "hacspec")]
pub struct MetadataUrl(pub String, pub Option<Sha256>);

#[cfg(not(feature = "hacspec"))]
/// The location of the metadata and an optional hash of the content.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType, Clone)]
pub struct MetadataUrl {
    /// The URL following the specification RFC1738.
    // #[concordium(size_length = 2)]
    pub url: String,
    /// A optional hash of the content.
    pub hash: Option<Sha256>,
}

#+end_src

#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// Trait for marking types as CIS1 token IDs.
/// For a type to be a valid CIS1 token ID it must implement serialization and
/// schema type, such that the first byte indicates how many bytes is used to
/// represent the token ID, followed by this many bytes for the token ID.
///
/// Note: The reason for introducing such a trait instead of representing every
/// token ID using Vec<u8> is to allow smart contracts to use specialized token
/// ID implementations avoiding allocations.
pub trait IsTokenId: Serialize + schema::SchemaType {}

#+end_src
*** TokenIdVec
#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
// #[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Clone, Serialize)]
pub struct TokenIdVec(pub PublicByteSeq);

#[cfg(not(feature = "hacspec"))]
/// Token Identifier, which combined with the address of the contract instance,
/// forms the unique identifier of a token type.
///
/// This token ID type can represent every possible token ID but requires
/// allocating a Vec. Using a fixed size token ID type (such as `TokenIdFixed`)
/// will avoid this.
///
/// The CIS1 specification allows for up to 255 bytes for the token ID, but
/// unless the bytes have some significant meaning, it is most likely better to
/// use a smaller fixed size token ID such as `TokenIdU8`.
#[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Clone, Serialize)]
pub struct TokenIdVec(
    // #[concordium(size_length = 1)]
    pub Vec<u8>,
);

#[cfg(not(feature = "hacspec"))]
impl IsTokenId for TokenIdVec {}

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for TokenIdVec {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U8, Box::new(schema::Type::U8))
    }
}

// #[cfg(not(feature="hacspec"))]
// /// Display the token ID as a uppercase hex string
// impl fmt::Display for TokenIdVec {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         for byte in &self.0 {
//             write!(f, "{:02X}", byte)?;
//         }
//         Ok(())
//     }
// }

#+end_src
*** TokenIdFixed
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// Token Identifier, which combined with the address of the contract instance,
/// forms the unique identifier of a token type.
///
/// The CIS1 specification allows for up to 255 bytes for the token ID, but for
/// most cases using a smaller token ID is fine and can reduce contract energy
/// costs.
///
/// This token ID uses an array for representing the token ID bytes which means
/// the token ID space is fixed to `N` number of bytes and some token IDs cannot
/// be represented. For a more general token ID type see `TokenIdVec`.
/// For fixed sized token IDs with integer representations see `TokenIdU8`,
/// `TokenIdU16`, `TokenIdU32` and `TokenIdU64`.
#[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdFixed<const N: usize>(pub [u8; N]);

#[cfg(not(feature = "hacspec"))]
impl<const N: usize> IsTokenId for TokenIdFixed<N> {}

#[cfg(not(feature = "hacspec"))]
impl<const N: usize> schema::SchemaType for TokenIdFixed<N> {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U8, Box::new(schema::Type::U8))
    }
}

#[cfg(not(feature = "hacspec"))]
impl<const N: usize> From<[u8; N]> for TokenIdFixed<N> {
    fn from(id: [u8; N]) -> Self {
        TokenIdFixed(id)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdFixed` is serialized as the value of the first byte represents
/// the number of bytes followed for the rest of the token ID.
impl<const N: usize> Serial for TokenIdFixed<N> {
    fn serial<W: Write>(&self, out: &mut W) -> Result<(), W::Err> {
        let len = u8::try_from(N).map_err(|_| W::Err::default())?;
        out.write_u8(len)?;
        for byte in self.0 {
            out.write_u8(byte)?;
        }
        Ok(())
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdFixed` is deserialized by reading the first byte represents the
/// number of bytes and ensuring this value corresponds with the number of bytes
/// to use for the token ID.
impl<const N: usize> Deserial for TokenIdFixed<N> {
    fn deserial<R: Read>(source: &mut R) -> ParseResult<Self> {
        let byte_length = source.read_u8()?;
        if usize::from(byte_length) != N {
            return Err(ParseError::default());
        }
        let bytes: [u8; N] = source.get()?;
        Ok(TokenIdFixed(bytes))
    }
}

// #[cfg(not(feature="hacspec"))]
// /// Display the token ID as a uppercase hex string
// impl<const N: usize> fmt::Display for TokenIdFixed<N> {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         for byte in &self.0 {
//             write!(f, "{:02X}", byte)?;
//         }
//         Ok(())
//     }
// }

#+end_src
*** TokenIdU64
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// Token Identifier, which combined with the address of the contract instance,
/// forms the unique identifier of a token type.
///
/// The CIS1 specification allows for up to 255 bytes for the token ID, but for
/// most cases using a smaller token ID is fine and can reduce contract energy
/// costs.
///
/// This token ID uses u64 for representing the token ID bytes which means the
/// token ID space is fixed to 8 bytes and some token IDs cannot be represented.
/// For a more general token ID type see `TokenIdVec`.
#[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdU64(pub u64);

#[cfg(not(feature = "hacspec"))]
impl IsTokenId for TokenIdU64 {}

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for TokenIdU64 {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U8, Box::new(schema::Type::U8))
    }
}

#[cfg(not(feature = "hacspec"))]
impl From<u64> for TokenIdU64 {
    fn from(id: u64) -> Self {
        TokenIdU64(id)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU64` is serialized with one byte with the value 8 followed by 8
/// bytes to encode a u64 in little endian.
impl Serial for TokenIdU64 {
    fn serial<W: Write>(&self, out: &mut W) -> Result<(), W::Err> {
        out.write_u8(8)?;
        out.write_u64(self.0)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU64` will deserialize one byte ensuring this contains the value
/// 8 and then deserialize a u64 as little endian. It will result in an error if
/// the first byte is not 8.
impl Deserial for TokenIdU64 {
    fn deserial<R: Read>(source: &mut R) -> ParseResult<Self> {
        let byte_length = source.read_u8()?;
        if byte_length == 8 {
            Ok(TokenIdU64(source.read_u64()?))
        } else {
            Err(ParseError::default())
        }
    }
}

// #[cfg(not(feature="hacspec"))]
// /// Display the token ID as a uppercase hex string
// impl fmt::Display for TokenIdU64 {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         for byte in &self.0.to_le_bytes() {
//             write!(f, "{:02X}", byte)?;
//         }
//         Ok(())
//     }
// }

#+end_src
*** TokenIdU32
#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
// #[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdU32(pub u32);

#[cfg(not(feature = "hacspec"))]
/// Token Identifier, which combined with the address of the contract instance,
/// forms the unique identifier of a token type.
///
/// The CIS1 specification allows for up to 255 bytes for the token ID, but for
/// most cases using a smaller token ID is fine and can reduce contract energy
/// costs.
///
/// This token ID uses u32 for representing the token ID bytes which means the
/// token ID space is fixed to 4 bytes and some token IDs cannot be represented.
/// For a more general token ID type see `TokenIdVec`.
#[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdU32(pub u32);

#[cfg(not(feature = "hacspec"))]
impl IsTokenId for TokenIdU32 {}

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for TokenIdU32 {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U8, Box::new(schema::Type::U8))
    }
}

#[cfg(not(feature = "hacspec"))]
impl From<u32> for TokenIdU32 {
    fn from(id: u32) -> Self {
        TokenIdU32(id)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU32` is serialized with one byte with the value 4 followed by 4
/// bytes to encode a u32 in little endian.
impl Serial for TokenIdU32 {
    fn serial<W: Write>(&self, out: &mut W) -> Result<(), W::Err> {
        out.write_u8(4)?;
        out.write_u32(self.0)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU32` will deserialize one byte ensuring this contains the value
/// 4 and then deserialize a u32 as little endian. It will result in an error if
/// the first byte is not 4.
impl Deserial for TokenIdU32 {
    fn deserial<R: Read>(source: &mut R) -> ParseResult<Self> {
        let byte_length = source.read_u8()?;
        if byte_length == 4 {
            Ok(TokenIdU32(source.read_u32()?))
        } else {
            Err(ParseError::default())
        }
    }
}

// /// Display the token ID as a uppercase hex string
// impl fmt::Display for TokenIdU32 {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         for byte in &self.0.to_le_bytes() {
//             write!(f, "{:02X}", byte)?;
//         }
//         Ok(())
//     }
// }

#+end_src
*** TokenIdU16
#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
// #[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdU16(pub u16);

#[cfg(not(feature = "hacspec"))]
/// Token Identifier, which combined with the address of the contract instance,
/// forms the unique identifier of a token type.
///
/// The CIS1 specification allows for up to 255 bytes for the token ID, but for
/// most cases using a smaller token ID is fine and can reduce contract energy
/// costs.
///
/// This token ID uses u16 for representing the token ID bytes which means the
/// token ID space is fixed to 2 bytes and some token IDs cannot be represented.
/// For a more general token ID type see `TokenIdVec`.
#[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdU16(pub u16);

#[cfg(not(feature = "hacspec"))]
impl IsTokenId for TokenIdU16 {}

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for TokenIdU16 {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U8, Box::new(schema::Type::U8))
    }
}

#[cfg(not(feature = "hacspec"))]
impl From<u16> for TokenIdU16 {
    fn from(id: u16) -> Self {
        TokenIdU16(id)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU16` is serialized with one byte with the value 2 followed by 2
/// bytes to encode a u16 in little endian.
impl Serial for TokenIdU16 {
    fn serial<W: Write>(&self, out: &mut W) -> Result<(), W::Err> {
        out.write_u8(2)?;
        out.write_u16(self.0)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU16` will deserialize one byte ensuring this contains the value
/// 2 and then deserialize a u16 as little endian. It will result in an error if
/// the first byte is not 2.
impl Deserial for TokenIdU16 {
    fn deserial<R: Read>(source: &mut R) -> ParseResult<Self> {
        let byte_length = source.read_u8()?;
        if byte_length == 2 {
            Ok(TokenIdU16(source.read_u16()?))
        } else {
            Err(ParseError::default())
        }
    }
}

// /// Display the token ID as a uppercase hex string
// impl fmt::Display for TokenIdU16 {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         for byte in &self.0.to_le_bytes() {
//             write!(f, "{:02X}", byte)?;
//         }
//         Ok(())
//     }
// }

#+end_src
*** TokenIdU8
#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
// #[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdU8(pub u8);

#[cfg(not(feature = "hacspec"))]
/// Token Identifier, which combined with the address of the contract instance,
/// forms the unique identifier of a token type.
///
/// The CIS1 specification allows for up to 255 bytes for the token ID, but for
/// most cases using a smaller token ID is fine and can reduce contract energy
/// costs.
///
/// This token ID uses u8 for representing the token ID bytes which means the
/// token ID space is fixed to 1 byte and some token IDs cannot be represented.
/// For a more general token ID type see `TokenIdVec`.
#[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdU8(pub u8);

#[cfg(not(feature = "hacspec"))]
impl IsTokenId for TokenIdU8 {}

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for TokenIdU8 {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U8, Box::new(schema::Type::U8))
    }
}

#[cfg(not(feature = "hacspec"))]
impl From<u8> for TokenIdU8 {
    fn from(id: u8) -> Self {
        TokenIdU8(id)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU8` is serialized with one byte with the value 1 followed by 1
/// bytes to encode a u8 in little endian.
impl Serial for TokenIdU8 {
    fn serial<W: Write>(&self, out: &mut W) -> Result<(), W::Err> {
        out.write_u8(1)?;
        out.write_u8(self.0)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdU8` will deserialize one byte ensuring this contains the value 1
/// and then deserialize a u8 as little endian. It will result in an error if
/// the first byte is not 1.
impl Deserial for TokenIdU8 {
    fn deserial<R: Read>(source: &mut R) -> ParseResult<Self> {
        let byte_length = source.read_u8()?;
        if byte_length == 1 {
            Ok(TokenIdU8(source.read_u8()?))
        } else {
            Err(ParseError::default())
        }
    }
}

// /// Display the token ID as a uppercase hex string
// impl fmt::Display for TokenIdU8 {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         for byte in &self.0.to_le_bytes() {
//             write!(f, "{:02X}", byte)?;
//         }
//         Ok(())
//     }
// }

#+end_src
*** TokenIdUnit
#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
// #[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdUnit();

#[cfg(not(feature = "hacspec"))]
/// Token Identifier, which combined with the address of the contract instance,
/// forms the unique identifier of a token type.
///
/// The CIS1 specification allows for up to 255 bytes for the token ID, but for
/// most cases using a smaller token ID is fine and can reduce contract energy
/// costs.
///
/// This token ID uses Unit for representing token IDs, which means only one
/// token ID can be represented with this type and other token IDs cannot be
/// represented. For a more general token ID type see `TokenIdVec`.
#[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Hash, Copy, Clone)]
pub struct TokenIdUnit();

#[cfg(not(feature = "hacspec"))]
impl IsTokenId for TokenIdUnit {}

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for TokenIdUnit {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U8, Box::new(schema::Type::U8))
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdUnit` is serialized with one byte with the value 0.
impl Serial for TokenIdUnit {
    fn serial<W: Write>(&self, out: &mut W) -> Result<(), W::Err> {
        out.write_u8(0)
    }
}

#[cfg(not(feature = "hacspec"))]
/// The `TokenIdUnit` will deserialize one byte ensuring this contains the value
/// 0. It will result in an error if the byte is not 0.
impl Deserial for TokenIdUnit {
    fn deserial<R: Read>(source: &mut R) -> ParseResult<Self> {
        let byte_length = source.read_u8()?;
        if byte_length == 0 {
            Ok(TokenIdUnit())
        } else {
            Err(ParseError::default())
        }
    }
}

#+end_src
*** More data types -- events
#+begin_src rust :eval never
// #[cfg(not(feature="hacspec"))]
/// An amount of a specific token type.
pub type TokenAmount = u64;

#[cfg(not(feature = "hacspec"))]
/// An untagged event of a transfer of some amount of tokens from one address to
/// another. For a tagged version, use `Cis1Event`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct TransferEvent<T: IsTokenId> {
    /// The ID of the token being transferred.
    pub token_id: T,
    /// The amount of tokens being transferred.
    pub amount: TokenAmount,
    /// The address owning these tokens before the transfer.
    pub from: Address,
    /// The address to receive these tokens after the transfer.
    pub to: Address,
}

#[cfg(not(feature = "hacspec"))]
/// An untagged event of tokens being minted, could be a new token type or
/// extending the total supply of existing token.
/// For a tagged version, use `Cis1Event`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct MintEvent<T: IsTokenId> {
    /// The ID of the token being minted, (possibly a new token ID).
    pub token_id: T,
    /// The number of tokens being minted, this is allowed to be 0 as well.
    pub amount: TokenAmount,
    /// The initial owner of these newly minted amount of tokens.
    pub owner: Address,
}

#[cfg(not(feature = "hacspec"))]
/// An untagged event of some amount of a token type being burned.
/// For a tagged version, use `Cis1Event`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct BurnEvent<T: IsTokenId> {
    /// The ID of the token where an amount is being burned.
    pub token_id: T,
    /// The amount of tokens being burned.
    pub amount: TokenAmount,
    /// The owner of the tokens being burned.
    pub owner: Address,
}

#[cfg(feature = "hacspec")]
// #[derive(Debug, Serialize, SchemaType)]
pub enum OperatorUpdate {
    /// Remove the operator.
    Remove,
    /// Add an address as an operator.
    Add,
}

#[cfg(not(feature = "hacspec"))]
/// The update to an the operator.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the variants cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub enum OperatorUpdate {
    /// Remove the operator.
    Remove,
    /// Add an address as an operator.
    Add,
}

#[cfg(feature = "hacspec")]
// #[derive(Debug, Serialize, SchemaType)]
pub struct UpdateOperatorEvent(pub OperatorUpdate, pub UserAddress, pub UserAddress);

#[cfg(not(feature = "hacspec"))]
/// An untagged event of an update to an operator address for an owner address.
/// For a tagged version, use `Cis1Event`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct UpdateOperatorEvent {
    /// The update to the operator.
    pub update: OperatorUpdate,
    /// The address for whom, the operator is updated.
    pub owner: Address,
    /// The address who is the operator being updated.
    pub operator: Address,
}

#[cfg(not(feature = "hacspec"))]
/// An untagged event for setting the metadata for a token.
/// For a tagged version, use `Cis1Event`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct TokenMetadataEvent<T: IsTokenId> {
    /// The ID of the token.
    pub token_id: T,
    /// The location of the metadata.
    pub metadata_url: MetadataUrl,
}

#[cfg(not(feature = "hacspec"))]
/// Tagged CIS1 event to be serialized for the event log.
#[derive(Debug)]
pub enum Cis1Event<T: IsTokenId> {
    /// A transfer between two addresses of some amount of tokens.
    Transfer(TransferEvent<T>),
    /// Creation of new tokens, could be both adding some amounts to an existing
    /// token or introduce an entirely new token ID.
    Mint(MintEvent<T>),
    /// Destruction of tokens removing some amounts of a token.
    Burn(BurnEvent<T>),
    /// Updates to an operator for a specific address and token id.
    UpdateOperator(UpdateOperatorEvent),
    /// Setting the metadata for a token.
    TokenMetadata(TokenMetadataEvent<T>),
}

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> Serial for Cis1Event<T> {
    fn serial<W: Write>(&self, out: &mut W) -> Result<(), W::Err> {
        match self {
            Cis1Event::Transfer(event) => {
                out.write_u8(TRANSFER_EVENT_TAG)?;
                event.serial(out)
            }
            Cis1Event::Mint(event) => {
                out.write_u8(MINT_EVENT_TAG)?;
                event.serial(out)
            }
            Cis1Event::Burn(event) => {
                out.write_u8(BURN_EVENT_TAG)?;
                event.serial(out)
            }
            Cis1Event::UpdateOperator(event) => {
                out.write_u8(UPDATE_OPERATOR_EVENT_TAG)?;
                event.serial(out)
            }
            Cis1Event::TokenMetadata(event) => {
                out.write_u8(TOKEN_METADATA_EVENT_TAG)?;
                event.serial(out)
            }
        }
    }
}

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> Deserial for Cis1Event<T> {
    fn deserial<R: Read>(source: &mut R) -> ParseResult<Self> {
        let tag = source.read_u8()?;
        match tag {
            TRANSFER_EVENT_TAG => TransferEvent::<T>::deserial(source).map(Cis1Event::Transfer),
            MINT_EVENT_TAG => MintEvent::<T>::deserial(source).map(Cis1Event::Mint),
            BURN_EVENT_TAG => BurnEvent::<T>::deserial(source).map(Cis1Event::Burn),
            UPDATE_OPERATOR_EVENT_TAG => {
                UpdateOperatorEvent::deserial(source).map(Cis1Event::UpdateOperator)
            }
            TOKEN_METADATA_EVENT_TAG => {
                TokenMetadataEvent::<T>::deserial(source).map(Cis1Event::TokenMetadata)
            }
            _ => Err(ParseError::default()),
        }
    }
}

#[cfg(not(feature = "hacspec"))]
/// The different errors the contract can produce.
#[derive(Debug, PartialEq, Eq)]
pub enum Cis1Error<R> {
    /// Invalid token id (Error code: -42000001).
    InvalidTokenId,
    /// The balance of the token owner is insufficient for the transfer (Error
    /// code: -42000002).
    InsufficientFunds,
    /// Sender is unauthorized to call this function (Error code: -42000003).
    Unauthorized,
    /// Custom error
    Custom(R),
}

#[cfg(not(feature = "hacspec"))]
/// Convert Cis1Error into a reject with error code:
/// - InvalidTokenId: -42000001
/// - InsufficientFunds: -42000002
/// - Unauthorized: -42000003
impl<R: Into<Reject>> From<Cis1Error<R>> for Reject {
    fn from(err: Cis1Error<R>) -> Self {
        let error_code = match err {
            Cis1Error::InvalidTokenId => unsafe { NonZeroI32::new_unchecked(-42000001) },
            Cis1Error::InsufficientFunds => unsafe { NonZeroI32::new_unchecked(-42000002) },
            Cis1Error::Unauthorized => unsafe { NonZeroI32::new_unchecked(-42000003) },
            Cis1Error::Custom(reject) => reject.into().error_code,
        };
        Self { error_code }
    }
}

#[cfg(not(feature = "hacspec"))]
impl<X: From<LogError>> From<LogError> for Cis1Error<X> {
    #[inline]
    fn from(err: LogError) -> Self {
        Cis1Error::Custom(X::from(err))
    }
}

#[cfg(not(feature = "hacspec"))]
impl<X: From<ParseError>> From<ParseError> for Cis1Error<X> {
    #[inline]
    fn from(err: ParseError) -> Self {
        Cis1Error::Custom(X::from(err))
    }
}

#+end_src
*** Receiver
#+begin_src rust :eval never
#[cfg_attr(feature = "hacspec", derive(Debug, Serialize))]
pub enum ReceiverHacspec {
    Account(
        PublicByteSeq,
    ),
    Contract(
        PublicByteSeq,
        String,
    ),
}

#[cfg(not(feature = "hacspec"))]
/// The receiving address for a transfer, similar to the Address type, but
/// contains extra information when the receiver address is a contract.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the variants and the order of their fields
// cannot be changed.
#[derive(Debug, Serialize)]
pub enum Receiver {
    /// The receiver is an account address.
    Account(
        /// The receiving address.
        AccountAddress,
    ),
    /// The receiver is a contract address.
    Contract(
        /// The receiving address.
        ContractAddress,
        /// The function to call on the receiving contract.
        OwnedReceiveName,
    ),
}

#[cfg(not(feature = "hacspec"))]
impl Receiver {
    /// Construct a receiver from an account address.
    pub fn from_account(address: AccountAddress) -> Self {
        Receiver::Account(address)
    }

    /// Construct a receiver from a contract address.
    pub fn from_contract(address: ContractAddress, function: OwnedReceiveName) -> Self {
        Receiver::Contract(address, function)
    }

    /// Get the Address of the receiver.
    pub fn address(&self) -> Address {
        match self {
            Receiver::Account(address) => Address::Account(*address),
            Receiver::Contract(address, ..) => Address::Contract(*address),
        }
    }
}

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for Receiver {
    fn get_type() -> schema::Type {
        schema::Type::Enum(vec![
            (
                String::from("Account"),
                schema::Fields::Unnamed(vec![AccountAddress::get_type()]),
            ),
            (
                String::from("Contract"),
                schema::Fields::Unnamed(vec![
                    ContractAddress::get_type(),
                    OwnedReceiveName::get_type(),
                ]),
            ),
        ])
    }
}

#[cfg(not(feature = "hacspec"))]
impl From<AccountAddress> for Receiver {
    fn from(address: AccountAddress) -> Self {
        Self::from_account(address)
    }
}

#+end_src
*** Additional Data
#+begin_src rust :eval never
#[cfg_attr(feature = "hacspec", derive(Debug, Serialize))]
pub struct AdditionalDataHacspec(Seq<u8>);

#[cfg(not(feature = "hacspec"))]
/// Additional information to include with a transfer.
#[derive(Debug, Serialize)]
pub struct AdditionalData(
    // #[concordium(size_length = 2)]
    Vec<u8>,
);

#[cfg(not(feature = "hacspec"))]
impl schema::SchemaType for AdditionalData {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U16, Box::new(schema::Type::U8))
    }
}

#[cfg(not(feature = "hacspec"))]
impl AdditionalData {
    /// Construct an AdditionalData containing no data.
    pub fn empty() -> Self {
        AdditionalData(Vec::new())
    }
}

#[cfg(not(feature = "hacspec"))]
impl From<Vec<u8>> for AdditionalData {
    fn from(data: Vec<u8>) -> Self {
        AdditionalData(data)
    }
}

#[cfg(not(feature = "hacspec"))]
impl AsRef<[u8]> for AdditionalData {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

#+end_src
*** Transfer
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// A single transfer of some amount of a token.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize)]
pub struct Transfer<T: IsTokenId> {
    /// The ID of the token being transferred.
    pub token_id: T,
    /// The amount of tokens being transferred.
    pub amount: TokenAmount,
    /// The address owning the tokens being transferred.
    pub from: Address,
    /// The address receiving the tokens being transferred.
    pub to: Receiver,
    /// Additional data to include in the transfer.
    /// Can be used for additional arguments.
    pub data: AdditionalData,
}

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> schema::SchemaType for Transfer<T> {
    fn get_type() -> schema::Type {
        schema::Type::Struct(schema::Fields::Named(vec![
            (String::from("token_id"), T::get_type()),
            (String::from("amount"), TokenAmount::get_type()),
            (String::from("from"), Address::get_type()),
            (String::from("to"), Receiver::get_type()),
            (String::from("data"), AdditionalData::get_type()),
        ]))
    }
}

#[cfg(not(feature = "hacspec"))]
/// The parameter type for the contract function `transfer`.
#[derive(Debug, Serialize)]
pub struct TransferParams<T: IsTokenId>(
    // #[concordium(size_length = 2)]
    pub Vec<Transfer<T>>,
);

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> schema::SchemaType for TransferParams<T> {
    fn get_type() -> schema::Type {
        schema::Type::List(schema::SizeLength::U16, Box::new(Transfer::<T>::get_type()))
    }
}

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> From<Vec<Transfer<T>>> for TransferParams<T> {
    fn from(transfers: Vec<Transfer<T>>) -> Self {
        TransferParams(transfers)
    }
}

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> AsRef<[Transfer<T>]> for TransferParams<T> {
    fn as_ref(&self) -> &[Transfer<T>] {
        &self.0
    }
}

#+end_src
*** Update Operator
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// A single update of an operator.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct UpdateOperator {
    /// The update for this operator.
    pub update: OperatorUpdate,
    /// The address which is either added or removed as an operator.
    /// Note: The address for whom this will become an operator is the sender of
    /// the contract transaction.
    pub operator: Address,
}

#[cfg(not(feature = "hacspec"))]
/// The parameter type for the contract function `updateOperator`.
#[derive(Debug, Serialize, SchemaType)]
pub struct UpdateOperatorParams(
    // #[concordium(size_length = 2)]
    pub Vec<UpdateOperator>,
);

#+end_src
*** Balance of
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// A query for the balance of a given address for a given token.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct BalanceOfQuery<T: IsTokenId> {
    /// The ID of the token for which to query the balance of.
    pub token_id: T,
    /// The address for which to query the balance of.
    pub address: Address,
}

#[cfg(not(feature = "hacspec"))]
/// The parameter type for the contract function `balanceOf`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct BalanceOfQueryParams<T: IsTokenId> {
    /// The contract to trigger with the results of the queries.
    pub result_contract: ContractAddress,
    /// The contract function to trigger with the results of the queries.
    pub result_function: OwnedReceiveName,
    /// List of balance queries.
    // #[concordium(size_length = 2)]
    pub queries: Vec<BalanceOfQuery<T>>,
}

#[cfg(not(feature = "hacspec"))]
/// BalanceOf query with the result of the query.
pub type BalanceOfQueryResult<T> = (BalanceOfQuery<T>, TokenAmount);

#[cfg(not(feature = "hacspec"))]
/// The response which is sent back when calling the contract function
/// `balanceOf`.
/// It consists of the list of queries paired with their corresponding result.
#[derive(Debug, Serialize, SchemaType)]
pub struct BalanceOfQueryResponse<T: IsTokenId>(
    // #[concordium(size_length = 2)]
    Vec<BalanceOfQueryResult<T>>,
);

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> From<Vec<BalanceOfQueryResult<T>>> for BalanceOfQueryResponse<T> {
    fn from(results: Vec<BalanceOfQueryResult<T>>) -> Self {
        BalanceOfQueryResponse(results)
    }
}

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> AsRef<[BalanceOfQueryResult<T>]> for BalanceOfQueryResponse<T> {
    fn as_ref(&self) -> &[BalanceOfQueryResult<T>] {
        &self.0
    }
}

#+end_src
*** Operator of
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// A query for the operator of a given address for a given token.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct OperatorOfQuery {
    /// The ID of the token for which to query the balance of.
    pub owner: Address,
    /// The address for which to check for being an operator of the owner.
    pub address: Address,
}

#[cfg(not(feature = "hacspec"))]
/// The parameter type for the contract function `operatorOf`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct OperatorOfQueryParams {
    /// The contract to trigger with the results of the queries.
    pub result_contract: ContractAddress,
    /// The contract function to trigger with the results of the queries.
    pub result_function: OwnedReceiveName,
    /// List of operatorOf queries.
    // #[concordium(size_length = 2)]
    pub queries: Vec<OperatorOfQuery>,
}

#[cfg(not(feature = "hacspec"))]
/// OperatorOf query with the result of the query.
pub type OperatorOfQueryResult = (OperatorOfQuery, bool);

#[cfg(not(feature = "hacspec"))]
/// The response which is sent back when calling the contract function
/// `operatorOf`.
/// It consists of the list of queries paired with their corresponding result.
#[derive(Debug, Serialize, SchemaType)]
pub struct OperatorOfQueryResponse(
    // #[concordium(size_length = 2)]
    Vec<OperatorOfQueryResult>,
);

#[cfg(not(feature = "hacspec"))]
impl From<Vec<OperatorOfQueryResult>> for OperatorOfQueryResponse {
    fn from(results: Vec<OperatorOfQueryResult>) -> Self {
        OperatorOfQueryResponse(results)
    }
}

#[cfg(not(feature = "hacspec"))]
impl AsRef<[OperatorOfQueryResult]> for OperatorOfQueryResponse {
    fn as_ref(&self) -> &[OperatorOfQueryResult] {
        &self.0
    }
}

#+end_src
*** Token metadata
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// The parameter type for the contract function `tokenMetadata`.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct TokenMetadataQueryParams<T: IsTokenId> {
    /// The contract to trigger with the results of the queries.
    pub result_contract: ContractAddress,
    /// The contract function to trigger with the results of the queries.
    pub result_function: OwnedReceiveName,
    /// List of balance queries.
    // #[concordium(size_length = 2)]
    pub queries: Vec<T>,
}

#[cfg(not(feature = "hacspec"))]
/// TokenMetadata query with the result of the query.
pub type TokenMetadataQueryResult<T> = (T, MetadataUrl);

#[cfg(not(feature = "hacspec"))]
/// The response which is sent back when calling the contract function
/// `tokenMetadata`.
/// It consists of the list of queries paired with their corresponding result.
#[derive(Debug, Serialize, SchemaType)]
pub struct TokenMetadataQueryResponse<T: IsTokenId>(
    // #[concordium(size_length = 2)]
    Vec<TokenMetadataQueryResult<T>>,
);

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> From<Vec<TokenMetadataQueryResult<T>>> for TokenMetadataQueryResponse<T> {
    fn from(results: Vec<TokenMetadataQueryResult<T>>) -> Self {
        TokenMetadataQueryResponse(results)
    }
}

#[cfg(not(feature = "hacspec"))]
impl<T: IsTokenId> AsRef<[TokenMetadataQueryResult<T>]> for TokenMetadataQueryResponse<T> {
    fn as_ref(&self) -> &[TokenMetadataQueryResult<T>] {
        &self.0
    }
}

#+end_src
*** On Receivivingreceiver
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// The parameter type for a contract function which receives CIS1 tokens.
// Note: For the serialization to be derived according to the CIS1
// specification, the order of the fields cannot be changed.
#[derive(Debug, Serialize, SchemaType)]
pub struct OnReceivingCis1Params<T: IsTokenId> {
    /// The ID of the token received.
    pub token_id: T,
    /// The amount of tokens received.
    pub amount: TokenAmount,
    /// The previous owner of the tokens.
    pub from: Address,
    /// The name of the token contract which is tracking the token and
    /// implements CIS1.
    pub contract_name: OwnedContractName,
    /// Some extra information which where sent as part of the transfer.
    pub data: AdditionalData,
}
#+end_src

* WCCD smart contract specification
** Rust code
:PROPERTIES:
:header-args: :tangle ./src/wccd.rs :mkdirp yes
:END:
*** Imports
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
extern crate hacspec_lib;

use hacspec_lib::*;

// #[cfg(not(feature = "hacspec"))]
// extern crate creusot_contracts;
#[cfg(test)]
#[cfg(not(feature = "hacspec"))]
use creusot_contracts::{ensures, requires};

use hacspec_concordium::*;

#[cfg(feature = "hacspec")]
use concert_lib::*;

#+end_src

#+begin_src rust :eval never
// #![cfg_attr(not(feature = "std"), no_std)]
// use concordium_cis1::*;

mod cis1;
pub use cis1::*;

#[cfg(not(feature = "hacspec"))]
pub use concordium_contracts_common::{HashMap as Map, HashSet as Set};

// #[cfg(not(feature = "hacspec"))]
// pub use concordium_impls::*;
// #[cfg(not(feature = "hacspec"))]
// pub use concordium_prims::*;

// #![cfg_attr(not(feature = "std"), no_std)]
// use concordium_std::*;
// #[cfg(not(feature = "std"))]
// use core::fmt;
// #[cfg(feature = "std")]
// use std::fmt;

#+end_src
*** Consts
#+begin_src rust :eval never
/// Contract token ID type.
/// Since this contract will only ever contain this one token type, we use the
/// smallest possible token ID.
type ContractTokenId = TokenIdUnit;

/// The id of the wCCD token in this contract.
const TOKEN_ID_WCCD: ContractTokenId = TokenIdUnit();

#[cfg(not(feature = "hacspec"))]
/// The metadata url for the wCCD token.
const TOKEN_METADATA_URL: &str = "https://some.example/token/wccd";

#+end_src

*** Types
#+begin_src rust :eval never
// Types

/// The state tracked for each address.
#[cfg_attr(feature = "hacspec", derive(Serialize, SchemaType))]
struct AddressStateHacspec (TokenAmount, PublicByteSeq);

#[cfg(not(feature = "hacspec"))]
/// The state tracked for each address.
#[derive(Serialize, SchemaType)]
struct AddressState {
    /// The number of tokens owned by this address.
    balance: TokenAmount,
    /// The address which are currently enabled as operators for this token and
    /// this address.
    // #[concordium(size_length = 1)]
    operators: Set<Address>,
}

#+end_src

#+begin_src rust :eval never
#[cfg_attr(feature = "hacspec", contract_state(contract = "CIS1-wCCD"))]
#[cfg_attr(feature = "hacspec", derive(Serialize, SchemaType))]
struct StateHacspec(pub PublicByteSeq); // Map<Address, AddressState>

#[cfg(not(feature = "hacspec"))]
/// The contract state,
#[contract_state(contract = "CIS1-wCCD")]
#[derive(Serialize, SchemaType)]
struct State {
    /// The state the one token.
    token: Map<Address, AddressState>,
}

#+end_src

#+begin_src rust :eval never
#[cfg_attr(feature = "hacspec", derive(Serialize, SchemaType))]
struct UnwrapParamsHacspec (TokenAmount, PublicByteSeq, ReceiverHacspec, AdditionalDataHacspec);

#[cfg(not(feature = "hacspec"))]
/// The parameter type for the contract function `unwrap`.
/// Takes an amount of tokens and unwrap the CCD and send it to a receiver.
#[derive(Serialize, SchemaType)]
struct UnwrapParams {
    /// The amount of tokens to unwrap.
    amount: TokenAmount,
    /// The owner of the tokens.
    owner: Address,
    /// The address to receive these unwrapped CCD.
    receiver: cis1::Receiver,
    /// Some additional bytes to include in the transfer.
    data: AdditionalData,
}

#+end_src

#+begin_src rust :eval never
#[cfg_attr(feature = "hacspec", derive(Serialize, SchemaType))]
struct WrapParamsHacspec (ReceiverHacspec, AdditionalDataHacspec);

#[cfg(not(feature = "hacspec"))]
/// The parameter type for the contract function `wrap`.
///
/// The receiver for the wrapped CCD tokens.
#[derive(Serialize, SchemaType)]
struct WrapParams {
    /// The address to receive these tokens.
    /// If the receiver is the sender of the message wrapping the tokens, it
    /// will not log a transfer.
    to: cis1::Receiver,
    /// Some additional bytes to include in a transfer.
    data: AdditionalData,
}

#+end_src

#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// The different errors the contract can produce.
#[derive(Serialize, Debug, PartialEq, Eq, Reject)]
enum CustomContractError {
    /// Failed parsing the parameter.
    #[from(ParseError)]
    ParseParams,
    /// Failed logging: Log is full.
    LogFull,
    /// Failed logging: Log is malformed.
    LogMalformed,
}

#+end_src

#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
type ContractError = Cis1Error<CustomContractError>;

#+end_src

#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
type ContractResult<A> = Result<A, ContractError>;

#+end_src

*** Implemenetations
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// Mapping the logging errors to ContractError.
impl From<LogError> for CustomContractError {
    fn from(le: LogError) -> Self {
        match le {
            LogError::Full => Self::LogFull,
            LogError::Malformed => Self::LogMalformed,
        }
    }
}

#[cfg(not(feature = "hacspec"))]
/// Mapping CustomContractError to ContractError
impl From<CustomContractError> for ContractError {
    fn from(c: CustomContractError) -> Self {
        Cis1Error::Custom(c)
    }
}

#[cfg(not(feature = "hacspec"))]
impl State {
    /// Creates a new state with no one owning any tokens by default.
    fn new() -> Self {
        State {
            token: Map::default(),
        }
    }

    /// Get the current balance of a given token id for a given address.
    /// Results in an error if the token id does not exist in the state.
    fn balance(
        &self,
        token_id: &ContractTokenId,
        address: &Address,
    ) -> ContractResult<TokenAmount> {
        // ensure_eq!(token_id, &TOKEN_ID_WCCD, ContractError::InvalidTokenId);
        Ok(self.token.get(address).map(|s| s.balance).unwrap_or(0))
    }

    /// Check is an address is an operator of a specific owner address.
    /// Results in an error if the token id does not exist in the state.
    fn is_operator(&self, address: &Address, owner: &Address) -> bool {
        self.token
            .get(owner)
            .map(|address_state| address_state.operators.contains(address))
            .unwrap_or(false)
    }

    /// Update the state with a transfer.
    /// Results in an error if the token id does not exist in the state or if
    /// the from address have insufficient tokens to do the transfer.
    fn transfer(
        &mut self,
        token_id: &ContractTokenId,
        amount: TokenAmount,
        from: &Address,
        to: &Address,
    ) -> ContractResult<()> {
        // ensure_eq!(token_id, &TOKEN_ID_WCCD, ContractError::InvalidTokenId);
        if amount == 0 {
            return Ok(());
        }
        let from_state = self
            .token
            .get_mut(from)
            .ok_or(ContractError::InsufficientFunds)?;
        ensure!(
            from_state.balance >= amount,
            ContractError::InsufficientFunds
        );
        from_state.balance -= amount;
        let to_state = self.token.entry(*to).or_insert_with(|| AddressState {
            balance: 0,
            operators: Set::default(),
        });
        to_state.balance += amount;
        Ok(())
    }

    /// Update the state adding a new operator for a given token id and address.
    /// Results in an error if the token id does not exist in the state.
    /// Succeeds even if the `operator` is already an operator for this
    /// `token_id` and `address`.
    fn add_operator(&mut self, owner: &Address, operator: &Address) {
        let address_state = self.token.entry(*owner).or_insert_with(|| AddressState {
            balance: 0,
            operators: Set::default(),
        });
        address_state.operators.insert(*operator);
    }

    /// Update the state removing an operator for a given token id and address.
    /// Results in an error if the token id does not exist in the state.
    /// Succeeds even if the `operator` is not an operator for this `token_id`
    /// and `address`.
    fn remove_operator(&mut self, owner: &Address, operator: &Address) {
        self.token
            .get_mut(owner)
            .map(|address_state| address_state.operators.remove(operator));
    }

    fn mint(
        &mut self,
        token_id: &ContractTokenId,
        amount: TokenAmount,
        owner: &Address,
    ) -> ContractResult<()> {
        // ensure_eq!(token_id, &TOKEN_ID_WCCD, ContractError::InvalidTokenId);
        let address_state = self.token.entry(*owner).or_insert_with(|| AddressState {
            balance: 0,
            operators: Set::default(),
        });
        address_state.balance += amount;
        Ok(())
    }

    fn burn(
        &mut self,
        token_id: &ContractTokenId,
        amount: TokenAmount,
        owner: &Address,
    ) -> ContractResult<()> {
        // ensure_eq!(token_id, &TOKEN_ID_WCCD, ContractError::InvalidTokenId);
        if amount == 0 {
            return Ok(());
        }
        let from_state = self
            .token
            .get_mut(owner)
            .ok_or(ContractError::InsufficientFunds)?;
        ensure!(
            from_state.balance >= amount,
            ContractError::InsufficientFunds
        );
        from_state.balance -= amount;
        Ok(())
    }
}

#+end_src

*** Contract
#+begin_src rust :eval never
// Contract functions

#[cfg(feature = "hacspec")]
/// Initialize contract instance with no initial tokens.
/// Logs a `Mint` event for the single token id with no amounts.
#[init(contract = "CIS1-wCCD", enable_logger)]
pub fn contract_init(ctx: Context) -> (Context, StateHacspec) {
    (ctx, StateHacspec(PublicByteSeq::new(0)))
}

#[cfg(not(feature = "hacspec"))]
/// Initialize contract instance with no initial tokens.
/// Logs a `Mint` event for the single token id with no amounts.
#[init(contract = "CIS1-wCCD", enable_logger)]
fn contract_init(ctx: &impl HasInitContext, logger: &mut impl HasLogger) -> InitResult<State> {
    // Construct the initial contract state.
    let state = State::new();
    // Get the instantiater of this contract instance.
    let invoker = Address::Account(ctx.init_origin());
    // Log event for the newly minted token.
    logger.log(&Cis1Event::Mint(MintEvent {
        token_id: TOKEN_ID_WCCD,
        amount: 0,
        owner: invoker,
    }))?;

    // Log event for where to find metadata for the token
    logger.log(&Cis1Event::TokenMetadata(TokenMetadataEvent {
        token_id: TOKEN_ID_WCCD,
        metadata_url: MetadataUrl {
            url: String::from(TOKEN_METADATA_URL),
            hash: None,
        },
    }))?;

    Ok(state)
}

#+end_src

#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(
    contract = "CIS1-wCCD",
    name = "wrap",
    parameter = "WrapParamsHacspec",
    enable_logger,
    payable
)]
// pub fn contract_wrap(contract_address_index : u64, contract_address_sub_index : u64, function: String, parameter: PublicByteSeq) {
fn contract_wrap(
    ctx: (Context, StateHacspec),
    amount: u64,
) -> Option<((Context, StateHacspec), ListAction)> {
    let (Context(owner, sender, balance, time), state) = ctx;

    let s = Seq::<HasAction>::new(0);

    // send_wrap_hacspec(
    //     contract_address_index,
    //     contract_address_sub_index,
    //     parameter.clone(),
    //     0u64,
    //     parameter.clone());

    Option::<((Context, StateHacspec), ListAction)>::Some((
        (Context(owner, sender, balance, time), state),
        s,
    ))
}

#[cfg(not(feature = "hacspec"))]
/// Wrap an amount of CCD into wCCD tokens and transfer the tokens if the sender
/// is not the receiver.
#[receive(
    contract = "CIS1-wCCD",
    name = "wrap",
    parameter = "WrapParams",
    enable_logger,
    payable
)]
fn contract_wrap<A: HasActions>(
    ctx: &impl HasReceiveContext,
    amount: Amount,
    logger: &mut impl HasLogger,
    state: &mut State,
) -> ContractResult<A> {
    let params: WrapParams = ctx.parameter_cursor().get()?;
    // Get the sender who invoked this contract function.
    let sender = ctx.sender();

    let receive_address = params.to.address();

    // Update the state.
    state.mint(&TOKEN_ID_WCCD, amount.micro_ccd, &receive_address)?;

    // Log the newly minted tokens.
    logger.log(&Cis1Event::Mint(MintEvent {
        token_id: TOKEN_ID_WCCD,
        amount: amount.micro_ccd,
        owner: sender,
    }))?;

    // Only log a transfer event if receiver is not the one who payed for this.
    if sender != receive_address {
        logger.log(&Cis1Event::Transfer(TransferEvent {
            token_id: TOKEN_ID_WCCD,
            amount: amount.micro_ccd,
            from: sender,
            to: receive_address,
        }))?;
    }

    // Send message to the receiver of the tokens.
    if let cis1::Receiver::Contract(address, function) = params.to {
        let parameter = OnReceivingCis1Params {
            token_id: TOKEN_ID_WCCD,
            amount: amount.micro_ccd,
            from: sender,
            contract_name: OwnedContractName::new_unchecked(String::from("init_CIS1-wCCD")),
            data: params.data,
        };
        // let param_bytes = concordium_contracts_common::to_bytes(&parameter);
        // Ok(A::send_raw(&address, function.as_ref(), Amount::zero(), &param_bytes))
        Ok(send_wrap(
            &address,
            function.as_ref(),
            Amount::zero(),
            &parameter,
        ))
    } else {
        Ok(A::accept())
    }
}

#+end_src

#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(
    contract = "CIS1-wCCD",
    name = "unwrap",
    parameter = "UnwrapParamsHacspec",
    enable_logger
)]
fn contract_unwrap(ctx: (Context, StateHacspec)) -> Option<((Context, StateHacspec), ListAction)> {
    let (Context(owner, sender, balance, time), state) = ctx;

    let s = Seq::<HasAction>::new(0);

    Option::<((Context, StateHacspec), ListAction)>::Some((
        (Context(owner, sender, balance, time), state),
        s,
    ))
}

#[cfg(not(feature = "hacspec"))]
/// Unwrap an amount of wCCD tokens into CCD
#[receive(
    contract = "CIS1-wCCD",
    name = "unwrap",
    parameter = "UnwrapParams",
    enable_logger
)]
fn contract_unwrap<A: HasActions>(
    ctx: &impl HasReceiveContext,
    logger: &mut impl HasLogger,
    state: &mut State,
) -> ContractResult<A> {
    let params: UnwrapParams = ctx.parameter_cursor().get()?;
    // Get the sender who invoked this contract function.
    let sender = ctx.sender();
    ensure!(
        sender == params.owner || state.is_operator(&sender, &params.owner),
        ContractError::Unauthorized
    );

    // Update the state.
    state.burn(&TOKEN_ID_WCCD, params.amount, &params.owner)?;

    // Log the burning of tokens.
    logger.log(&Cis1Event::Burn(BurnEvent {
        token_id: TOKEN_ID_WCCD,
        amount: params.amount,
        owner: params.owner,
    }))?;

    let unwrapped_amount = Amount::from_micro_ccd(params.amount);

    let action = match params.receiver {
        cis1::Receiver::Account(address) => A::simple_transfer(&address, unwrapped_amount),
        cis1::Receiver::Contract(address, function) => {
            send_wrap(&address, function.as_ref(), unwrapped_amount, &params.data)
        }
    };

    Ok(action)
}

#+end_src

#+begin_src rust :eval never
// Contract functions required by CIS1

#[allow(dead_code)]
type TransferParameterHacspec = (); // TODO: hacspec repr for TransferParams<ContractTokenId>;

#[cfg(not(feature = "hacspec"))]
#[allow(dead_code)]
type TransferParameter = TransferParams<ContractTokenId>;

#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(
    contract = "CIS1-wCCD",
    name = "transfer",
    parameter = "TransferParameterHacspec",
    enable_logger
)]
fn contract_transfer(ctx: (Context, StateHacspec)) -> Option<((Context, StateHacspec), ListAction)> {
    let (Context(owner, sender, balance, time), state) = ctx;

    let s = Seq::<HasAction>::new(0);

    Option::<((Context, StateHacspec), ListAction)>::Some((
        (Context(owner, sender, balance, time), state),
        s,
    ))
}

#[cfg(not(feature = "hacspec"))]
/// Execute a list of token transfers, in the order of the list.
///
/// Logs a `Transfer` event for each transfer in the list.
/// Produces an action which sends a message to each contract which was the
/// receiver of a transfer.
///
/// It rejects if:
/// - It fails to parse the parameter.
/// - Any of the transfers fail to be executed, which could be if:
///     - The `token_id` does not exist.
///     - The sender is not the owner of the token, or an operator for this
///       specific `token_id` and `from` address.
///     - The token is not owned by the `from`.
/// - Fails to log event.
/// - Any of the messages sent to contracts receiving a transfer choose to
///   reject.
#[receive(
    contract = "CIS1-wCCD",
    name = "transfer",
    parameter = "TransferParameter",
    enable_logger
)]
fn contract_transfer<A: HasActions>(
    ctx: &impl HasReceiveContext,
    logger: &mut impl HasLogger,
    state: &mut State,
) -> ContractResult<A> {
    let mut cursor = ctx.parameter_cursor();
    // Parse the number of transfers.
    let transfers_length: u8 = cursor.get()?;
    // Get the sender who invoked this contract function.
    let sender = ctx.sender();

    let mut actions = A::accept();
    // Loop over the number of transfers.
    for _ in 0..transfers_length {
        // Parse one of the transfers.
        let Transfer {
            token_id,
            amount,
            from,
            to,
            data,
        } = cursor.get()?;
        // Authenticate the sender for this transfer
        ensure!(
            from == sender || state.is_operator(&sender, &from),
            ContractError::Unauthorized
        );
        let to_address = to.address();
        // Update the contract state
        state.transfer(&token_id, amount, &from, &to_address)?;

        // Log transfer event
        logger.log(&Cis1Event::Transfer(TransferEvent {
            token_id,
            amount,
            from,
            to: to_address,
        }))?;

        // If the receiver is a contract, we add sending it a message to the list of
        // actions.
        if let cis1::Receiver::Contract(address, function) = to {
            let parameter = OnReceivingCis1Params {
                token_id,
                amount,
                from,
                contract_name: OwnedContractName::new_unchecked(String::from("init_CIS1-Multi")),
                data,
            };
            let action = send_wrap(&address, function.as_ref(), Amount::zero(), &parameter);
            actions = actions.and_then(action);
        }
    }
    Ok(actions)
}


#+end_src

#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(
    contract = "CIS1-wCCD",
    name = "updateOperator",
    parameter = "UpdateOperatorParams",
    enable_logger
)]
fn contract_update_operator(ctx: (Context, StateHacspec)) -> Option<((Context, StateHacspec), ListAction)> {
    let (Context(owner, sender, balance, time), state) = ctx;

    let s = Seq::<HasAction>::new(0);

    Option::<((Context, StateHacspec), ListAction)>::Some((
        (Context(owner, sender, balance, time), state),
        s,
    ))
}


#[cfg(not(feature="hacspec"))]
/// Enable or disable addresses as operators of the sender address.
/// Logs an `UpdateOperator` event.
///
/// It rejects if:
/// - It fails to parse the parameter.
/// - The operator address is the same as the sender address.
/// - Fails to log event.
#[receive(
    contract = "CIS1-wCCD",
    name = "updateOperator",
    parameter = "UpdateOperatorParams",
    enable_logger
)]
fn contract_update_operator<A: HasActions>(
    ctx: &impl HasReceiveContext,
    logger: &mut impl HasLogger,
    state: &mut State,
) -> ContractResult<A> {
    // Parse the parameter.
    let UpdateOperatorParams(params) = ctx.parameter_cursor().get()?;
    // Get the sender who invoked this contract function.
    let sender = ctx.sender();

    for param in params {
        // Update the operator in the state.
        match param.update {
            OperatorUpdate::Add => state.add_operator(&sender, &param.operator),
            OperatorUpdate::Remove => state.remove_operator(&sender, &param.operator),
        }

        // Log the appropriate event
        logger.log(&Cis1Event::<ContractTokenId>::UpdateOperator(UpdateOperatorEvent {
            owner:    sender,
            operator: param.operator,
            update:   param.update,
        }))?;
    }

    Ok(A::accept())
}

#+end_src

#+begin_src rust :eval never
#[cfg(not(feature="hacspec"))]
/// Parameter type for the CIS-1 function `balanceOf` specialized to the subset
/// of TokenIDs used by this contract.
// This type is pub to silence the dead_code warning, as this type is only used
// for when generating the schema.
pub type ContractBalanceOfQueryParams = BalanceOfQueryParams<ContractTokenId>;

#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(contract = "CIS1-wCCD", name = "balanceOf", parameter = "ContractBalanceOfQueryParams")]
fn contract_balance_of(ctx: (Context, StateHacspec)) -> Option<((Context, StateHacspec), ListAction)> {
    let (Context(owner, sender, balance, time), state) = ctx;

    let s = Seq::<HasAction>::new(0);

    Option::<((Context, StateHacspec), ListAction)>::Some((
        (Context(owner, sender, balance, time), state),
        s,
    ))
}

#[cfg(not(feature="hacspec"))]
/// Get the balance of given token IDs and addresses. It takes a contract
/// address plus contract function to invoke with the result.
///
/// It rejects if:
/// - Sender is not a contract.
/// - It fails to parse the parameter.
/// - Any of the queried `token_id` does not exist.
/// - Message sent back with the result rejects.
#[receive(contract = "CIS1-wCCD", name = "balanceOf", parameter = "ContractBalanceOfQueryParams")]
fn contract_balance_of<A: HasActions>(
    ctx: &impl HasReceiveContext,
    state: &mut State,
) -> ContractResult<A> {
    let mut cursor = ctx.parameter_cursor();
    // Parse the contract address to receive the result.
    let result_contract: ContractAddress = cursor.get()?;
    // Parse the contract function name to call with the result.
    let result_hook: OwnedReceiveName = cursor.get()?;
    // Parse the number of queries.
    let queries_length: u8 = cursor.get()?;

    // Build the response.
    let mut response = Vec::with_capacity(queries_length.into());
    for _ in 0..queries_length {
        // Parse one of the queries.
        let query: BalanceOfQuery<ContractTokenId> = ctx.parameter_cursor().get()?;
        // Query the state for balance.
        let amount = state.balance(&query.token_id, &query.address)?;
        response.push((query, amount));
    }
    // Send back the response.
    Ok(send_wrap(
        &result_contract,
        result_hook.as_ref(),
        Amount::zero(),
        &BalanceOfQueryResponse::from(response),
    ))
}

#+end_src

#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(contract = "CIS1-wCCD", name = "operatorOf", parameter = "OperatorOfQueryParams")]
fn contract_operator_of(ctx: (Context, StateHacspec)) -> Option<((Context, StateHacspec), ListAction)> {
    let (Context(owner, sender, balance, time), state) = ctx;

    let s = Seq::<HasAction>::new(0);

    Option::<((Context, StateHacspec), ListAction)>::Some((
        (Context(owner, sender, balance, time), state),
        s,
    ))
}

#[cfg(not(feature="hacspec"))]
/// Takes a list of queries. Each query is an owner address and some address to
/// check as an operator of the owner address. It takes a contract address plus
/// contract function to invoke with the result.
///
/// It rejects if:
/// - It fails to parse the parameter.
/// - Message sent back with the result rejects.
#[receive(contract = "CIS1-wCCD", name = "operatorOf", parameter = "OperatorOfQueryParams")]
fn contract_operator_of<A: HasActions>(
    ctx: &impl HasReceiveContext,
    state: &mut State,
) -> ContractResult<A> {
    // Parse the parameter.
    let params: OperatorOfQueryParams = ctx.parameter_cursor().get()?;
    // Build the response.
    let mut response = Vec::with_capacity(params.queries.len());
    for query in params.queries {
        // Query the state for address being an operator of owner.
        let is_operator = state.is_operator(&query.owner, &query.address);
        response.push((query, is_operator));
    }
    // Send back the response.
    Ok(send_wrap(
        &params.result_contract,
        params.result_function.as_ref(),
        Amount::zero(),
        &OperatorOfQueryResponse::from(response),
    ))
}

#[cfg(not(feature="hacspec"))]
/// Parameter type for the CIS-1 function `tokenMetadata` specialized to the
/// subset of TokenIDs used by this contract.
// This type is pub to silence the dead_code warning, as this type is only used
// for when generating the schema.
pub type ContractTokenMetadataQueryParams = TokenMetadataQueryParams<ContractTokenId>;

#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(
    contract = "CIS1-wCCD",
    name = "tokenMetadata",
    parameter = "ContractTokenMetadataQueryParams"
)]
fn contract_token_metadata(ctx: (Context, StateHacspec)) -> Option<((Context, StateHacspec), ListAction)> {
    let (Context(owner, sender, balance, time), state) = ctx;

    let s = Seq::<HasAction>::new(0);

    Option::<((Context, StateHacspec), ListAction)>::Some((
        (Context(owner, sender, balance, time), state),
        s,
    ))
}

#[cfg(not(feature="hacspec"))]
/// Get the token metadata URLs and checksums given a list of token IDs. It
/// takes a contract address plus contract function to invoke with the result.
///
/// It rejects if:
/// - It fails to parse the parameter.
/// - Any of the queried `token_id` does not exist.
/// - Message sent back with the result rejects.
#[receive(
    contract = "CIS1-wCCD",
    name = "tokenMetadata",
    parameter = "ContractTokenMetadataQueryParams"
)]
fn contract_token_metadata<A: HasActions>(
    ctx: &impl HasReceiveContext,
    _state: &mut State,
) -> ContractResult<A> {
    let mut cursor = ctx.parameter_cursor();
    // Parse the contract address to receive the result.
    let result_contract: ContractAddress = cursor.get()?;
    // Parse the contract function name to call with the result.
    let result_hook: OwnedReceiveName = cursor.get()?;
    // Parse the number of queries.
    let queries_length: u8 = cursor.get()?;

    // Build the response.
    let mut response = Vec::with_capacity(queries_length.into());
    for _ in 0..queries_length {
        let token_id: ContractTokenId = cursor.get()?;
        // Check the token exists.
        ensure_eq!(token_id, TOKEN_ID_WCCD, ContractError::InvalidTokenId);

        let metadata_url = MetadataUrl {
            url:  TOKEN_METADATA_URL.to_string(),
            hash: None,
        };
        response.push((token_id, metadata_url));
    }
    // Send back the response.
    Ok(send_wrap(
        &result_contract,
        result_hook.as_ref(),
        Amount::zero(),
        &TokenMetadataQueryResponse::from(response),
    ))
}

#+end_src

*** Tests
#+begin_src rust :eval never
// Tests

#[cfg(not(feature="hacspec"))]
#[concordium_cfg_test]
mod tests {
    use super::*;
    use test_infrastructure::*;

    const ACCOUNT_0: AccountAddress = AccountAddress([0u8; 32]);
    const ADDRESS_0: Address = Address::Account(ACCOUNT_0);
    const ACCOUNT_1: AccountAddress = AccountAddress([1u8; 32]);
    const ADDRESS_1: Address = Address::Account(ACCOUNT_1);

    /// Test helper function which creates a contract state where ADDRESS_0 owns
    /// 400 tokens.
    fn initial_state() -> State {
        let mut state = State::new();
        state.mint(&TOKEN_ID_WCCD, 400, &ADDRESS_0).expect_report("Failed to setup state");
        state
    }

    /// Test initialization succeeds and the tokens are owned by the contract
    /// instantiater and the appropriate events are logged.
    #[concordium_test]
    fn test_init() {
        // Setup the context
        let mut ctx = InitContextTest::empty();
        ctx.set_init_origin(ACCOUNT_0);

        let mut logger = LogRecorder::init();

        // Call the contract function.
        let result = contract_init(&ctx, &mut logger);

        // Check the result
        let state = result.expect_report("Contract initialization failed");

        // Check the state
        claim_eq!(state.token.len(), 0, "Only one token is initialized");
        let balance0 =
            state.balance(&TOKEN_ID_WCCD, &ADDRESS_0).expect_report("Token is expected to exist");
        claim_eq!(balance0, 0, "No initial tokens are owned by the contract instantiater");

        // Check the logs
        claim_eq!(logger.logs.len(), 2, "Exactly one event should be logged");
        claim!(
            logger.logs.contains(&to_bytes(&Cis1Event::Mint(MintEvent {
                owner:    ADDRESS_0,
                token_id: TOKEN_ID_WCCD,
                amount:   0,
            }))),
            "Missing event for minting the token"
        );
        claim!(
            logger.logs.contains(&to_bytes(&Cis1Event::TokenMetadata(TokenMetadataEvent {
                token_id:     TOKEN_ID_WCCD,
                metadata_url: MetadataUrl {
                    url:  String::from(TOKEN_METADATA_URL),
                    hash: None,
                },
            }))),
            "Missing event with metadata for the token"
        );
    }

    /// Test transfer succeeds, when `from` is the sender.
    #[concordium_test]
    fn test_transfer_account() {
        // Setup the context
        let mut ctx = ReceiveContextTest::empty();
        ctx.set_sender(ADDRESS_0);

        // and parameter.
        let transfer = Transfer {
            token_id: TOKEN_ID_WCCD,
            amount:   100,
            from:     ADDRESS_0,
            to:       cis1::Receiver::from_account(ACCOUNT_1),
            data:     AdditionalData::empty(),
        };
        let parameter = TransferParams::from(vec![transfer]);
        let parameter_bytes = to_bytes(&parameter);
        ctx.set_parameter(&parameter_bytes);

        let mut logger = LogRecorder::init();
        let mut state = State::new();
        state.mint(&TOKEN_ID_WCCD, 400, &ADDRESS_0).expect_report("Failed to setup state");

        // Call the contract function.
        let result: ContractResult<ActionsTree> = contract_transfer(&ctx, &mut logger, &mut state);
        // Check the result.
        let actions = result.expect_report("Results in rejection");
        claim_eq!(actions, ActionsTree::accept(), "No action should be produced.");

        // Check the state.
        let balance0 =
            state.balance(&TOKEN_ID_WCCD, &ADDRESS_0).expect_report("Token is expected to exist");
        let balance1 =
            state.balance(&TOKEN_ID_WCCD, &ADDRESS_1).expect_report("Token is expected to exist");
        claim_eq!(
            balance0,
            300,
            "Token owner balance should be decreased by the transferred amount"
        );
        claim_eq!(
            balance1,
            100,
            "Token receiver balance should be increased by the transferred amount"
        );

        // Check the logs.
        claim_eq!(logger.logs.len(), 1, "Only one event should be logged");
        claim_eq!(
            logger.logs[0],
            to_bytes(&Cis1Event::Transfer(TransferEvent {
                from:     ADDRESS_0,
                to:       ADDRESS_1,
                token_id: TOKEN_ID_WCCD,
                amount:   100,
            })),
            "Incorrect event emitted"
        )
    }

    /// Test transfer token fails, when sender is neither the owner or an
    /// operator of the owner.
    #[concordium_test]
    fn test_transfer_not_authorized() {
        // Setup the context
        let mut ctx = ReceiveContextTest::empty();
        ctx.set_sender(ADDRESS_1);

        // and parameter.
        let transfer = Transfer {
            from:     ADDRESS_0,
            to:       cis1::Receiver::from_account(ACCOUNT_1),
            token_id: TOKEN_ID_WCCD,
            amount:   100,
            data:     AdditionalData::empty(),
        };
        let parameter = TransferParams::from(vec![transfer]);
        let parameter_bytes = to_bytes(&parameter);
        ctx.set_parameter(&parameter_bytes);

        let mut logger = LogRecorder::init();
        let mut state = initial_state();

        // Call the contract function.
        let result: ContractResult<ActionsTree> = contract_transfer(&ctx, &mut logger, &mut state);
        // Check the result.
        let err = result.expect_err_report("Expected to fail");
        claim_eq!(err, ContractError::Unauthorized, "Error is expected to be Unauthorized")
    }

    /// Test transfer succeeds when sender is not the owner, but is an operator
    /// of the owner.
    #[concordium_test]
    fn test_operator_transfer() {
        // Setup the context
        let mut ctx = ReceiveContextTest::empty();
        ctx.set_sender(ADDRESS_1);

        // and parameter.
        let transfer = Transfer {
            from:     ADDRESS_0,
            to:       cis1::Receiver::from_account(ACCOUNT_1),
            token_id: TOKEN_ID_WCCD,
            amount:   100,
            data:     AdditionalData::empty(),
        };
        let parameter = TransferParams::from(vec![transfer]);
        let parameter_bytes = to_bytes(&parameter);
        ctx.set_parameter(&parameter_bytes);

        let mut logger = LogRecorder::init();
        let mut state = initial_state();
        state.add_operator(&ADDRESS_0, &ADDRESS_1);

        // Call the contract function.
        let result: ContractResult<ActionsTree> = contract_transfer(&ctx, &mut logger, &mut state);

        // Check the result.
        let actions: ActionsTree = result.expect_report("Results in rejection");
        claim_eq!(actions, ActionsTree::accept(), "No action should be produced.");

        // Check the state.
        let balance0 =
            state.balance(&TOKEN_ID_WCCD, &ADDRESS_0).expect_report("Token is expected to exist");
        let balance1 =
            state.balance(&TOKEN_ID_WCCD, &ADDRESS_1).expect_report("Token is expected to exist");
        claim_eq!(balance0, 300); //, "Token owner balance should be decreased by the transferred amount");
        claim_eq!(
            balance1,
            100,
            "Token receiver balance should be increased by the transferred amount"
        );

        // Check the logs.
        claim_eq!(logger.logs.len(), 1, "Only one event should be logged");
        claim_eq!(
            logger.logs[0],
            to_bytes(&Cis1Event::Transfer(TransferEvent {
                from:     ADDRESS_0,
                to:       ADDRESS_1,
                token_id: TOKEN_ID_WCCD,
                amount:   100,
            })),
            "Incorrect event emitted"
        )
    }

    /// Test adding an operator succeeds and the appropriate event is logged.
    #[concordium_test]
    fn test_add_operator() {
        // Setup the context
        let mut ctx = ReceiveContextTest::empty();
        ctx.set_sender(ADDRESS_0);

        // and parameter.
        let update = UpdateOperator {
            operator: ADDRESS_1,
            update:   OperatorUpdate::Add,
        };
        let parameter = UpdateOperatorParams(vec![update]);
        let parameter_bytes = to_bytes(&parameter);
        ctx.set_parameter(&parameter_bytes);

        let mut logger = LogRecorder::init();
        let mut state = initial_state();

        // Call the contract function.
        let result: ContractResult<ActionsTree> =
            contract_update_operator(&ctx, &mut logger, &mut state);

        // Check the result.
        let actions: ActionsTree = result.expect_report("Results in rejection");
        claim_eq!(actions, ActionsTree::accept(), "No action should be produced.");

        // Check the state.
        claim!(state.is_operator(&ADDRESS_1, &ADDRESS_0), "Account should be an operator");

        // Check the logs.
        claim_eq!(logger.logs.len(), 1, "One event should be logged");
        claim_eq!(
            logger.logs[0],
            to_bytes(&Cis1Event::<ContractTokenId>::UpdateOperator(UpdateOperatorEvent {
                owner:    ADDRESS_0,
                operator: ADDRESS_1,
                update:   OperatorUpdate::Add,
            })),
            "Incorrect event emitted"
        )
    }
}
#+end_src

** Generation of backend output

#+begin_src elisp :var SOURCE-CODE-FILE="Hacspec_Wccd.v" :results output silent :tangle no
(org-babel-detangle SOURCE-CODE-FILE)
#+end_src

*** wccd - Coq code
:PROPERTIES:
:header-args: coq :tangle Hacspec_Wccd.v :mkdirp yes :comments link
:header-args: coq :eval never :results output silent
:END:

#+begin_src coq

(** This file was automatically generated using Hacspec **)
Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
From Coq Require Import List.
Import ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.

From ConCert.Utils Require Import Extras.
From ConCert.Utils Require Import Automation.
From ConCert.Execution Require Import Serializable.
From ConCert.Execution Require Import Blockchain.
From ConCert.Execution Require Import ContractCommon.
From Coq Require Import Morphisms ZArith Basics.
Open Scope Z.
Set Nonrecursive Elimination Schemes.
#+end_src

#+begin_src coq
Require Import Hacspec_Lib.
Export Hacspec_Lib.
#+end_src

#+begin_src coq
Require Import Hacspec_Concordium.
Export Hacspec_Concordium.
#+end_src

#+begin_src coq
Require Import Concert_Lib.
Export Concert_Lib.
#+end_src

#+begin_src coq
Definition transfer_event_tag_v : int8 :=
  @repr WORDSIZE8 255.
#+end_src

#+begin_src coq
Definition mint_event_tag_v : int8 :=
  (@repr WORDSIZE8 255) .- (@repr WORDSIZE8 1).
#+end_src

#+begin_src coq
Definition burn_event_tag_v : int8 :=
  (@repr WORDSIZE8 255) .- (@repr WORDSIZE8 2).
#+end_src

#+begin_src coq
Definition update_operator_event_tag_v : int8 :=
  (@repr WORDSIZE8 255) .- (@repr WORDSIZE8 3).
#+end_src

#+begin_src coq
Definition token_metadata_event_tag_v : int8 :=
  (@repr WORDSIZE8 255) .- (@repr WORDSIZE8 4).
#+end_src

#+begin_src coq
Definition sha256_t := nseq (int8) (usize 32).
#+end_src

#+begin_src coq
Inductive metadata_url_t :=
| MetadataUrl : (string_t ∏ (option sha256_t)) -> metadata_url_t.
Global Instance serializable_metadata_url_t : Serializable metadata_url_t :=
  Derive Serializable metadata_url_t_rect<MetadataUrl>.
#+end_src

#+begin_src coq
Inductive token_id_vec_t :=
| TokenIdVec : public_byte_seq -> token_id_vec_t.
Global Instance serializable_token_id_vec_t : Serializable token_id_vec_t :=
  Derive Serializable token_id_vec_t_rect<TokenIdVec>.
#+end_src

#+begin_src coq
Inductive token_id_uint32_t :=
| TokenIdU32 : int32 -> token_id_uint32_t.
Global Instance serializable_token_id_uint32_t : Serializable token_id_uint32_t :=
  Derive Serializable token_id_uint32_t_rect<TokenIdU32>.
#+end_src

#+begin_src coq
Inductive token_id_uint16_t :=
| TokenIdU16 : int16 -> token_id_uint16_t.
Global Instance serializable_token_id_uint16_t : Serializable token_id_uint16_t :=
  Derive Serializable token_id_uint16_t_rect<TokenIdU16>.
#+end_src

#+begin_src coq
Inductive token_id_uint8_t :=
| TokenIdU8 : int8 -> token_id_uint8_t.
Global Instance serializable_token_id_uint8_t : Serializable token_id_uint8_t :=
  Derive Serializable token_id_uint8_t_rect<TokenIdU8>.
#+end_src

#+begin_src coq
Inductive token_id_unit_t :=
| TokenIdUnit : unit -> token_id_unit_t.
Global Instance serializable_token_id_unit_t : Serializable token_id_unit_t :=
  Derive Serializable token_id_unit_t_rect<TokenIdUnit>.
#+end_src

#+begin_src coq
Notation "'token_amount_t'" := (int64) : hacspec_scope.
#+end_src

#+begin_src coq
Inductive operator_update_t :=
| Remove : operator_update_t
| Add : operator_update_t.
Global Instance serializable_operator_update_t : Serializable operator_update_t :=
  Derive Serializable operator_update_t_rect<Remove,Add>.
#+end_src

#+begin_src coq
Inductive update_operator_event_t :=
| UpdateOperatorEvent : (operator_update_t ∏ user_address_t ∏ user_address_t
) -> update_operator_event_t.
Global Instance serializable_update_operator_event_t : Serializable update_operator_event_t :=
  Derive Serializable update_operator_event_t_rect<UpdateOperatorEvent>.
#+end_src

#+begin_src coq
Notation "'contract_token_id_t'" := (token_id_unit_t) : hacspec_scope.
#+end_src

#+begin_src coq
Definition token_id_wccd_v : contract_token_id_t :=
  TokenIdUnit (tt).
#+end_src

#+begin_src coq
Inductive state_hacspec_t :=
| StateHacspec : public_byte_seq -> state_hacspec_t.
Global Instance serializable_state_hacspec_t : Serializable state_hacspec_t :=
  Derive Serializable state_hacspec_t_rect<StateHacspec>.
Definition State := context_t ∏ state_hacspec_t.
#+end_src

#+begin_src coq
Definition contract_init (ctx_0 : context_t): (context_t ∏ state_hacspec_t) :=
  (ctx_0, StateHacspec (seq_new_ (default) (usize 0))).
Definition Setup := unit.
Definition CIS1_wCCD_State (chain : Chain) (ctx : ContractCallContext) (setup : Setup) : option (
  context_t ∏
  state_hacspec_t
) :=
  Some (contract_init (Context (ctx.(ctx_from), ctx.(ctx_origin), repr ctx.(ctx_amount), 0 (* TODO *)))).
#+end_src

#+begin_src coq
Definition contract_wrap
  (ctx_1 : (context_t ∏ state_hacspec_t))
  (amount_2 : int64): (option ((context_t ∏ state_hacspec_t) ∏ list_action_t
    )) :=
  let '(Context ((owner_3, sender_4, balance_5, time_6)), state_7) :=
    ctx_1 in 
  let s_8 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some ((context_t ∏ state_hacspec_t) ∏ list_action_t) ((
      (Context ((owner_3, sender_4, balance_5, time_6)), state_7),
      s_8
    )).

Definition wrap (amount : int64) (st : State) :=
  contract_wrap st amount.
#+end_src

#+begin_src coq
Definition contract_unwrap
  (ctx_9 : (context_t ∏ state_hacspec_t)): (option (
      (context_t ∏ state_hacspec_t) ∏
      list_action_t
    )) :=
  let '(Context ((owner_10, sender_11, balance_12, time_13)), state_14) :=
    ctx_9 in 
  let s_15 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some ((context_t ∏ state_hacspec_t) ∏ list_action_t) ((
      (Context ((owner_10, sender_11, balance_12, time_13)), state_14),
      s_15
    )).

Definition unwrap (st : State) :=
  contract_unwrap st.
#+end_src

#+begin_src coq
Definition contract_transfer
  (ctx_16 : (context_t ∏ state_hacspec_t)): (option (
      (context_t ∏ state_hacspec_t) ∏
      list_action_t
    )) :=
  let '(Context ((owner_17, sender_18, balance_19, time_20)), state_21) :=
    ctx_16 in 
  let s_22 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some ((context_t ∏ state_hacspec_t) ∏ list_action_t) ((
      (Context ((owner_17, sender_18, balance_19, time_20)), state_21),
      s_22
    )).

Definition transfer (st : State) :=
  contract_transfer st.
#+end_src

#+begin_src coq
Definition contract_update_operator
  (ctx_23 : (context_t ∏ state_hacspec_t)): (option (
      (context_t ∏ state_hacspec_t) ∏
      list_action_t
    )) :=
  let '(Context ((owner_24, sender_25, balance_26, time_27)), state_28) :=
    ctx_23 in 
  let s_29 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some ((context_t ∏ state_hacspec_t) ∏ list_action_t) ((
      (Context ((owner_24, sender_25, balance_26, time_27)), state_28),
      s_29
    )).

Definition updateOperator (st : State) :=
  contract_update_operator st.
#+end_src

#+begin_src coq
Definition contract_balance_of
  (ctx_30 : (context_t ∏ state_hacspec_t)): (option (
      (context_t ∏ state_hacspec_t) ∏
      list_action_t
    )) :=
  let '(Context ((owner_31, sender_32, balance_33, time_34)), state_35) :=
    ctx_30 in 
  let s_36 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some ((context_t ∏ state_hacspec_t) ∏ list_action_t) ((
      (Context ((owner_31, sender_32, balance_33, time_34)), state_35),
      s_36
    )).

Definition balanceOf (st : State) :=
  contract_balance_of st.
#+end_src

#+begin_src coq
Definition contract_operator_of
  (ctx_37 : (context_t ∏ state_hacspec_t)): (option (
      (context_t ∏ state_hacspec_t) ∏
      list_action_t
    )) :=
  let '(Context ((owner_38, sender_39, balance_40, time_41)), state_42) :=
    ctx_37 in 
  let s_43 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some ((context_t ∏ state_hacspec_t) ∏ list_action_t) ((
      (Context ((owner_38, sender_39, balance_40, time_41)), state_42),
      s_43
    )).

Definition operatorOf (st : State) :=
  contract_operator_of st.
#+end_src

#+begin_src coq
Definition contract_token_metadata
  (ctx_44 : (context_t ∏ state_hacspec_t)): (option (
      (context_t ∏ state_hacspec_t) ∏
      list_action_t
    )) :=
  let '(Context ((owner_45, sender_46, balance_47, time_48)), state_49) :=
    ctx_44 in 
  let s_50 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some ((context_t ∏ state_hacspec_t) ∏ list_action_t) ((
      (Context ((owner_45, sender_46, balance_47, time_48)), state_49),
      s_50
    )).

Definition tokenMetadata (st : State) :=
  contract_token_metadata st.
#+end_src

#+begin_src coq
Inductive Msg :=
| WRAP
| UNWRAP
| TRANSFER
| UPDATEOPERATOR
| BALANCEOF
| OPERATOROF
| TOKENMETADATA.
Global Instance Msg_serializable : Serializable Msg :=
  Derive Serializable Msg_rect<WRAP,UNWRAP,TRANSFER,UPDATEOPERATOR,BALANCEOF,OPERATOROF,TOKENMETADATA>.
Definition CIS1_wCCD_receive (chain : Chain) (ctx : ContractCallContext) (state : State) (msg : option Msg) : option (State * list ActionBody) :=
  match msg with
  | Some WRAP => to_action_body_list ctx (wrap (repr ctx.(ctx_amount)) state)
  | Some UNWRAP => to_action_body_list ctx (unwrap state)
  | Some TRANSFER => to_action_body_list ctx (transfer state)
  | Some UPDATEOPERATOR => to_action_body_list ctx (updateOperator state)
  | Some BALANCEOF => to_action_body_list ctx (balanceOf state)
  | Some OPERATOROF => to_action_body_list ctx (operatorOf state)
  | Some TOKENMETADATA => to_action_body_list ctx (tokenMetadata state)
  | None => None
  end.

Definition CIS1_wCCD_contract : Contract Setup Msg State :=
  build_contract CIS1_wCCD_State CIS1_wCCD_receive.
#+end_src
# 31 code sections
