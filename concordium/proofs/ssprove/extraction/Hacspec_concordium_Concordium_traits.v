(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Crate.
Export Crate.

Class t_HasParameter (Self : choice_type) := {
  f_size_loc : {fset Location} ;
  f_size : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_size_loc) I1 (int32) ;
}.
Hint Unfold f_size_loc.

Class t_HasChainMetadata (Self : choice_type) := {
  f_slot_time_loc : {fset Location} ;
  f_slot_time : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_slot_time_loc) I1 (t_Timestamp) ;
}.
Hint Unfold f_slot_time_loc.

Class t_HasPolicy (Self : choice_type) := {
  f_identity_provider_loc : {fset Location} ;
  f_identity_provider : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_identity_provider_loc) I1 (int32) ;
  f_created_at_loc : {fset Location} ;
  f_created_at : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_created_at_loc) I1 (t_Timestamp) ;
  f_valid_to_loc : {fset Location} ;
  f_valid_to : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_valid_to_loc) I1 (t_Timestamp) ;
  f_next_item_loc : {fset Location} ;
  f_next_item : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (nseq int8 31) -> both (L1 :|: L2 :|: f_next_item_loc) (I1 :|: I2) ((t_Option ((t_AttributeTag × int8)) × nseq int8 31 × v_Self)) ;
}.
Hint Unfold f_identity_provider_loc.
Hint Unfold f_created_at_loc.
Hint Unfold f_valid_to_loc.
Hint Unfold f_next_item_loc.

Class t_HasCommonData (Self : choice_type) := {
  f_PolicyType : choice_type ;
  f_PolicyType_t_HasPolicy :> t_HasPolicy (f_PolicyType) ;
  f_PolicyType_t_Sized :> t_Sized (f_PolicyType) ;
  f_MetadataType : choice_type ;
  f_MetadataType_t_HasChainMetadata :> t_HasChainMetadata (f_MetadataType) ;
  f_MetadataType_t_Sized :> t_Sized (f_MetadataType) ;
  f_ParamType : choice_type ;
  f_ParamType_t_Read :> t_Read (f_ParamType) ;
  f_ParamType_t_HasParameter :> t_HasParameter (f_ParamType) ;
  f_ParamType_t_Sized :> t_Sized (f_ParamType) ;
  f_PolicyIteratorType : choice_type ;
  f_PolicyIteratorType_t_ExactSizeIterator :> t_ExactSizeIterator (f_PolicyIteratorType) ;
  f_PolicyIteratorType_t_Iterator :> t_Iterator (f_PolicyIteratorType) ;
  f_PolicyIteratorType_t_Sized :> t_Sized (f_PolicyIteratorType) ;
  f_policies_loc : {fset Location} ;
  f_policies : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_policies_loc) I1 (f_PolicyIteratorType) ;
  f_metadata_loc : {fset Location} ;
  f_metadata : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_metadata_loc) I1 (f_MetadataType) ;
  f_parameter_cursor_loc : {fset Location} ;
  f_parameter_cursor : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_parameter_cursor_loc) I1 (f_ParamType) ;
}.
Hint Unfold f_policies_loc.
Hint Unfold f_metadata_loc.
Hint Unfold f_parameter_cursor_loc.

Class t_HasInitContext (Self : choice_type) := {
  f_InitData : choice_type ;
  f_InitData_t_Sized :> t_Sized (f_InitData) ;
  f_open_loc : {fset Location} ;
  f_open : forall {L1 I1}, both L1 I1 (f_InitData) -> both (L1 :|: f_open_loc) I1 (v_Self) ;
  f_init_origin_loc : {fset Location} ;
  f_init_origin : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_init_origin_loc) I1 (t_AccountAddress) ;
}.
Hint Unfold f_open_loc.
Hint Unfold f_init_origin_loc.

Class t_HasReceiveContext (Self : choice_type) := {
  f_ReceiveData : choice_type ;
  f_ReceiveData_t_Sized :> t_Sized (f_ReceiveData) ;
  f_open_loc : {fset Location} ;
  f_open : forall {L1 I1}, both L1 I1 (f_ReceiveData) -> both (L1 :|: f_open_loc) I1 (v_Self) ;
  f_invoker_loc : {fset Location} ;
  f_invoker : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_invoker_loc) I1 (t_AccountAddress) ;
  f_self_address_loc : {fset Location} ;
  f_self_address : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_self_address_loc) I1 (t_ContractAddress) ;
  f_self_balance_loc : {fset Location} ;
  f_self_balance : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_self_balance_loc) I1 (t_Amount) ;
  f_sender_loc : {fset Location} ;
  f_sender : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_sender_loc) I1 (t_Address) ;
  f_owner_loc : {fset Location} ;
  f_owner : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_owner_loc) I1 (t_AccountAddress) ;
}.
Hint Unfold f_open_loc.
Hint Unfold f_invoker_loc.
Hint Unfold f_self_address_loc.
Hint Unfold f_self_balance_loc.
Hint Unfold f_sender_loc.
Hint Unfold f_owner_loc.

Class t_HasContractState (Self : choice_type) := {
  f_ContractStateData : choice_type ;
  f_ContractStateData_t_Sized :> t_Sized (f_ContractStateData) ;
  f_open_loc : {fset Location} ;
  f_open : forall {L1 I1}, both L1 I1 (f_ContractStateData) -> both (L1 :|: f_open_loc) I1 (v_Self) ;
  f_size_loc : {fset Location} ;
  f_size : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_size_loc) I1 (int32) ;
  f_truncate_loc : {fset Location} ;
  f_truncate : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (int32) -> both (L1 :|: L2 :|: f_truncate_loc) (I1 :|: I2) (v_Self) ;
  f_reserve_loc : {fset Location} ;
  f_reserve : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (int32) -> both (L1 :|: L2 :|: f_reserve_loc) (I1 :|: I2) (('bool × v_Self)) ;
}.
Hint Unfold f_open_loc.
Hint Unfold f_size_loc.
Hint Unfold f_truncate_loc.
Hint Unfold f_reserve_loc.

Class t_HasLogger (Self : choice_type) := {
  f_init_loc : {fset Location} ;
  f_init : forall {L1 I1}, both (L1 :|: f_init_loc) I1 (v_Self) ;
  f_log_raw_loc : {fset Location} ;
  f_log_raw : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (seq int8) -> both (L1 :|: L2 :|: f_log_raw_loc) (I1 :|: I2) ((t_Result ('unit) (t_LogError) × v_Self)) ;
  f_log_loc : {fset Location} ;
  f_log : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (v_S) -> both (L1 :|: L2 :|: f_log_loc) (I1 :|: I2) ((t_Result ('unit) (t_LogError) × v_Self)) ;
}.
Hint Unfold f_init_loc.
Hint Unfold f_log_raw_loc.
Hint Unfold f_log_loc.

Class t_HasActions (Self : choice_type) := {
  f_accept_loc : {fset Location} ;
  f_accept : forall {L1 I1}, both (L1 :|: f_accept_loc) I1 (v_Self) ;
  f_simple_transfer_loc : {fset Location} ;
  f_simple_transfer : forall {L1 L2 I1 I2}, both L1 I1 (t_AccountAddress) -> both L2 I2 (t_Amount) -> both (L1 :|: L2 :|: f_simple_transfer_loc) (I1 :|: I2) (v_Self) ;
  f_send_raw_loc : {fset Location} ;
  f_send_raw : forall {L1 L2 L3 L4 I1 I2 I3 I4}, both L1 I1 (t_ContractAddress) -> both L2 I2 (t_ReceiveName) -> both L3 I3 (t_Amount) -> both L4 I4 (seq int8) -> both (L1 :|: L2 :|: L3 :|: L4 :|: f_send_raw_loc) (I1 :|: I2 :|: I3 :|: I4) (v_Self) ;
  f_and_then_loc : {fset Location} ;
  f_and_then : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (v_Self) -> both (L1 :|: L2 :|: f_and_then_loc) (I1 :|: I2) (v_Self) ;
  f_or_else_loc : {fset Location} ;
  f_or_else : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (v_Self) -> both (L1 :|: L2 :|: f_or_else_loc) (I1 :|: I2) (v_Self) ;
}.
Hint Unfold f_accept_loc.
Hint Unfold f_simple_transfer_loc.
Hint Unfold f_send_raw_loc.
Hint Unfold f_and_then_loc.
Hint Unfold f_or_else_loc.

Class t_UnwrapAbort (Self : choice_type) := {
  f_Unwrap : choice_type ;
  f_Unwrap_t_Sized :> t_Sized (f_Unwrap) ;
  f_unwrap_abort_loc : {fset Location} ;
  f_unwrap_abort : forall {L1 I1}, both L1 I1 (v_Self) -> both (L1 :|: f_unwrap_abort_loc) I1 (f_Unwrap) ;
}.
Hint Unfold f_unwrap_abort_loc.

Class t_ExpectReport (Self : choice_type) := {
  f_Unwrap : choice_type ;
  f_Unwrap_t_Sized :> t_Sized (f_Unwrap) ;
  f_expect_report_loc : {fset Location} ;
  f_expect_report : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (chString) -> both (L1 :|: L2 :|: f_expect_report_loc) (I1 :|: I2) (f_Unwrap) ;
}.
Hint Unfold f_expect_report_loc.

Class t_ExpectErrReport (Self : choice_type) := {
  f_Unwrap : choice_type ;
  f_Unwrap_t_Sized :> t_Sized (f_Unwrap) ;
  f_expect_err_report_loc : {fset Location} ;
  f_expect_err_report : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (chString) -> both (L1 :|: L2 :|: f_expect_err_report_loc) (I1 :|: I2) (f_Unwrap) ;
}.
Hint Unfold f_expect_err_report_loc.

Class t_ExpectNoneReport (Self : choice_type) := {
  f_expect_none_report_loc : {fset Location} ;
  f_expect_none_report : forall {L1 L2 I1 I2}, both L1 I1 (v_Self) -> both L2 I2 (chString) -> both (L1 :|: L2 :|: f_expect_none_report_loc) (I1 :|: I2) ('unit) ;
}.
Hint Unfold f_expect_none_report_loc.

Class t_SerialCtx (Self : choice_type) := {
  f_serial_ctx_loc : {fset Location} ;
  f_serial_ctx : forall {L1 L2 L3 I1 I2 I3}, both L1 I1 (v_Self) -> both L2 I2 (t_SizeLength) -> both L3 I3 (v_W) -> both (L1 :|: L2 :|: L3 :|: f_serial_ctx_loc) (I1 :|: I2 :|: I3) ((t_Result ('unit) (f_Err) × v_W)) ;
}.
Hint Unfold f_serial_ctx_loc.

Class t_DeserialCtx (Self : choice_type) := {
  f_deserial_ctx_loc : {fset Location} ;
  f_deserial_ctx : forall {L1 L2 L3 I1 I2 I3}, both L1 I1 (t_SizeLength) -> both L2 I2 ('bool) -> both L3 I3 (v_R) -> both (L1 :|: L2 :|: L3 :|: f_deserial_ctx_loc) (I1 :|: I2 :|: I3) ((t_Result (v_Self) (t_ParseError) × v_R)) ;
}.
Hint Unfold f_deserial_ctx_loc.
