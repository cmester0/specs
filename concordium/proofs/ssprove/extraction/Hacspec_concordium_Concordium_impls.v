(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Crate.
Export Crate.

Require Import Crate_Convert.
Export Crate_Convert.

Require Import convert.
Export convert.

Require Import NonZeroI32.
Export NonZeroI32.

Require Import trap.
Export trap.

Require Import Vec.
Export Vec.

Require Import Crate.
Export Crate.

Require Import Concordium_prims.
Export Concordium_prims.

Require Import Concordium_types.
Export Concordium_types.

Require Import Concordium_traits.
Export Concordium_traits.

Equations reject_impl_convert_from_unit {L : {fset Location}} {I : Interface} : both L I (t_Reject) :=
  reject_impl_convert_from_unit  :=
    solve_lift (Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (1 : int32))))) : both L I (t_Reject).
Fail Next Obligation.

Equations reject_impl_convert_from_parse_error {L : {fset Location}} {I : Interface} : both L I (t_Reject) :=
  reject_impl_convert_from_parse_error  :=
    solve_lift (Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (2 : int32))))) : both L I (t_Reject).
Fail Next Obligation.

#[global] Program Instance t_Reject_t_From : t_From t_Reject 'unit :=
  let from := fun  {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 ('unit)) => solve_lift reject_impl_convert_from_unit : both L1 I1 (t_Reject) in
  {| from_loc := (fset [] : {fset Location});
  from := (@from)|}.
Fail Next Obligation.

#[global] Program Instance t_Reject_t_From : t_From t_Reject t_ParseError :=
  let from := fun  {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 (t_ParseError)) => solve_lift reject_impl_convert_from_parse_error : both L1 I1 (t_Reject) in
  {| from_loc := (fset [] : {fset Location});
  from := (@from)|}.
Fail Next Obligation.

Equations reject_impl_from_log_error {L1 : {fset Location}} {I1 : Interface} (le : both L1 I1 (t_LogError)) : both L1 I1 (t_Reject) :=
  reject_impl_from_log_error le  :=
    solve_lift matchb le with
    | LogError_Full  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (3 : int32))))
    | LogError_Malformed  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (4 : int32))))
    end : both L1 I1 (t_Reject).
Fail Next Obligation.

#[global] Program Instance t_Reject_t_From : t_From t_Reject t_LogError :=
  let from := fun  {L1 : {fset Location}} {I1 : Interface} (le : both L1 I1 (t_LogError)) => solve_lift (reject_impl_from_log_error le) : both L1 I1 (t_Reject) in
  {| from_loc := (fset [] : {fset Location});
  from := (@from)|}.
Fail Next Obligation.

Definition t_NewContractNameError : choice_type :=
  chFin (mkpos 4).
Equations NewContractNameError_NewContractNameErrorMissingInitPrefix {L : {fset Location}} {I : Interface} : both L I t_NewContractNameError :=
  NewContractNameError_NewContractNameErrorMissingInitPrefix  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=0) eq_refl : t_NewContractNameError) : both L I t_NewContractNameError.
Fail Next Obligation.
Equations NewContractNameError_NewContractNameErrorTooLong {L : {fset Location}} {I : Interface} : both L I t_NewContractNameError :=
  NewContractNameError_NewContractNameErrorTooLong  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=1) eq_refl : t_NewContractNameError) : both L I t_NewContractNameError.
Fail Next Obligation.
Equations NewContractNameError_NewContractNameErrorContainsDot {L : {fset Location}} {I : Interface} : both L I t_NewContractNameError :=
  NewContractNameError_NewContractNameErrorContainsDot  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=2) eq_refl : t_NewContractNameError) : both L I t_NewContractNameError.
Fail Next Obligation.
Equations NewContractNameError_NewContractNameErrorInvalidCharacters {L : {fset Location}} {I : Interface} : both L I t_NewContractNameError :=
  NewContractNameError_NewContractNameErrorInvalidCharacters  :=
    solve_lift ret_both (fintype.Ordinal (n:=4) (m:=3) eq_refl : t_NewContractNameError) : both L I t_NewContractNameError.
Fail Next Obligation.

Equations reject_impl_from_new_contract_name_error {L1 : {fset Location}} {I1 : Interface} (nre : both L1 I1 (t_NewContractNameError)) : both L1 I1 (t_Reject) :=
  reject_impl_from_new_contract_name_error nre  :=
    solve_lift matchb nre with
    | NewContractNameError_NewContractNameErrorMissingInitPrefix  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (5 : int32))))
    | NewContractNameError_NewContractNameErrorTooLong  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (6 : int32))))
    | NewContractNameError_NewContractNameErrorContainsDot  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (9 : int32))))
    | NewContractNameError_NewContractNameErrorInvalidCharacters  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (10 : int32))))
    end : both L1 I1 (t_Reject).
Fail Next Obligation.

#[global] Program Instance t_Reject_t_From : t_From t_Reject t_NewContractNameError :=
  let from := fun  {L1 : {fset Location}} {I1 : Interface} (nre : both L1 I1 (t_NewContractNameError)) => solve_lift (reject_impl_from_new_contract_name_error nre) : both L1 I1 (t_Reject) in
  {| from_loc := (fset [] : {fset Location});
  from := (@from)|}.
Fail Next Obligation.

Definition t_NewReceiveNameError : choice_type :=
  chFin (mkpos 3).
Equations NewReceiveNameError_NewReceiveNameErrorMissingDotSeparator {L : {fset Location}} {I : Interface} : both L I t_NewReceiveNameError :=
  NewReceiveNameError_NewReceiveNameErrorMissingDotSeparator  :=
    solve_lift ret_both (fintype.Ordinal (n:=3) (m:=0) eq_refl : t_NewReceiveNameError) : both L I t_NewReceiveNameError.
Fail Next Obligation.
Equations NewReceiveNameError_NewReceiveNameErrorTooLong {L : {fset Location}} {I : Interface} : both L I t_NewReceiveNameError :=
  NewReceiveNameError_NewReceiveNameErrorTooLong  :=
    solve_lift ret_both (fintype.Ordinal (n:=3) (m:=1) eq_refl : t_NewReceiveNameError) : both L I t_NewReceiveNameError.
Fail Next Obligation.
Equations NewReceiveNameError_NewReceiveNameErrorInvalidCharacters {L : {fset Location}} {I : Interface} : both L I t_NewReceiveNameError :=
  NewReceiveNameError_NewReceiveNameErrorInvalidCharacters  :=
    solve_lift ret_both (fintype.Ordinal (n:=3) (m:=2) eq_refl : t_NewReceiveNameError) : both L I t_NewReceiveNameError.
Fail Next Obligation.

Equations reject_impl_from_new_receive_name_error {L1 : {fset Location}} {I1 : Interface} (nre : both L1 I1 (t_NewReceiveNameError)) : both L1 I1 (t_Reject) :=
  reject_impl_from_new_receive_name_error nre  :=
    solve_lift matchb nre with
    | NewReceiveNameError_NewReceiveNameErrorMissingDotSeparator  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (7 : int32))))
    | NewReceiveNameError_NewReceiveNameErrorTooLong  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (8 : int32))))
    | NewReceiveNameError_NewReceiveNameErrorInvalidCharacters  =>
      Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (11 : int32))))
    end : both L1 I1 (t_Reject).
Fail Next Obligation.

#[global] Program Instance t_Reject_t_From : t_From t_Reject t_NewReceiveNameError :=
  let from := fun  {L1 : {fset Location}} {I1 : Interface} (nre : both L1 I1 (t_NewReceiveNameError)) => solve_lift (reject_impl_from_new_receive_name_error nre) : both L1 I1 (t_Reject) in
  {| from_loc := (fset [] : {fset Location});
  from := (@from)|}.
Fail Next Obligation.

Equations reject_impl_from_not_payable_error {L : {fset Location}} {I : Interface} : both L I (t_Reject) :=
  reject_impl_from_not_payable_error  :=
    solve_lift (Build_Reject (f_error_code := non_zero_i32 (v_MIN_under_impl_2 .+ (ret_both (12 : int32))))) : both L I (t_Reject).
Fail Next Obligation.

#[global] Program Instance t_Reject_t_From : t_From t_Reject t_NotPayableError :=
  let from := fun  {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 (t_NotPayableError)) => solve_lift reject_impl_from_not_payable_error : both L1 I1 (t_Reject) in
  {| from_loc := (fset [] : {fset Location});
  from := (@from)|}.
Fail Next Obligation.
