(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Crypt Require Import jasmin_word.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Group.
Export Group.

Require Import Group_Ff.
Export Group_Ff.

Require Import Field.
Export Field.

Require Import Group.
Export Group.

Require Import Gt.
Export Gt.

Require Import PhantomData.
Export PhantomData.

Notation "'t_G'" := t_Gt.

(*item error backend*)

Equations compute_group_element_for_vote {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (xi : both L1 I1 t_Scalar) (vote : both L2 I2 'bool) (g_pow_yi : both L3 I3 t_Gt) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) t_Gt :=
  compute_group_element_for_vote xi vote g_pow_yi  :=
    solve_lift ((g_pow_yi .* xi) .+ ((f_generator (ret_both (tt : 'unit))) .* (ifb vote
    then f_ONE
    else f_ZERO))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) t_Gt.
Fail Next Obligation.

Equations hash {L1 : {fset Location}} {I1 : Interface} (v__inp : both L1 I1 (t_Vec t_Gt t_Global)) : both L1 I1 t_Scalar :=
  hash v__inp  :=
    solve_lift (impl__Scalar__one (ret_both (tt : 'unit))) : both L1 I1 t_Scalar.
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

Definition t_TallyParameter : choice_type :=
  'unit.
Equations Build_t_TallyParameter : both (fset []) (fset []) (t_TallyParameter) :=
  Build_t_TallyParameter  :=
    solve_lift (ret_both (tt (* Empty tuple *) : (t_TallyParameter))) : both (fset []) (fset []) (t_TallyParameter).
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

Equations init_ovn_contract {L1 : {fset Location}} {I1 : Interface} {n : both (fset []) (fset []) uint_size} (_ : both L1 I1 'unit) : both L1 I1 (t_Result (t_OvnContractState (both (fset []) (fset []) uint_size)) t_Reject) :=
  init_ovn_contract _  :=
    Result_Ok (solve_lift (Build_t_OvnContractState (f_g_pow_xis := repeat (f_identity (ret_both (tt : 'unit))) n) (f_zkp_xis := repeat (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_identity (ret_both (tt : 'unit))) (f_schnorr_zkp_z := f_ZERO) (f_schnorr_zkp_c := f_ZERO)) n) (f_commit_vis := repeat f_ZERO n) (f_g_pow_xi_yi_vis := repeat (f_identity (ret_both (tt : 'unit))) n) (f_zkp_vis := repeat (Build_t_OrZKPCommit (f_or_zkp_x := f_identity (ret_both (tt : 'unit))) (f_or_zkp_y := f_identity (ret_both (tt : 'unit))) (f_or_zkp_a1 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_b1 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_a2 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_b2 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_c := f_ZERO) (f_or_zkp_d1 := f_ZERO) (f_or_zkp_d2 := f_ZERO) (f_or_zkp_r1 := f_ZERO) (f_or_zkp_r2 := f_ZERO)) n) (f_tally := ret_both (0 : int32)))) : both L1 I1 (t_Result (t_OvnContractState (both (fset []) (fset []) uint_size)) t_Reject).
Fail Next Obligation.

(*item error backend*)

(*item error backend*)
