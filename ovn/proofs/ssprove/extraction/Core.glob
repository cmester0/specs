DIGEST 265cab0b506d10f1ada8bbe5826ce1eb
FExamples.Core
R74:84 Hacspec.Hacspec_Lib <> <> lib
R112:117 Coq.ZArith.ZArith <> <> lib
R127:144 Coq.Lists.List ListNotations <> mod
R206:208 Coq.micromega.Lia <> <> lib
R226:259 Coq.Logic.FunctionalExtensionality <> <> lib
R277:283 Coq.Bool.Sumbool <> <> lib
R316:322 mathcomp.ssreflect.fintype <> <> lib
R352:362 Crypt.choice_type <> <> lib
R364:370 Crypt.Package <> <> lib
R372:378 Crypt.Prelude <> <> lib
R388:402 Crypt.package.pkg_notation PackageNotation <> mod
R437:439 extructures.ord <> <> lib
R441:444 extructures.fset <> <> lib
R446:449 extructures.fmap <> <> lib
R482:485 mathcomp.zify.ssrZ <> <> lib
R487:490 mathcomp.word.word <> <> lib
R520:523 Jasmin.word <> <> lib
R551:556 Coq.ZArith.ZArith <> <> lib
R558:561 Coq.Lists.List <> <> lib
R571:583 Coq.Lists.List ListNotations <> mod
R615:628 Hacspec.ChoiceEquality <> <> lib
R659:673 Hacspec.LocationUtility <> <> lib
R704:725 Hacspec.Hacspec_Lib_Comparable <> <> lib
R756:770 Hacspec.Hacspec_Lib_Pre <> <> lib
R801:811 Hacspec.Hacspec_Lib <> <> lib
R970:990 mathcomp.ssreflect.choice Choice.Exports <> mod
ind 1000:1008 <> t_TryFrom
constr 1031:1037 <> TryFrom
rec 1000:1008 <> t_TryFrom
proj 1031:1037 <> TryFrom
R1015:1025 Crypt.choice_type <> choice_type ind
binder 1011:1011 <> A:1
R1042:1045 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1041:1041 Examples.Core <> A:1 var
R1046:1046 Examples.Core <> A:1 var
ind 1055:1060 <> t_Into
constr 1083:1086 <> Into
rec 1055:1060 <> t_Into
proj 1083:1086 <> Into
R1067:1077 Crypt.choice_type <> choice_type ind
binder 1063:1063 <> A:4
R1091:1094 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1090:1090 Examples.Core <> A:4 var
R1095:1095 Examples.Core <> A:4 var
ind 1104:1114 <> t_PartialEq
constr 1137:1145 <> PartialEq
rec 1104:1114 <> t_PartialEq
proj 1137:1145 <> PartialEq
R1121:1131 Crypt.choice_type <> choice_type ind
binder 1117:1117 <> A:7
R1150:1153 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1149:1149 Examples.Core <> A:7 var
R1154:1154 Examples.Core <> A:7 var
ind 1163:1168 <> t_Copy
constr 1191:1194 <> Copy
rec 1163:1168 <> t_Copy
proj 1191:1194 <> Copy
R1175:1185 Crypt.choice_type <> choice_type ind
binder 1171:1171 <> A:10
R1199:1202 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1198:1198 Examples.Core <> A:10 var
R1203:1203 Examples.Core <> A:10 var
ind 1212:1218 <> t_Clone
constr 1241:1245 <> Clone
rec 1212:1218 <> t_Clone
proj 1241:1245 <> Clone
R1225:1235 Crypt.choice_type <> choice_type ind
binder 1221:1221 <> A:13
R1250:1253 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1249:1249 Examples.Core <> A:13 var
R1254:1254 Examples.Core <> A:13 var
ind 1263:1269 <> t_Sized
constr 1292:1296 <> Sized
rec 1263:1269 <> t_Sized
proj 1292:1296 <> Sized
R1276:1286 Crypt.choice_type <> choice_type ind
binder 1272:1272 <> A:16
R1301:1304 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1300:1300 Examples.Core <> A:16 var
R1305:1305 Examples.Core <> A:16 var
def 1319:1326 <> t_Option
R1341:1344 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1330:1340 Crypt.choice_type <> choice_type ind
R1345:1355 Crypt.choice_type <> choice_type ind
R1360:1367 Crypt.choice_type <> chOption constr
ind 1380:1386 <> vec_typ
constr 1393:1400 <> t_Global
def 1414:1418 <> t_Vec
R1433:1436 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1422:1432 Crypt.choice_type <> choice_type ind
R1444:1447 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1437:1443 Examples.Core <> vec_typ ind
R1448:1458 Crypt.choice_type <> choice_type ind
binder 1467:1467 <> A:21
R1474:1479 Crypt.choice_type <> chList constr
R1481:1481 Examples.Core <> A:21 var
rec 1491:1499 <> t_Default
proj 1508:1514 <> default
binder 1501:1501 <> A:22
R1518:1518 Examples.Core <> A:22 var
inst 1543:1551 <> bool_copy
R1555:1560 Examples.Core <> t_Copy class
R1562:1566 Crypt.package.pkg_notation PackageNotation ::package_scope:'''bool' not
R1572:1575 Examples.Core <> Copy def
binder 1577:1577 <> x:25
R1582:1582 Examples.Core <> x:25 var
inst 1605:1614 <> bool_clone
R1618:1624 Examples.Core <> t_Clone class
R1626:1630 Crypt.package.pkg_notation PackageNotation ::package_scope:'''bool' not
R1636:1640 Examples.Core <> Clone def
binder 1642:1642 <> x:26
R1647:1647 Examples.Core <> x:26 var
inst 1670:1679 <> bool_sized
R1683:1689 Examples.Core <> t_Sized class
R1691:1695 Crypt.package.pkg_notation PackageNotation ::package_scope:'''bool' not
R1701:1705 Examples.Core <> Sized def
binder 1707:1707 <> x:27
R1712:1712 Examples.Core <> x:27 var
def 1728:1732 <> ilog2
binder 1735:1736 <> WS:28
binder 1740:1740 <> L:29
binder 1742:1742 <> I:30
R1750:1753 Hacspec.ChoiceEquality <> both rec
R1760:1762 Hacspec.Hacspec_Lib_Pre <> int syndef
R1764:1765 Examples.Core <> WS:28 var
R1757:1757 Examples.Core <> I:30 var
R1755:1755 Examples.Core <> L:29 var
binder 1746:1746 <> x:31
R1771:1774 Hacspec.ChoiceEquality <> both rec
R1781:1783 Hacspec.Hacspec_Lib_Pre <> int syndef
R1785:1786 Examples.Core <> WS:28 var
R1778:1778 Examples.Core <> I:30 var
R1776:1776 Examples.Core <> L:29 var
R1792:1792 Examples.Core <> x:31 var
def 1818:1824 <> collect
binder 1827:1827 <> A:32
binder 1831:1831 <> L:33
binder 1833:1833 <> I:34
R1841:1844 Hacspec.ChoiceEquality <> both rec
R1851:1856 Crypt.choice_type <> chList constr
R1858:1858 Examples.Core <> A:32 var
R1848:1848 Examples.Core <> I:34 var
R1846:1846 Examples.Core <> L:33 var
binder 1837:1837 <> x:35
R1864:1867 Hacspec.ChoiceEquality <> both rec
R1874:1878 Examples.Core <> t_Vec def
R1880:1880 Examples.Core <> A:32 var
R1882:1889 Examples.Core <> t_Global constr
R1871:1871 Examples.Core <> I:34 var
R1869:1869 Examples.Core <> L:33 var
R1895:1895 Examples.Core <> x:35 var
def 1912:1925 <> swap_both_list
binder 1928:1928 <> A:36
binder 1930:1930 <> L:37
binder 1932:1932 <> I:38
R1940:1943 Coq.Init.Datatypes <> list ind
R1946:1949 Hacspec.ChoiceEquality <> both rec
R1955:1955 Examples.Core <> A:36 var
R1953:1953 Examples.Core <> I:38 var
R1951:1951 Examples.Core <> L:37 var
binder 1936:1936 <> x:39
R1961:1964 Hacspec.ChoiceEquality <> both rec
R1971:1976 Crypt.choice_type <> chList constr
R1986:1999 Examples.Core <> swap_both_list:42 def
R2001:2001 Examples.Core <> x:41 var
R2009:2022 Coq.Lists.List <> fold_left def
R2169:2176 Hacspec.ChoiceEquality <> ret_both def
R2184:2189 Crypt.choice_type <> chList constr
R2179:2180 Coq.Lists.List ListNotations ::list_scope:'['_']' not
R2034:2037 Hacspec.ChoiceEquality <> both rec
R2044:2049 Crypt.choice_type <> chList constr
binder 2030:2030 <> x:43
binder 2055:2055 <> y:44
R2063:2071 Hacspec.ChoiceEquality <> bind_both def
binder 2080:2081 <> x':45
R2089:2097 Hacspec.ChoiceEquality <> bind_both def
binder 2106:2107 <> y':46
R2130:2137 Hacspec.ChoiceEquality <> ret_both def
R2153:2158 Crypt.choice_type <> chList constr
R2143:2146 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R2141:2142 Examples.Core <> y':46 var
R2147:2148 Examples.Core <> x':45 var
R2099:2099 Examples.Core <> y:44 var
R2073:2073 Examples.Core <> x:43 var
def 2284:2293 <> match_list
R2302:2312 Crypt.choice_type <> choice_type ind
binder 2296:2296 <> A:47
binder 2298:2298 <> B:48
binder 2316:2316 <> L:49
binder 2318:2318 <> I:50
R2326:2329 Hacspec.ChoiceEquality <> both rec
R2336:2341 Crypt.choice_type <> chList constr
R2343:2343 Examples.Core <> A:47 var
R2333:2333 Examples.Core <> I:50 var
R2331:2331 Examples.Core <> L:49 var
binder 2322:2322 <> x:51
R2358:2361 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R2352:2355 Coq.Init.Datatypes <> list ind
R2357:2357 Examples.Core <> A:47 var
R2362:2362 Examples.Core <> B:48 var
binder 2348:2348 <> f:52
R2367:2370 Hacspec.ChoiceEquality <> both rec
R2383:2392 Examples.Core <> match_list:56 def
R2396:2396 Examples.Core <> f:54 var
R2394:2394 Examples.Core <> x:55 var
R2403:2411 Hacspec.ChoiceEquality <> bind_both def
binder 2420:2421 <> x':57
R2426:2433 Hacspec.ChoiceEquality <> ret_both def
R2438:2439 Examples.Core <> x':57 var
def 2531:2533 <> map
binder 2536:2536 <> A:58
binder 2538:2538 <> B:59
binder 2542:2542 <> L:60
binder 2544:2544 <> I:61
R2552:2555 Hacspec.ChoiceEquality <> both rec
R2562:2567 Crypt.choice_type <> chList constr
R2569:2569 Examples.Core <> A:58 var
R2559:2559 Examples.Core <> I:61 var
R2557:2557 Examples.Core <> L:60 var
binder 2548:2548 <> x:62
R2589:2592 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R2579:2582 Hacspec.ChoiceEquality <> both rec
R2588:2588 Examples.Core <> A:58 var
R2586:2586 Examples.Core <> I:61 var
R2584:2584 Examples.Core <> L:60 var
R2593:2596 Hacspec.ChoiceEquality <> both rec
R2602:2602 Examples.Core <> B:59 var
R2600:2600 Examples.Core <> I:61 var
R2598:2598 Examples.Core <> L:60 var
binder 2575:2575 <> f:63
R2607:2610 Hacspec.ChoiceEquality <> both rec
R2617:2622 Crypt.choice_type <> chList constr
R2632:2634 Examples.Core <> map:67 def
R2638:2638 Examples.Core <> f:65 var
R2636:2636 Examples.Core <> x:66 var
R2645:2653 Hacspec.ChoiceEquality <> bind_both def
binder 2662:2663 <> x':68
R2668:2681 Examples.Core <> swap_both_list def
R2684:2691 Coq.Lists.List <> map def
R2719:2720 Examples.Core <> x':68 var
binder 2698:2698 <> y:69
R2706:2713 Hacspec.ChoiceEquality <> ret_both def
R2715:2715 Examples.Core <> y:69 var
def 2813:2818 <> cloned
binder 2821:2821 <> A:70
binder 2825:2825 <> L:71
binder 2827:2827 <> I:72
R2835:2838 Hacspec.ChoiceEquality <> both rec
R2845:2850 Crypt.choice_type <> chList constr
R2852:2852 Examples.Core <> A:70 var
R2842:2842 Examples.Core <> I:72 var
R2840:2840 Examples.Core <> L:71 var
binder 2831:2831 <> x:73
R2858:2861 Hacspec.ChoiceEquality <> both rec
R2868:2873 Crypt.choice_type <> chList constr
R2875:2875 Examples.Core <> A:70 var
R2865:2865 Examples.Core <> I:72 var
R2863:2863 Examples.Core <> L:71 var
R2881:2881 Examples.Core <> x:73 var
def 2895:2898 <> iter
binder 2901:2901 <> A:74
binder 2903:2903 <> L:75
binder 2905:2905 <> I:76
R2913:2916 Hacspec.ChoiceEquality <> both rec
R2923:2925 Hacspec.Hacspec_Lib_Pre <> seq def
R2927:2927 Examples.Core <> A:74 var
R2920:2920 Examples.Core <> I:76 var
R2918:2918 Examples.Core <> L:75 var
binder 2909:2909 <> x:77
R2933:2936 Hacspec.ChoiceEquality <> both rec
R2943:2948 Crypt.choice_type <> chList constr
R2958:2961 Examples.Core <> iter:80 def
R2963:2963 Examples.Core <> x:79 var
R2970:2978 Hacspec.ChoiceEquality <> bind_both def
binder 2987:2988 <> x':81
R2993:3000 Hacspec.ChoiceEquality <> ret_both def
R3022:3027 Crypt.choice_type <> chList constr
R3003:3013 Hacspec.Hacspec_Lib_Pre <> seq_to_list def
R3017:3018 Examples.Core <> x':81 var
def 3122:3126 <> dedup
binder 3129:3129 <> A:82
binder 3133:3133 <> L:83
binder 3135:3135 <> I:84
R3143:3146 Hacspec.ChoiceEquality <> both rec
R3153:3157 Examples.Core <> t_Vec def
R3159:3159 Examples.Core <> A:82 var
R3161:3168 Examples.Core <> t_Global constr
R3150:3150 Examples.Core <> I:84 var
R3148:3148 Examples.Core <> L:83 var
binder 3139:3139 <> x:85
R3174:3177 Hacspec.ChoiceEquality <> both rec
R3184:3188 Examples.Core <> t_Vec def
R3190:3190 Examples.Core <> A:82 var
R3192:3199 Examples.Core <> t_Global constr
R3181:3181 Examples.Core <> I:84 var
R3179:3179 Examples.Core <> L:83 var
R3205:3205 Examples.Core <> x:85 var
def 3220:3227 <> t_String
R3232:3256 Coq.Strings.String <> string ind
def 3270:3272 <> new
binder 3275:3275 <> A:86
binder 3277:3277 <> L:87
binder 3279:3279 <> I:88
R3284:3287 Hacspec.ChoiceEquality <> both rec
R3294:3298 Examples.Core <> t_Vec def
R3300:3300 Examples.Core <> A:86 var
R3302:3309 Examples.Core <> t_Global constr
R3291:3291 Examples.Core <> I:88 var
R3289:3289 Examples.Core <> L:87 var
R3315:3322 Hacspec.ChoiceEquality <> ret_both def
R3330:3335 Crypt.choice_type <> chList constr
R3337:3337 Examples.Core <> A:86 var
R3325:3326 Coq.Lists.List ListNotations ::list_scope:'['_']' not
def 3353:3361 <> enumerate
binder 3364:3364 <> A:89
binder 3368:3368 <> L:90
binder 3370:3370 <> I:91
R3378:3381 Hacspec.ChoiceEquality <> both rec
R3388:3392 Examples.Core <> t_Vec def
R3394:3394 Examples.Core <> A:89 var
R3396:3403 Examples.Core <> t_Global constr
R3385:3385 Examples.Core <> I:91 var
R3383:3383 Examples.Core <> L:90 var
binder 3374:3374 <> x:92
R3409:3412 Hacspec.ChoiceEquality <> both rec
R3419:3423 Examples.Core <> t_Vec def
R3425:3425 Examples.Core <> A:89 var
R3427:3434 Examples.Core <> t_Global constr
R3416:3416 Examples.Core <> I:91 var
R3414:3414 Examples.Core <> L:90 var
R3440:3440 Examples.Core <> x:92 var
def 3455:3462 <> t_Result
binder 3464:3464 <> A:93
binder 3466:3466 <> B:94
R3471:3476 Hacspec.Hacspec_Lib_Pre <> result def
R3478:3478 Examples.Core <> B:94 var
R3480:3480 Examples.Core <> A:93 var
ind 3493:3503 <> ControlFlow
constr 3552:3571 <> ControlFlow_Continue
constr 3594:3610 <> ControlFlow_Break
binder 3506:3506 <> L:95
binder 3508:3508 <> I:96
R3516:3526 Crypt.choice_type <> choice_type ind
binder 3512:3512 <> A:97
R3534:3544 Crypt.choice_type <> choice_type ind
binder 3530:3530 <> B:98
R3580:3583 Hacspec.ChoiceEquality <> both rec
R3589:3589 Examples.Core <> A:97 var
R3587:3587 Examples.Core <> I:96 var
R3585:3585 Examples.Core <> L:95 var
binder 3574:3576 <> val:101
R3619:3622 Hacspec.ChoiceEquality <> both rec
R3628:3628 Examples.Core <> B:98 var
R3626:3626 Examples.Core <> I:96 var
R3624:3624 Examples.Core <> L:95 var
binder 3613:3615 <> val:102
def 3644:3646 <> run
R3655:3665 Crypt.choice_type <> choice_type ind
binder 3649:3649 <> A:103
binder 3651:3651 <> B:104
binder 3669:3669 <> L:105
binder 3671:3671 <> I:106
R3679:3689 Examples.Core <> ControlFlow ind
R3693:3693 Examples.Core <> B:104 var
R3691:3691 Examples.Core <> A:103 var
binder 3675:3675 <> x:107
R3698:3701 Hacspec.ChoiceEquality <> both rec
R3708:3715 Examples.Core <> t_Result def
R3717:3717 Examples.Core <> A:103 var
R3719:3719 Examples.Core <> B:104 var
R3705:3705 Examples.Core <> I:106 var
R3703:3703 Examples.Core <> L:105 var
R3733:3733 Examples.Core <> x:107 var
R3744:3763 Examples.Core <> ControlFlow_Continue constr
R3770:3771 Hacspec.Hacspec_Lib <> Ok def
R3779:3795 Examples.Core <> ControlFlow_Break constr
R3802:3804 Hacspec.Hacspec_Lib <> Err def
def 4693:4703 <> t_ErrorKind
R4707:4717 Crypt.choice_type <> choice_type ind
R4722:4726 Crypt.choice_type <> chFin constr
R4729:4733 Crypt.Prelude <> mkpos constr
def 4750:4789 <> ErrorKind_SerializedProofSizeIsIncorrect
binder 4792:4792 <> L:109
binder 4794:4794 <> I:110
R4799:4802 Hacspec.ChoiceEquality <> both rec
R4808:4818 Examples.Core <> t_ErrorKind def
R4806:4806 Examples.Core <> I:110 var
R4804:4804 Examples.Core <> L:109 var
R4823:4830 Hacspec.ChoiceEquality <> ret_both def
R4873:4883 Examples.Core <> t_ErrorKind def
R4833:4847 mathcomp.ssreflect.fintype <> Ordinal constr
R4863:4869 Coq.Init.Logic <> eq_refl constr
def 4898:4927 <> ErrorKind_NotEnoughHelperNodes
binder 4930:4930 <> L:111
binder 4932:4932 <> I:112
R4937:4940 Hacspec.ChoiceEquality <> both rec
R4946:4956 Examples.Core <> t_ErrorKind def
R4944:4944 Examples.Core <> I:112 var
R4942:4942 Examples.Core <> L:111 var
R4961:4968 Hacspec.ChoiceEquality <> ret_both def
R5011:5021 Examples.Core <> t_ErrorKind def
R4971:4985 mathcomp.ssreflect.fintype <> Ordinal constr
R5001:5007 Coq.Init.Logic <> eq_refl constr
def 5036:5064 <> ErrorKind_HashConversionError
binder 5067:5067 <> L:113
binder 5069:5069 <> I:114
R5074:5077 Hacspec.ChoiceEquality <> both rec
R5083:5093 Examples.Core <> t_ErrorKind def
R5081:5081 Examples.Core <> I:114 var
R5079:5079 Examples.Core <> L:113 var
R5098:5105 Hacspec.ChoiceEquality <> ret_both def
R5148:5158 Examples.Core <> t_ErrorKind def
R5108:5122 mathcomp.ssreflect.fintype <> Ordinal constr
R5138:5144 Coq.Init.Logic <> eq_refl constr
def 5173:5212 <> ErrorKind_NotEnoughHashesToCalculateRoot
binder 5215:5215 <> L:115
binder 5217:5217 <> I:116
R5222:5225 Hacspec.ChoiceEquality <> both rec
R5231:5241 Examples.Core <> t_ErrorKind def
R5229:5229 Examples.Core <> I:116 var
R5227:5227 Examples.Core <> L:115 var
R5246:5253 Hacspec.ChoiceEquality <> ret_both def
R5296:5306 Examples.Core <> t_ErrorKind def
R5256:5270 mathcomp.ssreflect.fintype <> Ordinal constr
R5286:5292 Coq.Init.Logic <> eq_refl constr
def 5321:5356 <> ErrorKind_LeavesIndicesCountMismatch
binder 5359:5359 <> L:117
binder 5361:5361 <> I:118
R5366:5369 Hacspec.ChoiceEquality <> both rec
R5375:5385 Examples.Core <> t_ErrorKind def
R5373:5373 Examples.Core <> I:118 var
R5371:5371 Examples.Core <> L:117 var
R5390:5397 Hacspec.ChoiceEquality <> ret_both def
R5440:5450 Examples.Core <> t_ErrorKind def
R5400:5414 mathcomp.ssreflect.fintype <> Ordinal constr
R5430:5436 Coq.Init.Logic <> eq_refl constr
def 5643:5649 <> t_Error
R5653:5663 Crypt.choice_type <> choice_type ind
R5679:5682 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R5668:5678 Examples.Core <> t_ErrorKind def
R5683:5693 Examples.Core <> t_ErrorKind def
def 5735:5745 <> Build_Error
binder 5748:5748 <> L:119
binder 5750:5750 <> I:120
R5764:5767 Hacspec.ChoiceEquality <> both rec
R5773:5783 Examples.Core <> t_ErrorKind def
R5771:5771 Examples.Core <> I:120 var
R5769:5769 Examples.Core <> L:119 var
binder 5754:5760 <> f_kind1:121
R5797:5800 Hacspec.ChoiceEquality <> both rec
R5806:5816 Examples.Core <> t_ErrorKind def
R5804:5804 Examples.Core <> I:120 var
R5802:5802 Examples.Core <> L:119 var
binder 5787:5793 <> f_kind2:122
R5821:5824 Hacspec.ChoiceEquality <> both rec
R5830:5836 Examples.Core <> t_Error def
R5843:5853 Examples.Core <> Build_Error:126 def
R5882:5882 Examples.Core <> y:125 var
R5867:5867 Examples.Core <> x:124 var
R5890:5898 Hacspec.ChoiceEquality <> bind_both def
binder 5907:5908 <> x':127
R5915:5923 Hacspec.ChoiceEquality <> bind_both def
binder 5932:5933 <> y':128
R5955:5962 Hacspec.ChoiceEquality <> ret_both def
R5976:5982 Examples.Core <> t_Error def
R5965:5965 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5968:5969 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5972:5972 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5966:5967 Examples.Core <> x':127 var
R5970:5971 Examples.Core <> y':128 var
def 6075:6081 <> f_kind1
R6088:6094 Examples.Core <> t_Error def
binder 6084:6084 <> v:129
R6100:6102 Coq.Init.Datatypes <> fst def
R6104:6104 Examples.Core <> v:129 var
def 6118:6124 <> f_kind2
R6131:6137 Examples.Core <> t_Error def
binder 6127:6127 <> v:130
R6143:6145 Coq.Init.Datatypes <> snd def
R6147:6147 Examples.Core <> v:130 var
def 6237:6243 <> t_Drain
R6258:6261 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R6247:6257 Crypt.choice_type <> choice_type ind
R6269:6272 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R6262:6268 Examples.Core <> vec_typ ind
R6273:6283 Crypt.choice_type <> choice_type ind
R6288:6292 Examples.Core <> t_Vec def
ind 6305:6311 <> t_Range
constr 6316:6324 <> RangeFull
def 6337:6341 <> drain
binder 6353:6353 <> L:133
binder 6355:6355 <> I:134
binder 6357:6357 <> A:135
R6388:6391 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R6361:6364 Hacspec.ChoiceEquality <> both rec
R6371:6375 Examples.Core <> t_Vec def
R6377:6377 Examples.Core <> A:135 var
R6379:6386 Examples.Core <> t_Global constr
R6368:6368 Examples.Core <> I:134 var
R6366:6366 Examples.Core <> L:133 var
R6399:6402 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R6392:6398 Examples.Core <> t_Range ind
R6403:6406 Hacspec.ChoiceEquality <> both rec
R6431:6434 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R6413:6419 Examples.Core <> t_Drain def
R6421:6421 Examples.Core <> A:135 var
R6423:6430 Examples.Core <> t_Global constr
R6435:6439 Examples.Core <> t_Vec def
R6441:6441 Examples.Core <> A:135 var
R6443:6450 Examples.Core <> t_Global constr
R6410:6410 Examples.Core <> I:134 var
R6408:6408 Examples.Core <> L:133 var
R6458:6462 Examples.Core <> drain:138 def
R6464:6464 Examples.Core <> x:137 var
R6475:6483 Hacspec.ChoiceEquality <> bind_both def
binder 6492:6493 <> x':139
R6498:6505 Hacspec.ChoiceEquality <> ret_both def
R6538:6541 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R6520:6526 Examples.Core <> t_Drain def
R6530:6537 Examples.Core <> t_Global constr
R6542:6546 Examples.Core <> t_Vec def
R6550:6557 Examples.Core <> t_Global constr
R6508:6508 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6511:6512 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6515:6515 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6509:6510 Examples.Core <> x':139 var
R6513:6514 Coq.Lists.List ListNotations ::list_scope:'['_']' not
syndef 6648:6652 <> t_Rev
R6657:6658 Coq.Init.Datatypes <> id def
def 6671:6673 <> rev
binder 6676:6676 <> L:140
binder 6678:6678 <> I:141
binder 6680:6680 <> A:142
R6688:6691 Hacspec.ChoiceEquality <> both rec
R6698:6703 Crypt.choice_type <> chList constr
R6705:6705 Examples.Core <> A:142 var
R6695:6695 Examples.Core <> I:141 var
R6693:6693 Examples.Core <> L:140 var
binder 6684:6684 <> x:143
R6711:6714 Hacspec.ChoiceEquality <> both rec
R6721:6726 Crypt.choice_type <> chList constr
R6734:6736 Examples.Core <> rev:146 def
R6738:6738 Examples.Core <> x:145 var
R6743:6751 Hacspec.ChoiceEquality <> bind_both def
binder 6760:6760 <> x:147
R6765:6772 Hacspec.ChoiceEquality <> ret_both def
R6788:6793 Crypt.choice_type <> chList constr
R6775:6782 Coq.Lists.List <> rev def
R6784:6784 Examples.Core <> x:147 var
def 6888:6890 <> pop
binder 6893:6893 <> L:148
binder 6895:6895 <> I:149
binder 6897:6897 <> A:150
R6921:6924 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R6902:6905 Hacspec.ChoiceEquality <> both rec
R6912:6917 Crypt.choice_type <> chList constr
R6919:6919 Examples.Core <> A:150 var
R6909:6909 Examples.Core <> I:149 var
R6907:6907 Examples.Core <> L:148 var
R6925:6928 Hacspec.ChoiceEquality <> both rec
R6945:6948 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R6935:6942 Crypt.choice_type <> chOption constr
R6944:6944 Examples.Core <> A:150 var
R6949:6953 Examples.Core <> t_Vec def
R6955:6955 Examples.Core <> A:150 var
R6958:6965 Examples.Core <> t_Global constr
R6932:6932 Examples.Core <> I:149 var
R6930:6930 Examples.Core <> L:148 var
R6974:6983 Hacspec.ChoiceEquality <> lift1_both def
R6995:7000 Crypt.choice_type <> chList constr
R7002:7002 Examples.Core <> A:150 var
binder 6991:6991 <> x:151
R7051:7054 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R7041:7048 Crypt.choice_type <> chOption constr
R7050:7050 Examples.Core <> A:150 var
R7055:7059 Examples.Core <> t_Vec def
R7061:7061 Examples.Core <> A:150 var
R7064:7071 Examples.Core <> t_Global constr
R7008:7008 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7024:7026 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7036:7036 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7009:7021 Coq.Lists.List <> hd_error def
R7023:7023 Examples.Core <> x:151 var
R7027:7033 Coq.Lists.List <> tl def
R7035:7035 Examples.Core <> x:151 var
def 7089:7092 <> push
binder 7095:7096 <> L1:152
binder 7098:7099 <> L2:153
binder 7101:7102 <> I1:154
binder 7104:7105 <> I2:155
binder 7107:7107 <> A:156
R7141:7144 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R7112:7115 Hacspec.ChoiceEquality <> both rec
R7124:7128 Examples.Core <> t_Vec def
R7130:7130 Examples.Core <> A:156 var
R7132:7139 Examples.Core <> t_Global constr
R7120:7121 Examples.Core <> I1:154 var
R7117:7118 Examples.Core <> L1:152 var
R7157:7160 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R7145:7148 Hacspec.ChoiceEquality <> both rec
R7156:7156 Examples.Core <> A:156 var
R7153:7154 Examples.Core <> I2:155 var
R7150:7151 Examples.Core <> L2:153 var
R7161:7164 Hacspec.ChoiceEquality <> both rec
R7191:7195 Examples.Core <> t_Vec def
R7197:7197 Examples.Core <> A:156 var
R7200:7207 Examples.Core <> t_Global constr
R7181:7185 extructures.fset <> ::fset_scope:x_':|:'_x not
R7179:7180 Examples.Core <> I1:154 var
R7186:7187 Examples.Core <> I2:155 var
R7169:7173 extructures.fset <> ::fset_scope:x_':|:'_x not
R7167:7168 Examples.Core <> L1:152 var
R7174:7175 Examples.Core <> L2:153 var
R7216:7225 Hacspec.ChoiceEquality <> lift2_both def
R7238:7243 Crypt.choice_type <> chList constr
R7245:7245 Examples.Core <> A:156 var
binder 7234:7234 <> x:157
binder 7248:7248 <> y:158
R7262:7267 Crypt.choice_type <> chList constr
R7269:7269 Examples.Core <> A:156 var
R7254:7257 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R7253:7253 Examples.Core <> y:158 var
R7258:7258 Examples.Core <> x:157 var
syndef 7283:7293 <> Option_Some
R7298:7301 Coq.Init.Datatypes <> Some constr
def 7315:7320 <> append
binder 7323:7324 <> L1:159
binder 7326:7327 <> L2:160
binder 7329:7330 <> I1:161
binder 7332:7333 <> I2:162
R7341:7351 Crypt.choice_type <> choice_type ind
binder 7337:7337 <> A:163
R7359:7362 Hacspec.ChoiceEquality <> both rec
R7371:7376 Crypt.choice_type <> chList constr
R7378:7378 Examples.Core <> A:163 var
R7367:7368 Examples.Core <> I1:161 var
R7364:7365 Examples.Core <> L1:159 var
binder 7355:7355 <> l:164
R7387:7390 Hacspec.ChoiceEquality <> both rec
R7399:7404 Crypt.choice_type <> chList constr
R7406:7406 Examples.Core <> A:163 var
R7395:7396 Examples.Core <> I2:162 var
R7392:7393 Examples.Core <> L2:160 var
binder 7383:7383 <> x:165
R7412:7415 Hacspec.ChoiceEquality <> both rec
R7450:7453 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R7442:7447 Crypt.choice_type <> chList constr
R7449:7449 Examples.Core <> A:163 var
R7454:7459 Crypt.choice_type <> chList constr
R7461:7461 Examples.Core <> A:163 var
R7432:7436 extructures.fset <> ::fset_scope:x_':|:'_x not
R7430:7431 Examples.Core <> I2:162 var
R7437:7438 Examples.Core <> I1:161 var
R7420:7424 extructures.fset <> ::fset_scope:x_':|:'_x not
R7418:7419 Examples.Core <> L2:160 var
R7425:7426 Examples.Core <> L1:159 var
R7469:7478 Hacspec.ChoiceEquality <> lift2_both def
R7558:7558 Examples.Core <> l:164 var
R7556:7556 Examples.Core <> x:165 var
R7490:7495 Crypt.choice_type <> chList constr
R7497:7497 Examples.Core <> A:163 var
binder 7486:7486 <> x:166
R7505:7510 Crypt.choice_type <> chList constr
R7512:7512 Examples.Core <> A:163 var
binder 7501:7501 <> y:167
R7542:7545 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R7534:7539 Crypt.choice_type <> chList constr
R7541:7541 Examples.Core <> A:163 var
R7546:7551 Crypt.choice_type <> chList constr
R7553:7553 Examples.Core <> A:163 var
R7518:7518 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7526:7527 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7530:7530 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7519:7521 Coq.Init.Datatypes <> app def
R7525:7525 Examples.Core <> x:166 var
R7523:7523 Examples.Core <> y:167 var
R7528:7529 Coq.Lists.List ListNotations ::list_scope:'['_']' not
syndef 7571:7575 <> clone
R7580:7581 Coq.Init.Datatypes <> id def
def 7595:7603 <> seq_unzip
binder 7606:7606 <> A:168
binder 7608:7608 <> B:169
R7616:7621 Crypt.choice_type <> chList constr
R7625:7628 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R7624:7624 Examples.Core <> A:168 var
R7629:7629 Examples.Core <> B:169 var
binder 7612:7612 <> s:170
R7643:7646 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R7635:7640 Crypt.choice_type <> chList constr
R7642:7642 Examples.Core <> A:168 var
R7647:7652 Crypt.choice_type <> chList constr
R7654:7654 Examples.Core <> B:169 var
R7659:7659 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7672:7673 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7686:7686 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7660:7669 mathcomp.ssreflect.seq <> unzip1 def
R7671:7671 Examples.Core <> s:170 var
R7674:7683 mathcomp.ssreflect.seq <> unzip2 def
R7685:7685 Examples.Core <> s:170 var
def 7700:7704 <> unzip
binder 7707:7707 <> L:171
binder 7709:7709 <> I:172
binder 7713:7713 <> A:173
binder 7715:7715 <> B:174
R7746:7749 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R7720:7723 Hacspec.ChoiceEquality <> both rec
R7730:7735 Crypt.choice_type <> chList constr
R7739:7742 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R7738:7738 Examples.Core <> A:173 var
R7743:7743 Examples.Core <> B:174 var
R7727:7727 Examples.Core <> I:172 var
R7725:7725 Examples.Core <> L:171 var
R7750:7753 Hacspec.ChoiceEquality <> both rec
R7768:7771 Crypt.package.pkg_notation PackageNotation ::package_scope:x_'×'_x not
R7760:7765 Crypt.choice_type <> chList constr
R7767:7767 Examples.Core <> A:173 var
R7772:7777 Crypt.choice_type <> chList constr
R7779:7779 Examples.Core <> B:174 var
R7757:7757 Examples.Core <> I:172 var
R7755:7755 Examples.Core <> L:171 var
R7785:7794 Hacspec.ChoiceEquality <> lift1_both def
R7796:7804 Examples.Core <> seq_unzip def
def 7817:7821 <> deref
binder 7824:7824 <> L:175
binder 7826:7826 <> I:176
binder 7828:7828 <> A:177
R7860:7863 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R7833:7836 Hacspec.ChoiceEquality <> both rec
R7843:7847 Examples.Core <> t_Vec def
R7851:7858 Examples.Core <> t_Global constr
R7864:7867 Hacspec.ChoiceEquality <> both rec
R7874:7876 Hacspec.Hacspec_Lib_Pre <> seq def
R7886:7890 Examples.Core <> deref:180 def
R7892:7892 Examples.Core <> X:179 var
R7897:7905 Hacspec.ChoiceEquality <> bind_both def
R7918:7922 Examples.Core <> t_Vec def
R7926:7933 Examples.Core <> t_Global constr
binder 7914:7914 <> x:181
R7938:7945 Hacspec.ChoiceEquality <> ret_both def
R7948:7960 Hacspec.Hacspec_Lib_Pre <> seq_from_list def
R7964:7964 Examples.Core <> x:181 var
syndef 8054:8056 <> get
R8061:8062 Coq.Init.Datatypes <> id def
def 8076:8082 <> t_Never
R8087:8091 Coq.Init.Logic <> False ind
syndef 8103:8109 <> v_Break
R8114:8115 Coq.Init.Datatypes <> id def
syndef 8127:8136 <> Result_Err
R8141:8143 Hacspec.Hacspec_Lib <> Err def
def 8157:8168 <> never_to_any
R8173:8174 Coq.Init.Datatypes <> tt constr
syndef 8186:8194 <> Result_Ok
R8199:8200 Hacspec.Hacspec_Lib <> Ok def
def 8224:8230 <> if_both
binder 8233:8234 <> L1:182
binder 8236:8237 <> L2:183
binder 8239:8240 <> L3:184
binder 8242:8243 <> I1:185
binder 8245:8246 <> I2:186
binder 8248:8249 <> I3:187
binder 8253:8253 <> A:188
R8261:8264 Hacspec.ChoiceEquality <> both rec
R8272:8276 Crypt.package.pkg_notation PackageNotation ::package_scope:'''bool' not
R8269:8270 Examples.Core <> I1:185 var
R8266:8267 Examples.Core <> L1:182 var
binder 8257:8257 <> c:189
R8289:8292 Hacspec.ChoiceEquality <> both rec
R8300:8300 Examples.Core <> A:188 var
R8297:8298 Examples.Core <> I2:186 var
R8294:8295 Examples.Core <> L2:183 var
binder 8280:8285 <> e_then:190
R8313:8316 Hacspec.ChoiceEquality <> both rec
R8324:8324 Examples.Core <> A:188 var
R8321:8322 Examples.Core <> I3:187 var
R8318:8319 Examples.Core <> L3:184 var
binder 8304:8309 <> e_else:191
R8329:8332 Hacspec.ChoiceEquality <> both rec
R8372:8372 Examples.Core <> A:188 var
R8363:8367 extructures.fset <> ::fset_scope:x_':|:'_x not
R8356:8360 extructures.fset <> ::fset_scope:x_':|:'_x not
R8354:8355 Examples.Core <> I1:185 var
R8361:8362 Examples.Core <> I2:186 var
R8368:8369 Examples.Core <> I3:187 var
R8344:8348 extructures.fset <> ::fset_scope:x_':|:'_x not
R8337:8341 extructures.fset <> ::fset_scope:x_':|:'_x not
R8335:8336 Examples.Core <> L1:182 var
R8342:8343 Examples.Core <> L2:183 var
R8349:8350 Examples.Core <> L3:184 var
R8379:8387 Hacspec.ChoiceEquality <> bind_both def
binder 8436:8436 <> b:192
R8444:8444 Examples.Core <> b:192 var
R8513:8521 Hacspec.ChoiceEquality <> lift_both def
R8564:8569 Examples.Core <> e_else:191 var
R8451:8459 Hacspec.ChoiceEquality <> lift_both def
R8501:8506 Examples.Core <> e_then:190 var
R8429:8429 Examples.Core <> c:189 var
def 8669:8678 <> match_both
binder 8681:8682 <> L1:193
binder 8684:8685 <> L2:194
binder 8687:8688 <> L3:195
binder 8690:8691 <> I1:196
binder 8693:8694 <> I2:197
binder 8696:8697 <> I3:198
binder 8701:8701 <> A:199
binder 8703:8703 <> B:200
R8711:8714 Hacspec.ChoiceEquality <> both rec
R8723:8728 Hacspec.Hacspec_Lib_Pre <> option def
R8730:8730 Examples.Core <> A:199 var
R8719:8720 Examples.Core <> I3:198 var
R8716:8717 Examples.Core <> L3:195 var
binder 8707:8707 <> x:201
R8752:8755 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R8740:8743 Hacspec.ChoiceEquality <> both rec
R8751:8751 Examples.Core <> A:199 var
R8748:8749 Examples.Core <> I3:198 var
R8745:8746 Examples.Core <> L3:195 var
R8756:8759 Hacspec.ChoiceEquality <> both rec
R8767:8767 Examples.Core <> B:200 var
R8764:8765 Examples.Core <> I1:196 var
R8761:8762 Examples.Core <> L1:193 var
binder 8735:8736 <> fa:202
R8776:8779 Hacspec.ChoiceEquality <> both rec
R8787:8787 Examples.Core <> B:200 var
R8784:8785 Examples.Core <> I2:197 var
R8781:8782 Examples.Core <> L2:194 var
binder 8771:8772 <> fb:203
R8807:8813 Coq.Init.Datatypes <> is_true def
R8816:8822 extructures.fset <> fsubset def
R8827:8828 Examples.Core <> L1:193 var
R8824:8825 Examples.Core <> L3:195 var
binder 8792:8803 <> fsubset_loc1:204
R8850:8856 Coq.Init.Datatypes <> is_true def
R8859:8865 extructures.fset <> fsubset def
R8870:8871 Examples.Core <> L2:194 var
R8867:8868 Examples.Core <> L3:195 var
binder 8835:8846 <> fsubset_loc2:205
R8895:8901 Coq.Init.Datatypes <> is_true def
R8904:8910 extructures.fset <> fsubset def
R8915:8916 Examples.Core <> I1:196 var
R8912:8913 Examples.Core <> I3:198 var
binder 8878:8891 <> fsubset_opsig1:206
R8940:8946 Coq.Init.Datatypes <> is_true def
R8949:8955 extructures.fset <> fsubset def
R8960:8961 Examples.Core <> I2:197 var
R8957:8958 Examples.Core <> I3:198 var
binder 8923:8936 <> fsubset_opsig2:207
R8967:8970 Hacspec.ChoiceEquality <> both rec
R8996:8996 Examples.Core <> B:200 var
R8987:8991 extructures.fset <> ::fset_scope:x_':|:'_x not
R8985:8986 Examples.Core <> I1:196 var
R8992:8993 Examples.Core <> I2:197 var
R8975:8979 extructures.fset <> ::fset_scope:x_':|:'_x not
R8973:8974 Examples.Core <> L1:193 var
R8980:8981 Examples.Core <> L2:194 var
R9003:9011 Hacspec.ChoiceEquality <> bind_both def
binder 9060:9060 <> y:208
R9071:9071 Examples.Core <> y:208 var
R9089:9092 Coq.Init.Datatypes <> Some constr
R9099:9107 Hacspec.ChoiceEquality <> lift_both def
R9151:9152 Examples.Core <> fa:202 var
R9155:9162 Hacspec.ChoiceEquality <> ret_both def
R9179:9182 Coq.Init.Datatypes <> None constr
R9187:9195 Hacspec.ChoiceEquality <> lift_both def
R9238:9239 Examples.Core <> fb:203 var
R9053:9053 Examples.Core <> x:201 var
R9440:9449 Examples.Core <> match_both def
binder 9458:9458 <> a:210
not 9354:9354 <> :::'matchb'_x_'with'_'|'_'Option_Some'_x_'=>'_x_'|'_'Option_None'_'=>'_x_'end'
R9642:9651 Examples.Core <> match_both def
binder 9660:9660 <> a:211
not 9566:9566 <> :::'matchb'_x_'with'_'|'_'Option_Some'_x_'=>'_x_'|'_'''_'''_'=>'_x_'end'
R9790:9797 Hacspec.ChoiceEquality <> ret_both def
R9805:9809 Crypt.package.pkg_notation PackageNotation ::package_scope:'''unit' not
R9800:9801 Coq.Init.Datatypes <> tt constr
not 9768:9768 <> :::'ret_both'_'tt'
