(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Crate_Ovn_traits.
Export Crate_Ovn_traits.

Equations select_private_voting_key {L1 : {fset Location}} {I1 : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (random : both L1 I1 int32) : both L1 I1 v_Z :=
  select_private_voting_key random  :=
    solve_lift (f_random_field_elem random) : both L1 I1 v_Z.
Fail Next Obligation.

Equations compute_group_element_for_vote {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (xi : both L1 I1 f_Z) (vote : both L2 I2 'bool) (g_pow_yi : both L3 I3 v_G) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) v_G :=
  compute_group_element_for_vote xi vote g_pow_yi  :=
    solve_lift (f_prod (f_pow g_pow_yi xi) (f_g_pow (ifb vote
    then f_field_one (ret_both (tt : 'unit))
    else f_field_zero (ret_both (tt : 'unit))))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) v_G.
Fail Next Obligation.

Definition prod1_loc {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} : Location :=
  (v_G;0%nat).
Definition prod2_loc {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} : Location :=
  (v_G;1%nat).
Equations compute_g_pow_yi {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (i : both L1 I1 uint_size) (xis : both L2 I2 (nseq v_G (is_pure (n)))) : both (L1 :|: L2 :|: fset [prod1_loc;prod2_loc]) (I1 :|: I2) v_G :=
  compute_g_pow_yi i xis  :=
    letb prod1 loc(prod1_loc) := f_group_one (ret_both (tt : 'unit)) in
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := i))) (fun j =>
      ssp (fun _ =>
        assign todo(term) : (both (*1*)(L2:|:L1:|:fset [prod1_loc]) (I2:|:I1) 'unit))) (ret_both (tt : 'unit)) in
    letb prod2 loc(prod2_loc) := f_group_one (ret_both (tt : 'unit)) in
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := i .+ (ret_both (1 : uint_size))) (f_end := n))) (fun j =>
      ssp (fun _ =>
        assign todo(term) : (both (*1*)(L2:|:L1:|:fset [prod2_loc]) (I2:|:I1) 'unit))) (ret_both (tt : 'unit)) in
    solve_lift (f_div prod1 prod2) : both (L1 :|: L2 :|: fset [prod1_loc;prod2_loc]) (I1 :|: I2) v_G.
Fail Next Obligation.

Equations check_commitment {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (g_pow_xi_yi_vi : both L1 I1 v_G) (commitment : both L2 I2 f_Z) : both (L1 :|: L2) (I1 :|: I2) 'bool :=
  check_commitment g_pow_xi_yi_vi commitment  :=
    solve_lift ((f_hash (impl__into_vec (unsize (box_new (array_from_list [g_pow_xi_yi_vi]))))) =.? commitment) : both (L1 :|: L2) (I1 :|: I2) 'bool.
Fail Next Obligation.

Equations commit_to {L1 : {fset Location}} {I1 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (g_pow_xi_yi_vi : both L1 I1 v_G) : both L1 I1 f_Z :=
  commit_to g_pow_xi_yi_vi  :=
    solve_lift (f_hash (impl__into_vec (unsize (box_new (array_from_list [g_pow_xi_yi_vi]))))) : both L1 I1 f_Z.
Fail Next Obligation.

Definition t_CastVoteParam {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} : choice_type :=
  (int32 × v_Z × int32 × int32 × int32 × 'bool).
Equations f_cvp_i {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_CastVoteParam) : both L I int32 :=
  f_cvp_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst x)))) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_cvp_xi {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_CastVoteParam) : both L I v_Z :=
  f_cvp_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : v_Z))) : both L I v_Z.
Fail Next Obligation.
Equations f_cvp_zkp_random_w {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_CastVoteParam) : both L I int32 :=
  f_cvp_zkp_random_w s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_cvp_zkp_random_r {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_CastVoteParam) : both L I int32 :=
  f_cvp_zkp_random_r s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_cvp_zkp_random_d {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_CastVoteParam) : both L I int32 :=
  f_cvp_zkp_random_d s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_cvp_vote {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_CastVoteParam) : both L I 'bool :=
  f_cvp_vote s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : 'bool))) : both L I 'bool.
Fail Next Obligation.
Equations Build_t_CastVoteParam {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} {f_cvp_i : both L0 I0 int32} {f_cvp_xi : both L1 I1 v_Z} {f_cvp_zkp_random_w : both L2 I2 int32} {f_cvp_zkp_random_r : both L3 I3 int32} {f_cvp_zkp_random_d : both L4 I4 int32} {f_cvp_vote : both L5 I5 'bool} : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_CastVoteParam) :=
  Build_t_CastVoteParam  :=
    bind_both f_cvp_vote (fun f_cvp_vote =>
      bind_both f_cvp_zkp_random_d (fun f_cvp_zkp_random_d =>
        bind_both f_cvp_zkp_random_r (fun f_cvp_zkp_random_r =>
          bind_both f_cvp_zkp_random_w (fun f_cvp_zkp_random_w =>
            bind_both f_cvp_xi (fun f_cvp_xi =>
              bind_both f_cvp_i (fun f_cvp_i =>
                solve_lift (ret_both ((f_cvp_i,f_cvp_xi,f_cvp_zkp_random_w,f_cvp_zkp_random_r,f_cvp_zkp_random_d,f_cvp_vote) : (t_CastVoteParam))))))))) : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_CastVoteParam).
Fail Next Obligation.
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_i' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := y) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_xi' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := y) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_zkp_random_w' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := y) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_zkp_random_r' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := y) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_zkp_random_d' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := y) (f_cvp_vote := f_cvp_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_vote' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := y)).

Definition t_OrZKPCommit {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} : choice_type :=
  (v_G × v_G × v_G × v_G × v_G × v_G × f_Z × f_Z × f_Z × f_Z × f_Z).
Equations f_or_zkp_x {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I v_G :=
  f_or_zkp_x s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst (fst (fst (fst (fst (fst x))))))))) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_or_zkp_y {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I v_G :=
  f_or_zkp_y s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst (fst (fst (fst x))))))))) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_or_zkp_a1 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I v_G :=
  f_or_zkp_a1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst (fst (fst x)))))))) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_or_zkp_b1 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I v_G :=
  f_or_zkp_b1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst (fst x))))))) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_or_zkp_a2 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I v_G :=
  f_or_zkp_a2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst x)))))) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_or_zkp_b2 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I v_G :=
  f_or_zkp_b2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst x))))) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_or_zkp_c {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I f_Z :=
  f_or_zkp_c s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : f_Z))) : both L I f_Z.
Fail Next Obligation.
Equations f_or_zkp_d1 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I f_Z :=
  f_or_zkp_d1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : f_Z))) : both L I f_Z.
Fail Next Obligation.
Equations f_or_zkp_d2 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I f_Z :=
  f_or_zkp_d2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : f_Z))) : both L I f_Z.
Fail Next Obligation.
Equations f_or_zkp_r1 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I f_Z :=
  f_or_zkp_r1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : f_Z))) : both L I f_Z.
Fail Next Obligation.
Equations f_or_zkp_r2 {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OrZKPCommit) : both L I f_Z :=
  f_or_zkp_r2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : f_Z))) : both L I f_Z.
Fail Next Obligation.
Equations Build_t_OrZKPCommit {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {L6 : {fset Location}} {L7 : {fset Location}} {L8 : {fset Location}} {L9 : {fset Location}} {L10 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {I6 : Interface} {I7 : Interface} {I8 : Interface} {I9 : Interface} {I10 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} {f_or_zkp_x : both L0 I0 v_G} {f_or_zkp_y : both L1 I1 v_G} {f_or_zkp_a1 : both L2 I2 v_G} {f_or_zkp_b1 : both L3 I3 v_G} {f_or_zkp_a2 : both L4 I4 v_G} {f_or_zkp_b2 : both L5 I5 v_G} {f_or_zkp_c : both L6 I6 f_Z} {f_or_zkp_d1 : both L7 I7 f_Z} {f_or_zkp_d2 : both L8 I8 f_Z} {f_or_zkp_r1 : both L9 I9 f_Z} {f_or_zkp_r2 : both L10 I10 f_Z} : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6:|:L7:|:L8:|:L9:|:L10) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6:|:I7:|:I8:|:I9:|:I10) (t_OrZKPCommit) :=
  Build_t_OrZKPCommit  :=
    bind_both f_or_zkp_r2 (fun f_or_zkp_r2 =>
      bind_both f_or_zkp_r1 (fun f_or_zkp_r1 =>
        bind_both f_or_zkp_d2 (fun f_or_zkp_d2 =>
          bind_both f_or_zkp_d1 (fun f_or_zkp_d1 =>
            bind_both f_or_zkp_c (fun f_or_zkp_c =>
              bind_both f_or_zkp_b2 (fun f_or_zkp_b2 =>
                bind_both f_or_zkp_a2 (fun f_or_zkp_a2 =>
                  bind_both f_or_zkp_b1 (fun f_or_zkp_b1 =>
                    bind_both f_or_zkp_a1 (fun f_or_zkp_a1 =>
                      bind_both f_or_zkp_y (fun f_or_zkp_y =>
                        bind_both f_or_zkp_x (fun f_or_zkp_x =>
                          solve_lift (ret_both ((f_or_zkp_x,f_or_zkp_y,f_or_zkp_a1,f_or_zkp_b1,f_or_zkp_a2,f_or_zkp_b2,f_or_zkp_c,f_or_zkp_d1,f_or_zkp_d2,f_or_zkp_r1,f_or_zkp_r2) : (t_OrZKPCommit)))))))))))))) : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6:|:L7:|:L8:|:L9:|:L10) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6:|:I7:|:I8:|:I9:|:I10) (t_OrZKPCommit).
Fail Next Obligation.
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_x' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := y) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_y' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := y) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_a1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := y) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_b1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := y) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_a2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := y) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_b2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := y) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_c' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := y) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_d1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := y) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_d2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := y) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_r1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := y) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_r2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := y)).

Definition t_RegisterParam {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} : choice_type :=
  (int32 × v_Z × int32).
Equations f_rp_i {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_RegisterParam) : both L I int32 :=
  f_rp_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_rp_xi {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_RegisterParam) : both L I v_Z :=
  f_rp_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : v_Z))) : both L I v_Z.
Fail Next Obligation.
Equations f_rp_zkp_random {L : {fset Location}} {I : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} (s : both L I t_RegisterParam) : both L I int32 :=
  f_rp_zkp_random s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : int32))) : both L I int32.
Fail Next Obligation.
Equations Build_t_RegisterParam {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {v_Z : _} `{ t_Sized v_Z} `{ t_Field v_Z} {f_rp_i : both L0 I0 int32} {f_rp_xi : both L1 I1 v_Z} {f_rp_zkp_random : both L2 I2 int32} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_RegisterParam) :=
  Build_t_RegisterParam  :=
    bind_both f_rp_zkp_random (fun f_rp_zkp_random =>
      bind_both f_rp_xi (fun f_rp_xi =>
        bind_both f_rp_i (fun f_rp_i =>
          solve_lift (ret_both ((f_rp_i,f_rp_xi,f_rp_zkp_random) : (t_RegisterParam)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_RegisterParam).
Fail Next Obligation.
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_i' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := y) (f_rp_xi := f_rp_xi x) (f_rp_zkp_random := f_rp_zkp_random x)).
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_xi' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := f_rp_i x) (f_rp_xi := y) (f_rp_zkp_random := f_rp_zkp_random x)).
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_zkp_random' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := f_rp_i x) (f_rp_xi := f_rp_xi x) (f_rp_zkp_random := y)).

Definition t_SchnorrZKPCommit {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} : choice_type :=
  (v_G × f_Z × f_Z).
Equations f_schnorr_zkp_u {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_SchnorrZKPCommit) : both L I v_G :=
  f_schnorr_zkp_u s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_schnorr_zkp_c {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_SchnorrZKPCommit) : both L I f_Z :=
  f_schnorr_zkp_c s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : f_Z))) : both L I f_Z.
Fail Next Obligation.
Equations f_schnorr_zkp_z {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_SchnorrZKPCommit) : both L I f_Z :=
  f_schnorr_zkp_z s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : f_Z))) : both L I f_Z.
Fail Next Obligation.
Equations Build_t_SchnorrZKPCommit {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} {f_schnorr_zkp_u : both L0 I0 v_G} {f_schnorr_zkp_c : both L1 I1 f_Z} {f_schnorr_zkp_z : both L2 I2 f_Z} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_SchnorrZKPCommit) :=
  Build_t_SchnorrZKPCommit  :=
    bind_both f_schnorr_zkp_z (fun f_schnorr_zkp_z =>
      bind_both f_schnorr_zkp_c (fun f_schnorr_zkp_c =>
        bind_both f_schnorr_zkp_u (fun f_schnorr_zkp_u =>
          solve_lift (ret_both ((f_schnorr_zkp_u,f_schnorr_zkp_c,f_schnorr_zkp_z) : (t_SchnorrZKPCommit)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_SchnorrZKPCommit).
Fail Next Obligation.
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_u' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := y) (f_schnorr_zkp_c := f_schnorr_zkp_c x) (f_schnorr_zkp_z := f_schnorr_zkp_z x)).
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_c' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_schnorr_zkp_u x) (f_schnorr_zkp_c := y) (f_schnorr_zkp_z := f_schnorr_zkp_z x)).
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_z' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_schnorr_zkp_u x) (f_schnorr_zkp_c := f_schnorr_zkp_c x) (f_schnorr_zkp_z := y)).

Definition t_TallyParameter : choice_type :=
  'unit.
Equations Build_t_TallyParameter : both (fset []) (fset []) (t_TallyParameter) :=
  Build_t_TallyParameter  :=
    solve_lift (ret_both (tt (* Empty tuple *) : (t_TallyParameter))) : both (fset []) (fset []) (t_TallyParameter).
Fail Next Obligation.

Equations schnorr_zkp {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (random : both L1 I1 int32) (h : both L2 I2 v_G) (x : both L3 I3 f_Z) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_SchnorrZKPCommit v_G) :=
  schnorr_zkp random h x  :=
    solve_lift (run (letb r := f_random_field_elem random in
    letb u := f_g_pow r in
    letb c := f_hash (impl__into_vec (unsize (box_new (array_from_list [f_g (ret_both (tt : 'unit));
      h;
      u])))) in
    letb z := f_add r (f_mul c x) in
    letm[choice_typeMonad.result_bind_code (t_SchnorrZKPCommit v_G)] hoist1 := v_Break (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := u) (f_schnorr_zkp_c := c) (f_schnorr_zkp_z := z)) in
    ControlFlow_Continue (never_to_any hoist1))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_SchnorrZKPCommit v_G).
Fail Next Obligation.

Equations schnorr_zkp_validate {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (h : both L1 I1 v_G) (pi : both L2 I2 (t_SchnorrZKPCommit v_G)) : both (L1 :|: L2) (I1 :|: I2) 'bool :=
  schnorr_zkp_validate h pi  :=
    solve_lift (andb ((f_schnorr_zkp_c pi) =.? (f_hash (impl__into_vec (unsize (box_new (array_from_list [f_g (ret_both (tt : 'unit));
      h;
      f_schnorr_zkp_u pi])))))) ((f_g_pow (f_schnorr_zkp_z pi)) =.? (f_prod (f_schnorr_zkp_u pi) (f_pow h (f_schnorr_zkp_c pi))))) : both (L1 :|: L2) (I1 :|: I2) 'bool.
Fail Next Obligation.

Equations zkp_one_out_of_two {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {L6 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {I6 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (random_w : both L1 I1 int32) (random_r : both L2 I2 int32) (random_d : both L3 I3 int32) (h : both L4 I4 v_G) (xi : both L5 I5 f_Z) (vi : both L6 I6 'bool) : both (L1 :|: L2 :|: L3 :|: L4 :|: L5 :|: L6) (I1 :|: I2 :|: I3 :|: I4 :|: I5 :|: I6) (t_OrZKPCommit v_G) :=
  zkp_one_out_of_two random_w random_r random_d h xi vi  :=
    letb w := f_random_field_elem random_w in
    solve_lift (ifb vi
    then letb r1 := f_random_field_elem random_r in
    letb d1 := f_random_field_elem random_d in
    letb x := f_g_pow xi in
    letb y := f_prod (f_pow h xi) (f_g (ret_both (tt : 'unit))) in
    letb a1 := f_prod (f_g_pow r1) (f_pow x d1) in
    letb b1 := f_prod (f_pow h r1) (f_pow y d1) in
    letb a2 := f_g_pow w in
    letb b2 := f_pow h w in
    letb c := f_hash (impl__into_vec (unsize (box_new (array_from_list [x;
      y;
      a1;
      b1;
      a2;
      b2])))) in
    letb d2 := f_sub c d1 in
    letb r2 := f_sub w (f_mul xi d2) in
    Build_t_OrZKPCommit (f_or_zkp_x := x) (f_or_zkp_y := y) (f_or_zkp_a1 := a1) (f_or_zkp_b1 := b1) (f_or_zkp_a2 := a2) (f_or_zkp_b2 := b2) (f_or_zkp_c := c) (f_or_zkp_d1 := d1) (f_or_zkp_d2 := d2) (f_or_zkp_r1 := r1) (f_or_zkp_r2 := r2)
    else letb r2 := f_random_field_elem random_r in
    letb d2 := f_random_field_elem random_d in
    letb x := f_g_pow xi in
    letb y := f_pow h xi in
    letb a1 := f_g_pow w in
    letb b1 := f_pow h w in
    letb a2 := f_prod (f_g_pow r2) (f_pow x d2) in
    letb b2 := f_prod (f_pow h r2) (f_pow (f_div y (f_g (ret_both (tt : 'unit)))) d2) in
    letb c := f_hash (impl__into_vec (unsize (box_new (array_from_list [x;
      y;
      a1;
      b1;
      a2;
      b2])))) in
    letb d1 := f_sub c d2 in
    letb r1 := f_sub w (f_mul xi d1) in
    Build_t_OrZKPCommit (f_or_zkp_x := x) (f_or_zkp_y := y) (f_or_zkp_a1 := a1) (f_or_zkp_b1 := b1) (f_or_zkp_a2 := a2) (f_or_zkp_b2 := b2) (f_or_zkp_c := c) (f_or_zkp_d1 := d1) (f_or_zkp_d2 := d2) (f_or_zkp_r1 := r1) (f_or_zkp_r2 := r2)) : both (L1 :|: L2 :|: L3 :|: L4 :|: L5 :|: L6) (I1 :|: I2 :|: I3 :|: I4 :|: I5 :|: I6) (t_OrZKPCommit v_G).
Fail Next Obligation.

Equations zkp_one_out_of_two_validate {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_Group v_G} (h : both L1 I1 v_G) (zkp : both L2 I2 (t_OrZKPCommit v_G)) : both (L1 :|: L2) (I1 :|: I2) 'bool :=
  zkp_one_out_of_two_validate h zkp  :=
    letb c := f_hash (impl__into_vec (unsize (box_new (array_from_list [f_or_zkp_x zkp;
      f_or_zkp_y zkp;
      f_or_zkp_a1 zkp;
      f_or_zkp_b1 zkp;
      f_or_zkp_a2 zkp;
      f_or_zkp_b2 zkp])))) in
    solve_lift (andb (andb (andb (andb (c =.? (f_add (f_or_zkp_d1 zkp) (f_or_zkp_d2 zkp))) ((f_or_zkp_a1 zkp) =.? (f_prod (f_g_pow (f_or_zkp_r1 zkp)) (f_pow (f_or_zkp_x zkp) (f_or_zkp_d1 zkp))))) ((f_or_zkp_b1 zkp) =.? (f_prod (f_pow h (f_or_zkp_r1 zkp)) (f_pow (f_or_zkp_y zkp) (f_or_zkp_d1 zkp))))) ((f_or_zkp_a2 zkp) =.? (f_prod (f_g_pow (f_or_zkp_r2 zkp)) (f_pow (f_or_zkp_x zkp) (f_or_zkp_d2 zkp))))) ((f_or_zkp_b2 zkp) =.? (f_prod (f_pow h (f_or_zkp_r2 zkp)) (f_pow (f_div (f_or_zkp_y zkp) (f_g (ret_both (tt : 'unit)))) (f_or_zkp_d2 zkp))))) : both (L1 :|: L2) (I1 :|: I2) 'bool.
Fail Next Obligation.

Definition t_OvnContractState {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} : choice_type :=
  (nseq v_G (is_pure (n)) × nseq (t_SchnorrZKPCommit v_G) (is_pure (n)) × nseq f_Z (is_pure (n)) × nseq v_G (is_pure (n)) × nseq (t_OrZKPCommit v_G) (is_pure (n)) × int32 × nseq 'bool (is_pure (n))).
Equations f_g_pow_xis {L : {fset Location}} {I : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OvnContractState) : both L I (nseq v_G (is_pure (n))) :=
  f_g_pow_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst (fst x))))) : (nseq v_G (is_pure (n)))))) : both L I (nseq v_G (is_pure (n))).
Fail Next Obligation.
Equations f_zkp_xis {L : {fset Location}} {I : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OvnContractState) : both L I (nseq (t_SchnorrZKPCommit v_G) (is_pure (n))) :=
  f_zkp_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst x))))) : (nseq (t_SchnorrZKPCommit v_G) (is_pure (n)))))) : both L I (nseq (t_SchnorrZKPCommit v_G) (is_pure (n))).
Fail Next Obligation.
Equations f_commit_vis {L : {fset Location}} {I : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OvnContractState) : both L I (nseq f_Z (is_pure (n))) :=
  f_commit_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : (nseq f_Z (is_pure (n)))))) : both L I (nseq f_Z (is_pure (n))).
Fail Next Obligation.
Equations f_g_pow_xi_yi_vis {L : {fset Location}} {I : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OvnContractState) : both L I (nseq v_G (is_pure (n))) :=
  f_g_pow_xi_yi_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : (nseq v_G (is_pure (n)))))) : both L I (nseq v_G (is_pure (n))).
Fail Next Obligation.
Equations f_zkp_vis {L : {fset Location}} {I : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OvnContractState) : both L I (nseq (t_OrZKPCommit v_G) (is_pure (n))) :=
  f_zkp_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : (nseq (t_OrZKPCommit v_G) (is_pure (n)))))) : both L I (nseq (t_OrZKPCommit v_G) (is_pure (n))).
Fail Next Obligation.
Equations f_tally {L : {fset Location}} {I : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OvnContractState) : both L I int32 :=
  f_tally s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_round1 {L : {fset Location}} {I : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (s : both L I t_OvnContractState) : both L I (nseq 'bool (is_pure (n))) :=
  f_round1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : (nseq 'bool (is_pure (n)))))) : both L I (nseq 'bool (is_pure (n))).
Fail Next Obligation.
Equations Build_t_OvnContractState {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {L6 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {I6 : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} {f_g_pow_xis : both L0 I0 (nseq v_G (is_pure (n)))} {f_zkp_xis : both L1 I1 (nseq (t_SchnorrZKPCommit v_G) (is_pure (n)))} {f_commit_vis : both L2 I2 (nseq f_Z (is_pure (n)))} {f_g_pow_xi_yi_vis : both L3 I3 (nseq v_G (is_pure (n)))} {f_zkp_vis : both L4 I4 (nseq (t_OrZKPCommit v_G) (is_pure (n)))} {f_tally : both L5 I5 int32} {f_round1 : both L6 I6 (nseq 'bool (is_pure (n)))} : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6) (t_OvnContractState) :=
  Build_t_OvnContractState  :=
    bind_both f_round1 (fun f_round1 =>
      bind_both f_tally (fun f_tally =>
        bind_both f_zkp_vis (fun f_zkp_vis =>
          bind_both f_g_pow_xi_yi_vis (fun f_g_pow_xi_yi_vis =>
            bind_both f_commit_vis (fun f_commit_vis =>
              bind_both f_zkp_xis (fun f_zkp_xis =>
                bind_both f_g_pow_xis (fun f_g_pow_xis =>
                  solve_lift (ret_both ((f_g_pow_xis,f_zkp_xis,f_commit_vis,f_g_pow_xi_yi_vis,f_zkp_vis,f_tally,f_round1) : (t_OvnContractState)))))))))) : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6) (t_OvnContractState).
Fail Next Obligation.
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := y) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x) (f_round1 := f_round1 x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := y) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x) (f_round1 := f_round1 x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_commit_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := y) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x) (f_round1 := f_round1 x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xi_yi_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := y) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x) (f_round1 := f_round1 x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := y) (f_tally := f_tally x) (f_round1 := f_round1 x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_tally' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := y) (f_round1 := f_round1 x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_round1' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x) (f_round1 := y)).

Definition cast_vote_state_ret_loc {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState v_G (both (fset []) (fset []) uint_size);5%nat).
Equations cast_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (ctx : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState v_G (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [cast_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError) :=
  cast_vote ctx state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code t_ParseError] (params : t_CastVoteParam f_Z) := impl__map_err out f_from in
    Result_Ok (letb g_pow_yi := compute_g_pow_yi (cast_int (WS2 := _) (f_cvp_i params)) (f_g_pow_xis state) in
    letb g_pow_xi_yi_vi := compute_group_element_for_vote (f_cvp_xi params) (f_cvp_vote params) g_pow_yi in
    letb zkp_vi := zkp_one_out_of_two (f_cvp_zkp_random_w params) (f_cvp_zkp_random_r params) (f_cvp_zkp_random_d params) g_pow_yi (f_cvp_xi params) (f_cvp_vote params) in
    letb cast_vote_state_ret loc(cast_vote_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    letb _ := assign todo(term) in
    Result_Ok (prod_b (f_accept (ret_both (tt : 'unit)),cast_vote_state_ret))))) : both (L1 :|: L2 :|: fset [cast_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.

Definition commit_to_vote_state_ret_loc {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState v_G (both (fset []) (fset []) uint_size);6%nat).
Equations commit_to_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (ctx : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState v_G (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [commit_to_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError) :=
  commit_to_vote ctx state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code t_ParseError] (params : t_CastVoteParam f_Z) := impl__map_err out f_from in
    Result_Ok (letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := n))) (fun i =>
      ssp (fun _ =>
        solve_lift (ifb orb (not (schnorr_zkp_validate ((f_g_pow_xis state).a[i]) ((f_zkp_xis state).a[i]))) (not ((f_round1 state).a[i]))
        then letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError)] hoist26 := v_Break (Result_Err ParseError) in
        ControlFlow_Continue (never_to_any hoist26)
        else ()) : (both (*0*)(L2:|:fset []) (I2) (t_ControlFlow (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError) 'unit)))) (ret_both (tt : 'unit)) in
    letb g_pow_yi := compute_g_pow_yi (cast_int (WS2 := _) (f_cvp_i params)) (f_g_pow_xis state) in
    letb g_pow_xi_yi_vi := compute_group_element_for_vote (f_cvp_xi params) (f_cvp_vote params) g_pow_yi in
    letb commit_vi := commit_to g_pow_xi_yi_vi in
    letb commit_to_vote_state_ret loc(commit_to_vote_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    Result_Ok (prod_b (f_accept (ret_both (tt : 'unit)),commit_to_vote_state_ret))))) : both (L1 :|: L2 :|: fset [commit_to_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.

Equations init_ovn_contract {L1 : {fset Location}} {I1 : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} `{ t_Sized v_G} `{ t_Group v_G} (_ : both L1 I1 'unit) : both L1 I1 (t_Result (t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_Reject) :=
  init_ovn_contract _  :=
    Result_Ok (solve_lift (Build_t_OvnContractState (f_g_pow_xis := repeat (f_group_one (ret_both (tt : 'unit))) n) (f_zkp_xis := repeat (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_group_one (ret_both (tt : 'unit))) (f_schnorr_zkp_z := f_field_zero (ret_both (tt : 'unit))) (f_schnorr_zkp_c := f_field_zero (ret_both (tt : 'unit)))) n) (f_commit_vis := repeat (f_field_zero (ret_both (tt : 'unit))) n) (f_g_pow_xi_yi_vis := repeat (f_group_one (ret_both (tt : 'unit))) n) (f_zkp_vis := repeat (Build_t_OrZKPCommit (f_or_zkp_x := f_group_one (ret_both (tt : 'unit))) (f_or_zkp_y := f_group_one (ret_both (tt : 'unit))) (f_or_zkp_a1 := f_group_one (ret_both (tt : 'unit))) (f_or_zkp_b1 := f_group_one (ret_both (tt : 'unit))) (f_or_zkp_a2 := f_group_one (ret_both (tt : 'unit))) (f_or_zkp_b2 := f_group_one (ret_both (tt : 'unit))) (f_or_zkp_c := f_field_zero (ret_both (tt : 'unit))) (f_or_zkp_d1 := f_field_zero (ret_both (tt : 'unit))) (f_or_zkp_d2 := f_field_zero (ret_both (tt : 'unit))) (f_or_zkp_r1 := f_field_zero (ret_both (tt : 'unit))) (f_or_zkp_r2 := f_field_zero (ret_both (tt : 'unit)))) n) (f_tally := ret_both (0 : int32)) (f_round1 := repeat (ret_both (false : 'bool)) n))) : both L1 I1 (t_Result (t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_Reject).
Fail Next Obligation.

Definition register_vote_state_ret_loc {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState v_G (both (fset []) (fset []) uint_size);7%nat).
Equations register_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (ctx : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState v_G (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [register_vote_state_ret_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError) :=
  register_vote ctx state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code t_ParseError] (params : t_RegisterParam f_Z) := impl__map_err out f_from in
    Result_Ok (letb g_pow_xi := f_g_pow (f_rp_xi params) in
    letb zkp_xi := schnorr_zkp (f_rp_zkp_random params) g_pow_xi (f_rp_xi params) in
    letb register_vote_state_ret loc(register_vote_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    letb _ := assign todo(term) in
    letb _ := assign todo(term) in
    Result_Ok (prod_b (f_accept (ret_both (tt : 'unit)),register_vote_state_ret))))) : both (L1 :|: L2 :|: fset [register_vote_state_ret_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.

Definition curr_loc {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (f_Z;8%nat).
Definition tally_loc {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (int32;9%nat).
Definition tally_votes_state_ret_loc {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState v_G (both (fset []) (fset []) uint_size);10%nat).
Definition vote_result_loc {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (v_G;11%nat).
Equations tally_votes {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_G : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_G} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Group v_G} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (_ : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState v_G (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [curr_loc;tally_loc;tally_votes_state_ret_loc;vote_result_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError) :=
  tally_votes _ state  :=
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := n))) (fun i =>
      ssp (fun _ =>
        letb g_pow_yi := compute_g_pow_yi i (f_g_pow_xis state) in
        letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError)] _ := ControlFlow_Continue (ifb not (zkp_one_out_of_two_validate g_pow_yi ((f_zkp_vis state).a[i]))
        then letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError)] hoist27 := v_Break (Result_Err ParseError) in
        ControlFlow_Continue (never_to_any hoist27)
        else ()) in
        solve_lift (ifb not (check_commitment ((f_g_pow_xi_yi_vis state).a[i]) ((f_commit_vis state).a[i]))
        then letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError)] hoist28 := v_Break (Result_Err ParseError) in
        ControlFlow_Continue (never_to_any hoist28)
        else ()) : (both (*2*)(L2:|:fset [prod1_loc;prod2_loc]) (I2) (t_ControlFlow (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError) 'unit)))) (ret_both (tt : 'unit)) in
    letb vote_result loc(vote_result_loc) := f_group_one (ret_both (tt : 'unit)) in
    letb _ := foldi_both_list (f_into_iter (f_g_pow_xi_yi_vis state)) (fun g_pow_vote =>
      ssp (fun _ =>
        assign todo(term) : (both (*1*)(L2:|:fset [vote_result_loc]) (I2) 'unit))) (ret_both (tt : 'unit)) in
    letb tally loc(tally_loc) := ret_both (0 : int32) in
    letb curr loc(curr_loc) := f_field_zero (ret_both (tt : 'unit)) in
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : int32)) (f_end := cast_int (WS2 := _) n))) (fun i =>
      ssp (fun _ =>
        letb _ := ifb (f_g_pow curr) =.? vote_result
        then letb _ := assign todo(term) in
        ret_both (tt : 'unit)
        else () in
        letb _ := assign todo(term) in
        solve_lift (ret_both (tt : 'unit)) : (both (*3*)(fset [curr_loc;tally_loc;vote_result_loc]) ((fset [])) 'unit))) (ret_both (tt : 'unit)) in
    letb tally_votes_state_ret loc(tally_votes_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    Result_Ok (solve_lift (prod_b (f_accept (ret_both (tt : 'unit)),tally_votes_state_ret))) : both (L1 :|: L2 :|: fset [curr_loc;tally_loc;tally_votes_state_ret_loc;vote_result_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState v_G (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.
