(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_lib.

Program Definition random_oracle_init {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 (unit)) : both (L1) (I1) (unit) :=
  tt.
Fail Next Obligation.

Definition t_GCanvas : choice_type :=
  (nseq int8 TODO: Int.to_string length × t_Sign × 'bool).
Equations Build_t_GCanvas {L : {fset Location}} {I : Interface} (f_b : both L I (nseq int8 TODO: Int.to_string length)) (f_sign : both L I (t_Sign)) (f_signed : both L I ('bool)) : both L I (t_GCanvas) :=
  Build_t_GCanvas f_b f_sign f_signed  :=
    bind_both f_signed (fun f_signed =>
      bind_both f_sign (fun f_sign =>
        bind_both f_b (fun f_b =>
          ret_both f_b f_sign f_signed))) : both L I (t_GCanvas).
Fail Next Obligation.

Program Definition max_under_impl_16 : both (fset []) ([interface ]) (t_Output) :=
  ((from i32(1)) shift_left i32(384)) .- one.
Fail Next Obligation.

Program Definition max_value_under_impl_16 : both (fset []) ([interface ]) (t_GCanvas) :=
  from max_under_impl_16.
Fail Next Obligation.

(*item error backend*)

Program Definition from_literal_under_impl_16 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_GCanvas) :=
  letb big_x := (from x) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_16)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type GCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_16 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_GCanvas) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_16)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type GCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition pow2_under_impl_16 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_GCanvas) :=
  into ((from i32(1)) shift_left x).
Fail Next Obligation.

(*item error backend*)

#[global] Instance t_GCanvas_t_From : t_From t_GCanvas t_BigUint := {
  from (x : t_BigUint) := from (from x);
}.

#[global] Instance t_GCanvas_t_From : t_From t_GCanvas t_BigInt := {
  from (x : t_BigInt) := letb max_value := (max_under_impl_16) : both _ _ (t_BigInt) in
  letb _ := (ifb not (x <=.? max_value)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type GCanvas!])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb '(sign,repr) := (to_bytes_be_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letb _ := (ifb andb (sign =.? Sign_Minus) (not false)
    then letb 'tt := (never_to_any (begin_panic Trying to convert a negative number into an unsigned integer!)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb _ := (ifb (len_under_impl_1 repr) >.? ((i32(384) .+ i32(7)) ./ i32(8))
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type GCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm out loc(out_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize out)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl_1 repr)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (out),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(repr)))))),
    )) : both _ _ (unit) in
  Build_t_GCanvas outsignfalse;
}.

#[global] Instance t_GCanvas_t_Default : t_Default t_GCanvas := {
  default := Build_t_GCanvas (repeat i8(0) i32(48))Sign_Plusfalse;
}.

#[global] Instance t_GCanvas_t_Into : t_Into t_GCanvas t_BigInt := {
  into (self : t_GCanvas) := from_bytes_be_under_impl_24 (f_sign self) (unsize (f_b self));
}.

#[global] Instance t_GCanvas_t_Into : t_Into t_GCanvas t_BigUint := {
  into (self : t_GCanvas) := from_bytes_be_under_impl_18 (unsize (f_b self));
}.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*item error backend*)

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 1%nat).
Program Definition from_be_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  Build_t_GCanvas reprSign_Plusfalse.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 2%nat).
Program Definition from_le_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  into (from_bytes_le_under_impl_24 Sign_Plus (unsize repr)).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_GCanvas)) : both (L1) (I1) (nseq int8 TODO: Int.to_string length) :=
  f_b self.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 3%nat).
Program Definition to_le_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_GCanvas)) : both (L1 :|: fset [repr_loc]) (I1) (nseq int8 TODO: Int.to_string length) :=
  letb x := (from_bytes_be_under_impl_24 Sign_Plus (unsize (f_b self))) : both _ _ (t_BigInt) in
  letb '(_,x_s) := (to_bytes_le_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: 0,
                f_end: alloc::vec::len_under_impl_1(&(x_s)),
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(x_s)))))),
    )) : both _ _ (unit) in
  repr.
Fail Next Obligation.

Program Definition comp_eq_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a =.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_GCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_ne_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <> b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_GCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gte_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >=.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_GCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gt_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_GCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lte_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <=.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_GCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lt_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_GCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition inv_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (modval : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_GCanvas) :=
  letb biguintmodval := (into modval) : both _ _ (t_BigInt) in
  letb m := (biguintmodval .- (from i32(2))) : both _ _ (t_Output) in
  letb s := (into self) : both _ _ (t_BigInt) in
  into (modpow_under_impl_24 s m biguintmodval).
Fail Next Obligation.

Program Definition pow_felem_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_GCanvas)) (exp : both L2 I2 (t_GCanvas)) (modval : both L3 I3 (t_GCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_GCanvas) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into exp) : both _ _ (t_BigInt) in
  letb m := (into modval) : both _ _ (t_BigInt) in
  letb c := (modpow_under_impl_24 a b m) : both _ _ (t_BigInt) in
  into c.
Fail Next Obligation.

Program Definition pow_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_GCanvas)) (exp : both L2 I2 (int128)) (modval : both L3 I3 (t_GCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_GCanvas) :=
  pow_felem_under_impl_27 self (into (from exp)) modval.
Fail Next Obligation.

Program Definition rem_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (n : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  self .% n.
Fail Next Obligation.

#[global] Instance t_GCanvas_t_Add : t_Add t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  add (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_16
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded addition overflow for type GCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_GCanvas_t_Sub : t_Sub t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  sub (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (ifb f_signed self
    then a .- b
    else unwrap_or_else_under_impl (checked_sub_under_impl_24 a b) (
        never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded substraction underflow for type GCanvas])) (unsize none_under_impl_1))))) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_GCanvas_t_Mul : t_Mul t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  mul (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_16
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded multiplication overflow for type GCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_GCanvas_t_Div : t_Div t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  div (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type GCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a ./ b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_GCanvas_t_Rem : t_Rem t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  rem (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type GCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a .% b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_GCanvas_t_Not : t_Not t_GCanvas := {
  t_Output := t_GCanvas;
  not (self : t_GCanvas) := never_to_any (panic not implemented);
}.

#[global] Instance t_GCanvas_t_BitOr : t_BitOr t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  bitor (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .| b);
}.

#[global] Instance t_GCanvas_t_BitXor : t_BitXor t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  bitxor (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .^ b);
}.

#[global] Instance t_GCanvas_t_BitAnd : t_BitAnd t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  bitand (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .& b);
}.

#[global] Instance t_GCanvas_t_Shr : t_Shr t_GCanvas uint_size := {
  t_Output := t_GCanvas;
  shr (self : t_GCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_right b);
}.

#[global] Instance t_GCanvas_t_Shl : t_Shl t_GCanvas uint_size := {
  t_Output := t_GCanvas;
  shl (self : t_GCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_left b);
}.

#[global] Instance t_GCanvas_t_PartialEq : t_PartialEq t_GCanvas t_GCanvas := {
  eq (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  a =.? b;
}.

#[global] Instance t_GCanvas_t_Eq : t_Eq t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_PartialOrd : t_PartialOrd t_GCanvas t_GCanvas := {
  partial_cmp (self : t_GCanvas) (other : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into other) : both _ _ (t_BigInt) in
  partial_cmp a b;
}.

#[global] Instance t_GCanvas_t_Ord : t_Ord t_GCanvas := {
  cmp (self : t_GCanvas) (other : t_GCanvas) := unwrap_under_impl (partial_cmp self other);
}.

Program Definition from_byte_seq_be_under_impl_8 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x)))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_8 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x)))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_8 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_GCanvas)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (unsize (to_be_bytes_under_impl_15 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

#[global] Instance t_GCanvas_t_NumericCopy : t_NumericCopy t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_UnsignedInteger : t_UnsignedInteger t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_Integer : t_Integer t_GCanvas := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_16 i128(0);
  ONE := from_literal_under_impl_16 i128(1);
  TWO := from_literal_under_impl_16 i128(2);
  from_literal (val : int128) := from_literal_under_impl_16 val;
  from_hex_string (s : t_String) := from_hex_under_impl_15 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_GCanvas) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_GCanvas) (b : t_GCanvas) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_16 (not (i128(1) shift_left i))) : both _ _ (t_GCanvas) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_GCanvas) (pos : uint_size) (y : t_GCanvas) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_GCanvas) in
  set_bit self b pos;
  rotate_left (self : t_GCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_GCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_GCanvas_t_ModNumeric : t_ModNumeric t_GCanvas := {
  sub_mod (self : t_GCanvas) (rhs : t_GCanvas) (n : t_GCanvas) := (self .- rhs) .% n;
  add_mod (self : t_GCanvas) (rhs : t_GCanvas) (n : t_GCanvas) := (self .+ rhs) .% n;
  mul_mod (self : t_GCanvas) (rhs : t_GCanvas) (n : t_GCanvas) := (self .* rhs) .% n;
  pow_mod (self : t_GCanvas) (exp : t_GCanvas) (n : t_GCanvas) := pow_felem_under_impl_27 self exp n;
  modulo (self : t_GCanvas) (n : t_GCanvas) := self .% n;
  signed_modulo (self : t_GCanvas) (n : t_GCanvas) := modulo self n;
  absolute (self : t_GCanvas) := self;
}.

#[global] Instance t_GCanvas_t_Numeric : t_Numeric t_GCanvas := {
  max_val := max_value_under_impl_16;
  wrap_add (self : t_GCanvas) (rhs : t_GCanvas) := self .+ rhs;
  wrap_sub (self : t_GCanvas) (rhs : t_GCanvas) := self .- rhs;
  wrap_mul (self : t_GCanvas) (rhs : t_GCanvas) := self .* rhs;
  wrap_div (self : t_GCanvas) (rhs : t_GCanvas) := self ./ rhs;
  exp (self : t_GCanvas) (exp : int32) := pow_under_impl_27 self (into exp) max_val;
  pow_self (self : t_GCanvas) (exp : t_GCanvas) := pow_felem_under_impl_27 self (into exp) max_val;
  divide (self : t_GCanvas) (rhs : t_GCanvas) := self ./ rhs;
  inv (self : t_GCanvas) (n : t_GCanvas) := inv_under_impl_27 self n;
  equal (self : t_GCanvas) (other : t_GCanvas) := self =.? other;
  greater_than (self : t_GCanvas) (other : t_GCanvas) := self >.? other;
  greater_than_or_equal (self : t_GCanvas) (other : t_GCanvas) := self >=.? other;
  less_than (self : t_GCanvas) (other : t_GCanvas) := self <.? other;
  less_than_or_equal (self : t_GCanvas) (other : t_GCanvas) := self >=.? other;
  not_equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb not (equal self other)
  then max_val
  else from_literal_under_impl_16 i128(0);
  equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb equal self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  greater_than_bm (self : t_GCanvas) (other : t_GCanvas) := ifb greater_than self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  greater_than_or_equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb greater_than_or_equal self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  less_than_bm (self : t_GCanvas) (other : t_GCanvas) := ifb less_than self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  less_than_or_equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb less_than_or_equal self other
  then max_val
  else from_literal_under_impl_16 i128(0);
}.

Definition t_G : choice_type :=
  (t_GCanvas).
Equations Build_t_G {L : {fset Location}} {I : Interface} (0 : both L I (t_GCanvas)) : both L I (t_G) :=
  Build_t_G 0  :=
    bind_both 0 (fun 0 =>
      ret_both 0) : both L I (t_G).
Fail Next Obligation.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

#[global] Instance t_G_t_From : t_From t_G t_GCanvas := {
  from (x : t_GCanvas) := G (rem_under_impl_27 x (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab));
}.

#[global] Instance t_G_t_Into : t_Into t_G t_GCanvas := {
  into (self : t_G) := 0 self;
}.

Program Definition from_canvas_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_GCanvas)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  G (rem_under_impl_27 x (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)).
Fail Next Obligation.

Program Definition into_canvas_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_GCanvas) :=
  0 self.
Fail Next Obligation.

Program Definition max_under_impl_64 : both (fset [x_loc]) ([interface ]) (t_GCanvas) :=
  from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab.
Fail Next Obligation.

Program Definition declassify_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_BigInt) :=
  letb a := (into self) : both _ _ (t_GCanvas) in
  into a.
Fail Next Obligation.

(*item error backend*)

Program Definition from_be_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  into (from_be_bytes_under_impl_15 v).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_be_bytes_under_impl_15 (into self))).
Fail Next Obligation.

Program Definition from_le_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  into (from_le_bytes_under_impl_15 v).
Fail Next Obligation.

Program Definition to_le_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [repr_loc]) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_le_bytes_under_impl_15 (into self))).
Fail Next Obligation.

Program Definition bit_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (i : both L2 I2 (uint_size)) : both (L1:|:L2) (I1:|:I2) ('bool) :=
  bit_under_impl_16 (into self) i.
Fail Next Obligation.

Program Definition from_literal_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  letb big_x := (from x) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_64)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type G])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  G (into big_x).
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_64)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type G])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  G (into big_x).
Fail Next Obligation.

Program Definition comp_eq_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  letb x := (into self) : both _ _ (t_GCanvas) in
  into (comp_eq_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_ne_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  letb x := (into self) : both _ _ (t_GCanvas) in
  into (comp_ne_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gte_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  letb x := (into self) : both _ _ (t_GCanvas) in
  into (comp_gte_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gt_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  letb x := (into self) : both _ _ (t_GCanvas) in
  into (comp_gt_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lte_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  letb x := (into self) : both _ _ (t_GCanvas) in
  into (comp_lte_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lt_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  letb x := (into self) : both _ _ (t_GCanvas) in
  into (comp_lt_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition neg_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  letb mod_val := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigInt) in
  letb s := (into self) : both _ _ (t_GCanvas) in
  letb s := (into s) : both _ _ (t_BigInt) in
  letb result := (into (mod_val .- s)) : both _ _ (t_GCanvas) in
  into result.
Fail Next Obligation.

#[global] Instance t_G_t_PartialOrd : t_PartialOrd t_G t_G := {
  partial_cmp (self : t_G) (other : t_G) := Option_Some (cmp self other);
}.

#[global] Instance t_G_t_Ord : t_Ord t_G := {
  cmp (self : t_G) (other : t_G) := cmp (0 self) (0 other);
}.

#[global] Instance t_G_t_PartialEq : t_PartialEq t_G t_G := {
  eq (self : t_G) (other : t_G) := (0 self) =.? (0 other);
}.

#[global] Instance t_G_t_Eq : t_Eq t_G := {
}.

#[global] Instance t_G_t_Add : t_Add t_G t_G := {
  t_Output := t_G;
  add (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  into d;
}.

#[global] Instance t_G_t_Sub : t_Sub t_G t_G := {
  t_Output := t_G;
  sub (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb c := (ifb b >.? a
    then ((clone max) .- b) .+ a
    else a .- b) : both _ _ (t_Output) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  into d;
}.

#[global] Instance t_G_t_Mul : t_Mul t_G t_G := {
  t_Output := t_G;
  mul (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  into d;
}.

#[global] Instance t_G_t_Div : t_Div t_G t_G := {
  t_Output := t_G;
  div (self : t_G) (rhs : t_G) := self .* (inv_under_impl_58 rhs);
}.

#[global] Instance t_G_t_Rem : t_Rem t_G t_G := {
  t_Output := t_G;
  rem (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .% b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  into d;
}.

#[global] Instance t_G_t_Not : t_Not t_G := {
  t_Output := t_G;
  not (self : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  into (not a);
}.

#[global] Instance t_G_t_BitOr : t_BitOr t_G t_G := {
  t_Output := t_G;
  bitor (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  into (a .| b);
}.

#[global] Instance t_G_t_BitXor : t_BitXor t_G t_G := {
  t_Output := t_G;
  bitxor (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  into (a .^ b);
}.

#[global] Instance t_G_t_BitAnd : t_BitAnd t_G t_G := {
  t_Output := t_G;
  bitand (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  into (a .& b);
}.

#[global] Instance t_G_t_Shr : t_Shr t_G uint_size := {
  t_Output := t_G;
  shr (self : t_G) (rhs : uint_size) := letb a := (into self) : both _ _ (t_GCanvas) in
  into (a shift_right rhs);
}.

#[global] Instance t_G_t_Shl : t_Shl t_G uint_size := {
  t_Output := t_G;
  shl (self : t_G) (rhs : uint_size) := letb a := (into self) : both _ _ (t_GCanvas) in
  into (a shift_left rhs);
}.

Program Definition inv_under_impl_58 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  letb base := (into self) : both _ _ (t_GCanvas) in
  into (inv_under_impl_27 base max_under_impl_64).
Fail Next Obligation.

Program Definition pow_felem_under_impl_58 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (exp : both L2 I2 (t_G)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_G) :=
  letb base := (into self) : both _ _ (t_GCanvas) in
  into (pow_felem_under_impl_27 base (into exp) max_under_impl_64).
Fail Next Obligation.

Program Definition pow_under_impl_58 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (exp : both L2 I2 (int128)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_G) :=
  letb base := (into self) : both _ _ (t_GCanvas) in
  into (pow_under_impl_27 base exp max_under_impl_64).
Fail Next Obligation.

Program Definition pow2_under_impl_58 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_G) :=
  into (pow2_under_impl_16 x).
Fail Next Obligation.

Program Definition from_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  into (from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  into (from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_be_bytes_under_impl_64 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_be_bytes_under_impl_64 self).
Fail Next Obligation.

Program Definition from_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  into (from_le_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  into (from_le_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_le_bytes_under_impl_64 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_le_bytes_under_impl_64 self).
Fail Next Obligation.

Program Definition from_secret_literal_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_U128)) : both (L1) (I1) (t_G) :=
  into (from_literal_under_impl_16 (declassify_under_impl_126 x)).
Fail Next Obligation.

#[global] Instance t_G_t_NumericCopy : t_NumericCopy t_G := {
}.

#[global] Instance t_G_t_UnsignedInteger : t_UnsignedInteger t_G := {
}.

#[global] Instance t_G_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_G := {
}.

#[global] Instance t_G_t_Integer : t_Integer t_G := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_64 i128(0);
  ONE := from_literal_under_impl_64 i128(1);
  TWO := from_literal_under_impl_64 i128(2);
  from_literal (val : int128) := from_literal_under_impl_64 val;
  from_hex_string (s : t_String) := from_hex_under_impl_64 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_G) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_G) (b : t_G) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_64 (not (i128(1) shift_left i))) : both _ _ (t_G) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_G) (pos : uint_size) (y : t_G) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_G) in
  set_bit self b pos;
  rotate_left (self : t_G) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_G) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_G_t_ModNumeric : t_ModNumeric t_G := {
  sub_mod (self : t_G) (rhs : t_G) (n : t_G) := self .- rhs;
  add_mod (self : t_G) (rhs : t_G) (n : t_G) := self .+ rhs;
  mul_mod (self : t_G) (rhs : t_G) (n : t_G) := self .* rhs;
  pow_mod (self : t_G) (exp : t_G) (n : t_G) := pow_felem_under_impl_58 self exp;
  modulo (self : t_G) (n : t_G) := self .% n;
  signed_modulo (self : t_G) (n : t_G) := modulo self n;
  absolute (self : t_G) := self;
}.

#[global] Instance t_G_t_Numeric : t_Numeric t_G := {
  max_val := into (max_under_impl_64 .- (from_literal_under_impl_16 i128(1)));
  wrap_add (self : t_G) (rhs : t_G) := self .+ rhs;
  wrap_sub (self : t_G) (rhs : t_G) := self .- rhs;
  wrap_mul (self : t_G) (rhs : t_G) := self .* rhs;
  wrap_div (self : t_G) (rhs : t_G) := self ./ rhs;
  exp (self : t_G) (exp : int32) := pow_under_impl_58 self (into exp);
  pow_self (self : t_G) (exp : t_G) := pow_felem_under_impl_58 self exp;
  divide (self : t_G) (rhs : t_G) := self ./ rhs;
  inv (self : t_G) (n : t_G) := inv_under_impl_58 self;
  equal (self : t_G) (other : t_G) := self =.? other;
  greater_than (self : t_G) (other : t_G) := self >.? other;
  greater_than_or_equal (self : t_G) (other : t_G) := self >=.? other;
  less_than (self : t_G) (other : t_G) := self <.? other;
  less_than_or_equal (self : t_G) (other : t_G) := self <=.? other;
  not_equal_bm (self : t_G) (other : t_G) := ifb self <> other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  equal_bm (self : t_G) (other : t_G) := ifb self =.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_bm (self : t_G) (other : t_G) := ifb self >.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_or_equal_bm (self : t_G) (other : t_G) := ifb self >=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_bm (self : t_G) (other : t_G) := ifb self <.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_or_equal_bm (self : t_G) (other : t_G) := ifb self <=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
}.

Definition t_QCanvas : choice_type :=
  (nseq int8 TODO: Int.to_string length × t_Sign × 'bool).
Equations Build_t_QCanvas {L : {fset Location}} {I : Interface} (f_b : both L I (nseq int8 TODO: Int.to_string length)) (f_sign : both L I (t_Sign)) (f_signed : both L I ('bool)) : both L I (t_QCanvas) :=
  Build_t_QCanvas f_b f_sign f_signed  :=
    bind_both f_signed (fun f_signed =>
      bind_both f_sign (fun f_sign =>
        bind_both f_b (fun f_b =>
          ret_both f_b f_sign f_signed))) : both L I (t_QCanvas).
Fail Next Obligation.

Program Definition max_under_impl_83 : both (fset []) ([interface ]) (t_Output) :=
  ((from i32(1)) shift_left i32(384)) .- one.
Fail Next Obligation.

Program Definition max_value_under_impl_83 : both (fset []) ([interface ]) (t_QCanvas) :=
  from max_under_impl_83.
Fail Next Obligation.

(*item error backend*)

Program Definition from_literal_under_impl_83 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_QCanvas) :=
  letb big_x := (from x) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_83)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type QCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_83 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_QCanvas) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_83)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type QCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition pow2_under_impl_83 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_QCanvas) :=
  into ((from i32(1)) shift_left x).
Fail Next Obligation.

(*item error backend*)

#[global] Instance t_QCanvas_t_From : t_From t_QCanvas t_BigUint := {
  from (x : t_BigUint) := from (from x);
}.

#[global] Instance t_QCanvas_t_From : t_From t_QCanvas t_BigInt := {
  from (x : t_BigInt) := letb max_value := (max_under_impl_83) : both _ _ (t_BigInt) in
  letb _ := (ifb not (x <=.? max_value)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type QCanvas!])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb '(sign,repr) := (to_bytes_be_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letb _ := (ifb andb (sign =.? Sign_Minus) (not false)
    then letb 'tt := (never_to_any (begin_panic Trying to convert a negative number into an unsigned integer!)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb _ := (ifb (len_under_impl_1 repr) >.? ((i32(384) .+ i32(7)) ./ i32(8))
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type QCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm out loc(out_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize out)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl_1 repr)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (out),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(repr)))))),
    )) : both _ _ (unit) in
  Build_t_QCanvas outsignfalse;
}.

#[global] Instance t_QCanvas_t_Default : t_Default t_QCanvas := {
  default := Build_t_QCanvas (repeat i8(0) i32(48))Sign_Plusfalse;
}.

#[global] Instance t_QCanvas_t_Into : t_Into t_QCanvas t_BigInt := {
  into (self : t_QCanvas) := from_bytes_be_under_impl_24 (f_sign self) (unsize (f_b self));
}.

#[global] Instance t_QCanvas_t_Into : t_Into t_QCanvas t_BigUint := {
  into (self : t_QCanvas) := from_bytes_be_under_impl_18 (unsize (f_b self));
}.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*item error backend*)

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 5%nat).
Program Definition from_be_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_QCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  Build_t_QCanvas reprSign_Plusfalse.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 6%nat).
Program Definition from_le_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_QCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  into (from_bytes_le_under_impl_24 Sign_Plus (unsize repr)).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_QCanvas)) : both (L1) (I1) (nseq int8 TODO: Int.to_string length) :=
  f_b self.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 7%nat).
Program Definition to_le_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_QCanvas)) : both (L1 :|: fset [repr_loc]) (I1) (nseq int8 TODO: Int.to_string length) :=
  letb x := (from_bytes_be_under_impl_24 Sign_Plus (unsize (f_b self))) : both _ _ (t_BigInt) in
  letb '(_,x_s) := (to_bytes_le_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: 0,
                f_end: alloc::vec::len_under_impl_1(&(x_s)),
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(x_s)))))),
    )) : both _ _ (unit) in
  repr.
Fail Next Obligation.

Program Definition comp_eq_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (rhs : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a =.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_QCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_ne_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (rhs : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <> b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_QCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gte_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (rhs : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >=.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_QCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gt_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (rhs : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_QCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lte_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (rhs : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <=.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_QCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lt_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (rhs : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_QCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition inv_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (modval : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_QCanvas) :=
  letb biguintmodval := (into modval) : both _ _ (t_BigInt) in
  letb m := (biguintmodval .- (from i32(2))) : both _ _ (t_Output) in
  letb s := (into self) : both _ _ (t_BigInt) in
  into (modpow_under_impl_24 s m biguintmodval).
Fail Next Obligation.

Program Definition pow_felem_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_QCanvas)) (exp : both L2 I2 (t_QCanvas)) (modval : both L3 I3 (t_QCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_QCanvas) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into exp) : both _ _ (t_BigInt) in
  letb m := (into modval) : both _ _ (t_BigInt) in
  letb c := (modpow_under_impl_24 a b m) : both _ _ (t_BigInt) in
  into c.
Fail Next Obligation.

Program Definition pow_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_QCanvas)) (exp : both L2 I2 (int128)) (modval : both L3 I3 (t_QCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_QCanvas) :=
  pow_felem_under_impl_94 self (into (from exp)) modval.
Fail Next Obligation.

Program Definition rem_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QCanvas)) (n : both L2 I2 (t_QCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  self .% n.
Fail Next Obligation.

#[global] Instance t_QCanvas_t_Add : t_Add t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  add (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_83
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded addition overflow for type QCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_QCanvas_t_Sub : t_Sub t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  sub (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (ifb f_signed self
    then a .- b
    else unwrap_or_else_under_impl (checked_sub_under_impl_24 a b) (
        never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded substraction underflow for type QCanvas])) (unsize none_under_impl_1))))) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_QCanvas_t_Mul : t_Mul t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  mul (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_83
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded multiplication overflow for type QCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_QCanvas_t_Div : t_Div t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  div (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type QCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a ./ b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_QCanvas_t_Rem : t_Rem t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  rem (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type QCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a .% b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_QCanvas_t_Not : t_Not t_QCanvas := {
  t_Output := t_QCanvas;
  not (self : t_QCanvas) := never_to_any (panic not implemented);
}.

#[global] Instance t_QCanvas_t_BitOr : t_BitOr t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  bitor (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .| b);
}.

#[global] Instance t_QCanvas_t_BitXor : t_BitXor t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  bitxor (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .^ b);
}.

#[global] Instance t_QCanvas_t_BitAnd : t_BitAnd t_QCanvas t_QCanvas := {
  t_Output := t_QCanvas;
  bitand (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .& b);
}.

#[global] Instance t_QCanvas_t_Shr : t_Shr t_QCanvas uint_size := {
  t_Output := t_QCanvas;
  shr (self : t_QCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_right b);
}.

#[global] Instance t_QCanvas_t_Shl : t_Shl t_QCanvas uint_size := {
  t_Output := t_QCanvas;
  shl (self : t_QCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_left b);
}.

#[global] Instance t_QCanvas_t_PartialEq : t_PartialEq t_QCanvas t_QCanvas := {
  eq (self : t_QCanvas) (rhs : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  a =.? b;
}.

#[global] Instance t_QCanvas_t_Eq : t_Eq t_QCanvas := {
}.

#[global] Instance t_QCanvas_t_PartialOrd : t_PartialOrd t_QCanvas t_QCanvas := {
  partial_cmp (self : t_QCanvas) (other : t_QCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into other) : both _ _ (t_BigInt) in
  partial_cmp a b;
}.

#[global] Instance t_QCanvas_t_Ord : t_Ord t_QCanvas := {
  cmp (self : t_QCanvas) (other : t_QCanvas) := unwrap_under_impl (partial_cmp self other);
}.

Program Definition from_byte_seq_be_under_impl_75 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_QCanvas) :=
  from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x)))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_75 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_QCanvas) :=
  from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x)))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_75 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_QCanvas)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (unsize (to_be_bytes_under_impl_82 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

#[global] Instance t_QCanvas_t_NumericCopy : t_NumericCopy t_QCanvas := {
}.

#[global] Instance t_QCanvas_t_UnsignedInteger : t_UnsignedInteger t_QCanvas := {
}.

#[global] Instance t_QCanvas_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_QCanvas := {
}.

#[global] Instance t_QCanvas_t_Integer : t_Integer t_QCanvas := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_83 i128(0);
  ONE := from_literal_under_impl_83 i128(1);
  TWO := from_literal_under_impl_83 i128(2);
  from_literal (val : int128) := from_literal_under_impl_83 val;
  from_hex_string (s : t_String) := from_hex_under_impl_82 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_QCanvas) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_QCanvas) (b : t_QCanvas) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_83 (not (i128(1) shift_left i))) : both _ _ (t_QCanvas) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_QCanvas) (pos : uint_size) (y : t_QCanvas) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_QCanvas) in
  set_bit self b pos;
  rotate_left (self : t_QCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_QCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_QCanvas_t_ModNumeric : t_ModNumeric t_QCanvas := {
  sub_mod (self : t_QCanvas) (rhs : t_QCanvas) (n : t_QCanvas) := (self .- rhs) .% n;
  add_mod (self : t_QCanvas) (rhs : t_QCanvas) (n : t_QCanvas) := (self .+ rhs) .% n;
  mul_mod (self : t_QCanvas) (rhs : t_QCanvas) (n : t_QCanvas) := (self .* rhs) .% n;
  pow_mod (self : t_QCanvas) (exp : t_QCanvas) (n : t_QCanvas) := pow_felem_under_impl_94 self exp n;
  modulo (self : t_QCanvas) (n : t_QCanvas) := self .% n;
  signed_modulo (self : t_QCanvas) (n : t_QCanvas) := modulo self n;
  absolute (self : t_QCanvas) := self;
}.

#[global] Instance t_QCanvas_t_Numeric : t_Numeric t_QCanvas := {
  max_val := max_value_under_impl_83;
  wrap_add (self : t_QCanvas) (rhs : t_QCanvas) := self .+ rhs;
  wrap_sub (self : t_QCanvas) (rhs : t_QCanvas) := self .- rhs;
  wrap_mul (self : t_QCanvas) (rhs : t_QCanvas) := self .* rhs;
  wrap_div (self : t_QCanvas) (rhs : t_QCanvas) := self ./ rhs;
  exp (self : t_QCanvas) (exp : int32) := pow_under_impl_94 self (into exp) max_val;
  pow_self (self : t_QCanvas) (exp : t_QCanvas) := pow_felem_under_impl_94 self (into exp) max_val;
  divide (self : t_QCanvas) (rhs : t_QCanvas) := self ./ rhs;
  inv (self : t_QCanvas) (n : t_QCanvas) := inv_under_impl_94 self n;
  equal (self : t_QCanvas) (other : t_QCanvas) := self =.? other;
  greater_than (self : t_QCanvas) (other : t_QCanvas) := self >.? other;
  greater_than_or_equal (self : t_QCanvas) (other : t_QCanvas) := self >=.? other;
  less_than (self : t_QCanvas) (other : t_QCanvas) := self <.? other;
  less_than_or_equal (self : t_QCanvas) (other : t_QCanvas) := self >=.? other;
  not_equal_bm (self : t_QCanvas) (other : t_QCanvas) := ifb not (equal self other)
  then max_val
  else from_literal_under_impl_83 i128(0);
  equal_bm (self : t_QCanvas) (other : t_QCanvas) := ifb equal self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  greater_than_bm (self : t_QCanvas) (other : t_QCanvas) := ifb greater_than self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  greater_than_or_equal_bm (self : t_QCanvas) (other : t_QCanvas) := ifb greater_than_or_equal self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  less_than_bm (self : t_QCanvas) (other : t_QCanvas) := ifb less_than self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  less_than_or_equal_bm (self : t_QCanvas) (other : t_QCanvas) := ifb less_than_or_equal self other
  then max_val
  else from_literal_under_impl_83 i128(0);
}.

Definition t_Q : choice_type :=
  (t_QCanvas).
Equations Build_t_Q {L : {fset Location}} {I : Interface} (0 : both L I (t_QCanvas)) : both L I (t_Q) :=
  Build_t_Q 0  :=
    bind_both 0 (fun 0 =>
      ret_both 0) : both L I (t_Q).
Fail Next Obligation.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

#[global] Instance t_Q_t_From : t_From t_Q t_QCanvas := {
  from (x : t_QCanvas) := Q (rem_under_impl_94 x (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab));
}.

#[global] Instance t_Q_t_Into : t_Into t_Q t_QCanvas := {
  into (self : t_Q) := 0 self;
}.

Program Definition from_canvas_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_QCanvas)) : both (L1 :|: fset [x_loc]) (I1) (t_Q) :=
  Q (rem_under_impl_94 x (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)).
Fail Next Obligation.

Program Definition into_canvas_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1) (I1) (t_QCanvas) :=
  0 self.
Fail Next Obligation.

Program Definition max_under_impl_131 : both (fset [x_loc]) ([interface ]) (t_QCanvas) :=
  from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab.
Fail Next Obligation.

Program Definition declassify_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1) (I1) (t_BigInt) :=
  letb a := (into self) : both _ _ (t_QCanvas) in
  into a.
Fail Next Obligation.

(*item error backend*)

Program Definition from_be_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_Q) :=
  into (from_be_bytes_under_impl_82 v).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_be_bytes_under_impl_82 (into self))).
Fail Next Obligation.

Program Definition from_le_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_Q) :=
  into (from_le_bytes_under_impl_82 v).
Fail Next Obligation.

Program Definition to_le_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1 :|: fset [repr_loc]) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_le_bytes_under_impl_82 (into self))).
Fail Next Obligation.

Program Definition bit_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (i : both L2 I2 (uint_size)) : both (L1:|:L2) (I1:|:I2) ('bool) :=
  bit_under_impl_83 (into self) i.
Fail Next Obligation.

Program Definition from_literal_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_Q) :=
  letb big_x := (from x) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_131)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type Q])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  Q (into big_x).
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_Q) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_131)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type Q])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  Q (into big_x).
Fail Next Obligation.

Program Definition comp_eq_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (rhs : both L2 I2 (t_Q)) : both (L1:|:L2) (I1:|:I2) (t_Q) :=
  letb x := (into self) : both _ _ (t_QCanvas) in
  into (comp_eq_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_ne_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (rhs : both L2 I2 (t_Q)) : both (L1:|:L2) (I1:|:I2) (t_Q) :=
  letb x := (into self) : both _ _ (t_QCanvas) in
  into (comp_ne_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gte_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (rhs : both L2 I2 (t_Q)) : both (L1:|:L2) (I1:|:I2) (t_Q) :=
  letb x := (into self) : both _ _ (t_QCanvas) in
  into (comp_gte_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gt_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (rhs : both L2 I2 (t_Q)) : both (L1:|:L2) (I1:|:I2) (t_Q) :=
  letb x := (into self) : both _ _ (t_QCanvas) in
  into (comp_gt_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lte_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (rhs : both L2 I2 (t_Q)) : both (L1:|:L2) (I1:|:I2) (t_Q) :=
  letb x := (into self) : both _ _ (t_QCanvas) in
  into (comp_lte_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lt_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (rhs : both L2 I2 (t_Q)) : both (L1:|:L2) (I1:|:I2) (t_Q) :=
  letb x := (into self) : both _ _ (t_QCanvas) in
  into (comp_lt_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition neg_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1 :|: fset [x_loc]) (I1) (t_Q) :=
  letb mod_val := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigInt) in
  letb s := (into self) : both _ _ (t_QCanvas) in
  letb s := (into s) : both _ _ (t_BigInt) in
  letb result := (into (mod_val .- s)) : both _ _ (t_QCanvas) in
  into result.
Fail Next Obligation.

#[global] Instance t_Q_t_PartialOrd : t_PartialOrd t_Q t_Q := {
  partial_cmp (self : t_Q) (other : t_Q) := Option_Some (cmp self other);
}.

#[global] Instance t_Q_t_Ord : t_Ord t_Q := {
  cmp (self : t_Q) (other : t_Q) := cmp (0 self) (0 other);
}.

#[global] Instance t_Q_t_PartialEq : t_PartialEq t_Q t_Q := {
  eq (self : t_Q) (other : t_Q) := (0 self) =.? (0 other);
}.

#[global] Instance t_Q_t_Eq : t_Eq t_Q := {
}.

#[global] Instance t_Q_t_Add : t_Add t_Q t_Q := {
  t_Output := t_Q;
  add (self : t_Q) (rhs : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  letb b := (into rhs) : both _ _ (t_QCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QCanvas) in
  into d;
}.

#[global] Instance t_Q_t_Sub : t_Sub t_Q t_Q := {
  t_Output := t_Q;
  sub (self : t_Q) (rhs : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  letb b := (into rhs) : both _ _ (t_QCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb c := (ifb b >.? a
    then ((clone max) .- b) .+ a
    else a .- b) : both _ _ (t_Output) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QCanvas) in
  into d;
}.

#[global] Instance t_Q_t_Mul : t_Mul t_Q t_Q := {
  t_Output := t_Q;
  mul (self : t_Q) (rhs : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  letb b := (into rhs) : both _ _ (t_QCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QCanvas) in
  into d;
}.

#[global] Instance t_Q_t_Div : t_Div t_Q t_Q := {
  t_Output := t_Q;
  div (self : t_Q) (rhs : t_Q) := self .* (inv_under_impl_125 rhs);
}.

#[global] Instance t_Q_t_Rem : t_Rem t_Q t_Q := {
  t_Output := t_Q;
  rem (self : t_Q) (rhs : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  letb b := (into rhs) : both _ _ (t_QCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .% b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QCanvas) in
  into d;
}.

#[global] Instance t_Q_t_Not : t_Not t_Q := {
  t_Output := t_Q;
  not (self : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  into (not a);
}.

#[global] Instance t_Q_t_BitOr : t_BitOr t_Q t_Q := {
  t_Output := t_Q;
  bitor (self : t_Q) (rhs : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  letb b := (into rhs) : both _ _ (t_QCanvas) in
  into (a .| b);
}.

#[global] Instance t_Q_t_BitXor : t_BitXor t_Q t_Q := {
  t_Output := t_Q;
  bitxor (self : t_Q) (rhs : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  letb b := (into rhs) : both _ _ (t_QCanvas) in
  into (a .^ b);
}.

#[global] Instance t_Q_t_BitAnd : t_BitAnd t_Q t_Q := {
  t_Output := t_Q;
  bitand (self : t_Q) (rhs : t_Q) := letb a := (into self) : both _ _ (t_QCanvas) in
  letb b := (into rhs) : both _ _ (t_QCanvas) in
  into (a .& b);
}.

#[global] Instance t_Q_t_Shr : t_Shr t_Q uint_size := {
  t_Output := t_Q;
  shr (self : t_Q) (rhs : uint_size) := letb a := (into self) : both _ _ (t_QCanvas) in
  into (a shift_right rhs);
}.

#[global] Instance t_Q_t_Shl : t_Shl t_Q uint_size := {
  t_Output := t_Q;
  shl (self : t_Q) (rhs : uint_size) := letb a := (into self) : both _ _ (t_QCanvas) in
  into (a shift_left rhs);
}.

Program Definition inv_under_impl_125 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1 :|: fset [x_loc]) (I1) (t_Q) :=
  letb base := (into self) : both _ _ (t_QCanvas) in
  into (inv_under_impl_94 base max_under_impl_131).
Fail Next Obligation.

Program Definition pow_felem_under_impl_125 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (exp : both L2 I2 (t_Q)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_Q) :=
  letb base := (into self) : both _ _ (t_QCanvas) in
  into (pow_felem_under_impl_94 base (into exp) max_under_impl_131).
Fail Next Obligation.

Program Definition pow_under_impl_125 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Q)) (exp : both L2 I2 (int128)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_Q) :=
  letb base := (into self) : both _ _ (t_QCanvas) in
  into (pow_under_impl_94 base exp max_under_impl_131).
Fail Next Obligation.

Program Definition pow2_under_impl_125 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_Q) :=
  into (pow2_under_impl_83 x).
Fail Next Obligation.

Program Definition from_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Q) :=
  into (from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Q) :=
  into (from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_be_bytes_under_impl_131 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_be_bytes_under_impl_131 self).
Fail Next Obligation.

Program Definition from_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Q) :=
  into (from_le_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Q) :=
  into (from_le_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_le_bytes_under_impl_131 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Q)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_le_bytes_under_impl_131 self).
Fail Next Obligation.

Program Definition from_secret_literal_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_U128)) : both (L1) (I1) (t_Q) :=
  into (from_literal_under_impl_83 (declassify_under_impl_126 x)).
Fail Next Obligation.

#[global] Instance t_Q_t_NumericCopy : t_NumericCopy t_Q := {
}.

#[global] Instance t_Q_t_UnsignedInteger : t_UnsignedInteger t_Q := {
}.

#[global] Instance t_Q_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_Q := {
}.

#[global] Instance t_Q_t_Integer : t_Integer t_Q := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_131 i128(0);
  ONE := from_literal_under_impl_131 i128(1);
  TWO := from_literal_under_impl_131 i128(2);
  from_literal (val : int128) := from_literal_under_impl_131 val;
  from_hex_string (s : t_String) := from_hex_under_impl_131 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_Q) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_Q) (b : t_Q) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_131 (not (i128(1) shift_left i))) : both _ _ (t_Q) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_Q) (pos : uint_size) (y : t_Q) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_Q) in
  set_bit self b pos;
  rotate_left (self : t_Q) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_Q) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_Q_t_ModNumeric : t_ModNumeric t_Q := {
  sub_mod (self : t_Q) (rhs : t_Q) (n : t_Q) := self .- rhs;
  add_mod (self : t_Q) (rhs : t_Q) (n : t_Q) := self .+ rhs;
  mul_mod (self : t_Q) (rhs : t_Q) (n : t_Q) := self .* rhs;
  pow_mod (self : t_Q) (exp : t_Q) (n : t_Q) := pow_felem_under_impl_125 self exp;
  modulo (self : t_Q) (n : t_Q) := self .% n;
  signed_modulo (self : t_Q) (n : t_Q) := modulo self n;
  absolute (self : t_Q) := self;
}.

#[global] Instance t_Q_t_Numeric : t_Numeric t_Q := {
  max_val := into (max_under_impl_131 .- (from_literal_under_impl_83 i128(1)));
  wrap_add (self : t_Q) (rhs : t_Q) := self .+ rhs;
  wrap_sub (self : t_Q) (rhs : t_Q) := self .- rhs;
  wrap_mul (self : t_Q) (rhs : t_Q) := self .* rhs;
  wrap_div (self : t_Q) (rhs : t_Q) := self ./ rhs;
  exp (self : t_Q) (exp : int32) := pow_under_impl_125 self (into exp);
  pow_self (self : t_Q) (exp : t_Q) := pow_felem_under_impl_125 self exp;
  divide (self : t_Q) (rhs : t_Q) := self ./ rhs;
  inv (self : t_Q) (n : t_Q) := inv_under_impl_125 self;
  equal (self : t_Q) (other : t_Q) := self =.? other;
  greater_than (self : t_Q) (other : t_Q) := self >.? other;
  greater_than_or_equal (self : t_Q) (other : t_Q) := self >=.? other;
  less_than (self : t_Q) (other : t_Q) := self <.? other;
  less_than_or_equal (self : t_Q) (other : t_Q) := self <=.? other;
  not_equal_bm (self : t_Q) (other : t_Q) := ifb self <> other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  equal_bm (self : t_Q) (other : t_Q) := ifb self =.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_bm (self : t_Q) (other : t_Q) := ifb self >.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_or_equal_bm (self : t_Q) (other : t_Q) := ifb self >=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_bm (self : t_Q) (other : t_Q) := ifb self <.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_or_equal_bm (self : t_Q) (other : t_Q) := ifb self <=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
}.

Notation t_Random := (t_G).

Notation t_Query := (t_G).

Program Definition sample_uniform : both (fset []) ([interface ]) (t_G) :=
  v_ONE.
Fail Next Obligation.

Require Import Std. (* as HashMap *)

Require Import Std.

Require Import Std. (* as Hash *)

Require Import Std. (* as Hasher *)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

Program Definition random_oracle_query {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (QUERIES : both L1 I1 (t_HashMap (t_G) (t_G) (t_RandomState))) (q : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) ((t_HashMap (t_G) (t_G) (t_RandomState) × t_G)) :=
  match get_under_impl_2 QUERIES q with
  | Option_Some r => prod_b(clone QUERIES,clone r)
  | Option_None  => letb r := (sample_uniform) : both _ _ (t_G) in
    letb '(todo_fresh_var,QUERIES_temp) := (insert_under_impl_2 QUERIES q r) : both _ _ ((t_Option (t_G) × t_HashMap (t_G) (t_G) (t_RandomState))) in
    letb QUERIES := (QUERIES_temp) : both _ _ (t_HashMap (t_G) (t_G) (t_RandomState)) in
    letb _ := (todo_fresh_var) : both _ _ (t_Option (t_G)) in
    prod_b(QUERIES,r)
  end.
Fail Next Obligation.
