(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Crypt Require Import jasmin_word.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(* Require Import Group. *)
(* Export Group. *)

(* Require Import Group_Ff. *)
(* Export Group_Ff. *)

(* Require Import Field. *)
(* Export Field. *)

(* Require Import Group. *)
(* Export Group. *)

(* Require Import Gt. *)
(* Export Gt. *)

(* Require Import PhantomData. *)
(* Export PhantomData. *)

Axiom rng_core : choice_type.
Axiom t_Choice : choice_type. (* ~ chOption *)

Class t_Scalar (v_Self : choice_type) := {
    t_Scalar_t_Add :> (t_Add v_Self v_Self) ;
    t_Scalar_t_Mul :> (t_Mul v_Self v_Self) ;
    f_ZERO_loc : {fset Location} ;
    f_ZERO : (forall {L1 I1}, both (L1 :|: f_ZERO_loc) I1 v_Self) ;
    f_ONE_loc : {fset Location} ;
    f_ONE : (forall {L1 I1}, both (L1 :|: f_ONE_loc) I1 v_Self) ;
  }.
Hint Unfold f_ZERO_loc : hacspec_hints.
Hint Unfold f_ONE_loc : hacspec_hints.

Class t_Group (v_Self : choice_type) := {
  f_Scalar : choice_type ;
  f_Scalar_t_Scalar :> (t_Scalar f_Scalar) ;
  f_Scalar_t_Sized :> (t_Sized f_Scalar) ;
  t_Group_t_Add :> (t_Add v_Self v_Self) ;
  t_Group_t_Mul :> (t_Mul v_Self f_Scalar) ;
  f_random_loc : {fset Location} ;
  f_random : (forall {L1 I1}, both L1 I1 rng_core -> both (L1 :|: f_random_loc) I1 v_Self) ;
  f_identity_loc : {fset Location} ;
  f_identity : (forall {L1 I1}, both L1 I1 'unit -> both (L1 :|: f_identity_loc) I1 v_Self) ;
  f_generator_loc : {fset Location} ;
  f_generator : (forall {L1 I1}, both L1 I1 'unit -> both (L1 :|: f_generator_loc) I1 v_Self) ;
  f_is_identity_loc : {fset Location} ;
  f_is_identity : (forall {L1 I1}, both L1 I1 v_Self -> both (L1 :|: f_is_identity_loc) I1 t_Choice) ;
  f_double_loc : {fset Location} ;
  f_double : (forall {L1 I1}, both L1 I1 v_Self -> both (L1 :|: f_double_loc) I1 v_Self) ;
}.
Hint Unfold f_random_loc : hacspec_hints.
Hint Unfold f_identity_loc : hacspec_hints.
Hint Unfold f_generator_loc : hacspec_hints.
Hint Unfold f_is_identity_loc : hacspec_hints.
Hint Unfold f_double_loc : hacspec_hints.

Axiom t_Gt_Scalar : choice_type.
Axiom t_Gt : choice_type.
Program Instance f_Scalar_t_Add : t_Add t_Gt_Scalar t_Gt_Scalar := { f_Output := t_Gt_Scalar; f_add_loc := fset [] ; }.
Admit Obligations.
Program Instance f_Scalar_t_Mul : t_Mul t_Gt_Scalar t_Gt_Scalar := { f_Output := t_Gt_Scalar; f_mul_loc := fset [] ; }.
Admit Obligations.
Program Instance f_Group_t_Add : t_Add t_Gt t_Gt := { f_Output := t_Gt; f_add_loc := fset [] ; }.
Admit Obligations.
Program Instance f_Group_t_Mul : t_Mul t_Gt t_Gt_Scalar := { f_Output := t_Gt; f_mul_loc := fset [] ; }.
Admit Obligations.
Program Instance t_Scalar_t_Scalar : t_Scalar t_Gt_Scalar := {
    f_ZERO_loc := fset [] ;
    f_ONE_loc := fset [] ;
    t_Scalar_t_Add := f_Scalar_t_Add ;
    t_Scalar_t_Mul := f_Scalar_t_Mul ;
  }.
Admit Obligations.
Program Instance t_Gt_Group : t_Group t_Gt := {
    f_Scalar := t_Gt_Scalar ;
    f_Scalar_t_Scalar := t_Scalar_t_Scalar ;
    t_Group_t_Add := f_Group_t_Add ;
    t_Group_t_Mul := f_Group_t_Mul ;
    f_random_loc := fset [] ;
    f_identity_loc := fset [] ;
    f_generator_loc := fset [] ;
    f_is_identity_loc := fset [] ;
    f_double_loc := fset [] ;
  }.
Admit Obligations.
Notation "'t_G'" := t_Gt.

Notation "'t_Z'" := (f_Scalar (t_Group := t_Gt_Group)).

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)
Check (f_add (t_Add := t_Group_t_Add (t_Group := t_Gt_Group)) _ _) : both _ _ t_Gt.
Check (f_mul (t_Mul := t_Group_t_Mul (t_Group := t_Gt_Group)) (_ : both _ _ t_Gt) (_ : both _ _ t_Gt_Scalar)) : both _ _ t_Gt.
Check ((_ : both _ _ int32) .+ _) : both _ _ int32.
Check ((_ : both _ _ t_Gt) .+ _) : both _ _ t_Gt.
Check ((_ : both _ _ t_Gt) .* (_  : both _ _ t_Gt_Scalar) : both _ _ t_Gt) .+ _ : both _ _ t_Gt.
Check (ret_both 1 :of0: int32) .+ (ret_both 4 :of0: int32) : both _ _ int32.

Ltac solve_ssprove_obligations :=
  repeat (
      intros ; autounfold with hacspec_hints ; autounfold ; normalize_fset ;
      solve [solve_match || now (apply fsubsetxx || apply fsub0set)
           | solve_in_mem (* TODO: add match goal *)
           | fset_equality (* TODO: add match goal *)
           | solve_in_fset (* TODO: add match goal *)
           | ssprove_valid'_2 ; (Tactics.program_simpl; fail)]).

Obligation Tactic := simpl ; solve_ssprove_obligations.

Equations compute_group_element_for_vote {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (xi : both L1 I1 (f_Scalar (t_Group := t_Gt_Group))) (vote : both L2 I2 'bool) (g_pow_yi : both L3 I3 t_Gt) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) t_Gt :=
  compute_group_element_for_vote xi vote g_pow_yi  :=
        solve_lift (
        ((g_pow_yi .* xi : both _ _ t_Gt)
          .+
          (
            (f_generator (ret_both (tt : 'unit)) : both _ _ t_Gt) .*
              (ifb vote
               then f_ONE
               else f_ZERO : both _ _ t_Gt_Scalar) : both _ _ t_Gt)) : both _ _ t_Gt) :
    both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) t_Gt.
Fail Next Obligation.

Obligation Tactic := solve_ssprove_obligations.


Equations hash {L1 : {fset Location}} {I1 : Interface} (v__inp : both L1 I1 (t_Vec t_Gt t_Global)) : both L1 I1 (f_Scalar) :=
  hash v__inp  :=
    solve_lift (f_ONE) : both L1 I1 f_Scalar.
Fail Next Obligation.

Definition prod1_loc {n : both (fset []) (fset []) uint_size} : Location :=
  (t_Gt;0%nat).
Definition prod2_loc {n : both (fset []) (fset []) uint_size} : Location :=
  (t_Gt;1%nat).
Equations compute_g_pow_yi {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {n : both (fset []) (fset []) uint_size} (i : both L1 I1 uint_size) (xis : both L2 I2 (nseq t_Gt (is_pure (n)))) : both (L1 :|: L2 :|: fset [prod1_loc (n := n);prod2_loc (n := n)]) (I1 :|: I2) t_Gt :=
  compute_g_pow_yi i xis  :=
    letb prod1 loc(prod1_loc) := f_identity (ret_both (tt : 'unit)) in
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := i))) (fun j =>
      ssp (fun _ =>
         assignb _ loc( prod1_loc ) := _ ; : (both (*1*)(L2:|:L1:|:fset [prod1_loc]) (I2:|:I1) 'unit))) (ret_both (tt : 'unit)) in
    letb prod2 loc(prod2_loc) := f_identity (ret_both (tt : 'unit)) in
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := i .+ (ret_both (1 : uint_size))) (f_end := n))) (fun j =>
      ssp (fun _ =>
        assignb _ loc( prod2_loc ) := _ ; : (both (*1*)(L2:|:L1:|:fset [prod2_loc]) (I2:|:I1) 'unit))) (ret_both (tt : 'unit)) in
    solve_lift (prod1 .- prod2) : both (L1 :|: L2 :|: fset [prod1_loc;prod2_loc]) (I1 :|: I2) t_Gt.
Fail Next Obligation.

Equations check_commitment {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi_yi_vi : both L1 I1 t_Gt) (commitment : both L2 I2 t_Scalar) : both (L1 :|: L2) (I1 :|: I2) 'bool :=
  check_commitment g_pow_xi_yi_vi commitment  :=
    solve_lift ((hash (impl__into_vec (unsize (box_new (array_from_list [g_pow_xi_yi_vi]))))) =.? commitment) : both (L1 :|: L2) (I1 :|: I2) 'bool.
Fail Next Obligation.

Equations commit_to {L1 : {fset Location}} {I1 : Interface} (g_pow_xi_yi_vi : both L1 I1 t_Gt) : both L1 I1 t_Scalar :=
  commit_to g_pow_xi_yi_vi  :=
    solve_lift (hash (impl__into_vec (unsize (box_new (array_from_list [g_pow_xi_yi_vi]))))) : both L1 I1 t_Scalar.
Fail Next Obligation.

Definition t_CastVoteParam {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} : choice_type :=
  (int32 × f_Scalar × f_Scalar × f_Scalar × f_Scalar × 'bool × t_PhantomData v_S).
Equations f_cvp_i {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_CastVoteParam) : both L I int32 :=
  f_cvp_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst (fst x))))) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_cvp_xi {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_CastVoteParam) : both L I f_Scalar :=
  f_cvp_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst x))))) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_cvp_zkp_random_w {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_CastVoteParam) : both L I f_Scalar :=
  f_cvp_zkp_random_w s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_cvp_zkp_random_r {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_CastVoteParam) : both L I f_Scalar :=
  f_cvp_zkp_random_r s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_cvp_zkp_random_d {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_CastVoteParam) : both L I f_Scalar :=
  f_cvp_zkp_random_d s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_cvp_vote {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_CastVoteParam) : both L I 'bool :=
  f_cvp_vote s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : 'bool))) : both L I 'bool.
Fail Next Obligation.
Equations f_phantom {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_CastVoteParam) : both L I (t_PhantomData v_S) :=
  f_phantom s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : (t_PhantomData v_S)))) : both L I (t_PhantomData v_S).
Fail Next Obligation.
Equations Build_t_CastVoteParam {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {L6 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {I6 : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} {f_cvp_i : both L0 I0 int32} {f_cvp_xi : both L1 I1 f_Scalar} {f_cvp_zkp_random_w : both L2 I2 f_Scalar} {f_cvp_zkp_random_r : both L3 I3 f_Scalar} {f_cvp_zkp_random_d : both L4 I4 f_Scalar} {f_cvp_vote : both L5 I5 'bool} {f_phantom : both L6 I6 (t_PhantomData v_S)} : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6) (t_CastVoteParam) :=
  Build_t_CastVoteParam  :=
    bind_both f_phantom (fun f_phantom =>
      bind_both f_cvp_vote (fun f_cvp_vote =>
        bind_both f_cvp_zkp_random_d (fun f_cvp_zkp_random_d =>
          bind_both f_cvp_zkp_random_r (fun f_cvp_zkp_random_r =>
            bind_both f_cvp_zkp_random_w (fun f_cvp_zkp_random_w =>
              bind_both f_cvp_xi (fun f_cvp_xi =>
                bind_both f_cvp_i (fun f_cvp_i =>
                  solve_lift (ret_both ((f_cvp_i,f_cvp_xi,f_cvp_zkp_random_w,f_cvp_zkp_random_r,f_cvp_zkp_random_d,f_cvp_vote,f_phantom) : (t_CastVoteParam)))))))))) : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6) (t_CastVoteParam).
Fail Next Obligation.
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_i' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := y) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x) (f_phantom := f_phantom x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_xi' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := y) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x) (f_phantom := f_phantom x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_zkp_random_w' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := y) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x) (f_phantom := f_phantom x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_zkp_random_r' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := y) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x) (f_phantom := f_phantom x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_zkp_random_d' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := y) (f_cvp_vote := f_cvp_vote x) (f_phantom := f_phantom x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_vote' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := y) (f_phantom := f_phantom x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_phantom' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_zkp_random_w := f_cvp_zkp_random_w x) (f_cvp_zkp_random_r := f_cvp_zkp_random_r x) (f_cvp_zkp_random_d := f_cvp_zkp_random_d x) (f_cvp_vote := f_cvp_vote x) (f_phantom := y)).

#[global] Program Instance t_CastVoteParam v_S_t_Serial {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} : t_Serial (t_CastVoteParam v_S) :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_CastVoteParam v_S)) (w : both L2 I2 v_W) => solve_lift (run (letb '(tmp0,out) := f_serial (f_cvp_i self) w in
  letb _ := assign todo(term) in
  letb hoist2 := out in
  letb hoist3 := f_branch hoist2 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist3 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist1 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist1))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_serial (f_from (f_cvp_xi self)) w in
  letb _ := assign todo(term) in
  letb hoist5 := out in
  letb hoist6 := f_branch hoist5 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist6 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist4 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist4))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_serial (f_from (f_cvp_zkp_random_w self)) w in
  letb _ := assign todo(term) in
  letb hoist8 := out in
  letb hoist9 := f_branch hoist8 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist9 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist7 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist7))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_serial (f_from (f_cvp_zkp_random_r self)) w in
  letb _ := assign todo(term) in
  letb hoist11 := out in
  letb hoist12 := f_branch hoist11 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist12 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist10 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist10))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_serial (f_from (f_cvp_zkp_random_d self)) w in
  letb _ := assign todo(term) in
  letb hoist14 := out in
  letb hoist15 := f_branch hoist14 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist15 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist13 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist13))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_serial (f_cvp_vote self) w in
  letb _ := assign todo(term) in
  letb hoist17 := out in
  letb hoist18 := f_branch hoist17 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist18 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist16 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist16))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  ControlFlow_Continue (letb hax_temp_output := Result_Ok (ret_both (tt : 'unit)) in
  prod_b (w,hax_temp_output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) (v_W × t_Result 'unit f_Err) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_CastVoteParam v_S_t_Serial.

#[global] Program Instance t_CastVoteParam v_S_t_Deserial {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} : t_Deserial (t_CastVoteParam v_S) :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (r : both L1 I1 v_R) => solve_lift (run (letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist20 := out in
  letb hoist21 := f_branch hoist20 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] (cvp_i : both _ _ int32) := matchb hoist21 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist19 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist19))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (int32)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist23 := out in
  letb hoist24 := f_branch hoist23 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist25 := matchb hoist24 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist22 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist22))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (v_S)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb (cvp_xi : both _ _ t_Scalar) := f_into hoist25 in
  letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist27 := out in
  letb hoist28 := f_branch hoist27 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist29 := matchb hoist28 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist26 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist26))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (v_S)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb (cvp_zkp_random_w : both _ _ t_Scalar) := f_into hoist29 in
  letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist31 := out in
  letb hoist32 := f_branch hoist31 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist33 := matchb hoist32 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist30 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist30))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (v_S)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb (cvp_zkp_random_r : both _ _ t_Scalar) := f_into hoist33 in
  letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist35 := out in
  letb hoist36 := f_branch hoist35 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist37 := matchb hoist36 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist34 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist34))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (v_S)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb (cvp_zkp_random_d : both _ _ t_Scalar) := f_into hoist37 in
  letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist39 := out in
  letb hoist40 := f_branch hoist39 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] (cvp_vote : both _ _ 'bool) := matchb hoist40 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_CastVoteParam v_S) t_ParseError)] hoist38 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist38))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('bool)) in
    ControlFlow_Continue (solve_lift val)
  end in
  ControlFlow_Continue (letb hax_temp_output := Result_Ok (Build_t_CastVoteParam (f_cvp_i := cvp_i) (f_cvp_xi := cvp_xi) (f_cvp_zkp_random_w := cvp_zkp_random_w) (f_cvp_zkp_random_r := cvp_zkp_random_r) (f_cvp_zkp_random_d := cvp_zkp_random_d) (f_cvp_vote := cvp_vote) (f_phantom := PhantomData)) in
  prod_b (r,hax_temp_output)))) : both (L1 :|: fset []) I1 (v_R × t_Result (t_CastVoteParam v_S) t_ParseError) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_CastVoteParam v_S_t_Deserial.

Definition t_OrZKPCommit : choice_type :=
  (t_Gt × t_Gt × t_Gt × t_Gt × t_Gt × t_Gt × f_Scalar × f_Scalar × f_Scalar × f_Scalar × f_Scalar).
Equations f_or_zkp_x {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I t_Gt :=
  f_or_zkp_x s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst (fst (fst (fst (fst (fst x))))))))) : t_Gt))) : both L I t_Gt.
Fail Next Obligation.
Equations f_or_zkp_y {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I t_Gt :=
  f_or_zkp_y s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst (fst (fst (fst x))))))))) : t_Gt))) : both L I t_Gt.
Fail Next Obligation.
Equations f_or_zkp_a1 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I t_Gt :=
  f_or_zkp_a1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst (fst (fst x)))))))) : t_Gt))) : both L I t_Gt.
Fail Next Obligation.
Equations f_or_zkp_b1 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I t_Gt :=
  f_or_zkp_b1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst (fst x))))))) : t_Gt))) : both L I t_Gt.
Fail Next Obligation.
Equations f_or_zkp_a2 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I t_Gt :=
  f_or_zkp_a2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst (fst x)))))) : t_Gt))) : both L I t_Gt.
Fail Next Obligation.
Equations f_or_zkp_b2 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I t_Gt :=
  f_or_zkp_b2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Gt))) : both L I t_Gt.
Fail Next Obligation.
Equations f_or_zkp_c {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I f_Scalar :=
  f_or_zkp_c s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_or_zkp_d1 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I f_Scalar :=
  f_or_zkp_d1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_or_zkp_d2 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I f_Scalar :=
  f_or_zkp_d2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_or_zkp_r1 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I f_Scalar :=
  f_or_zkp_r1 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_or_zkp_r2 {L : {fset Location}} {I : Interface} (s : both L I t_OrZKPCommit) : both L I f_Scalar :=
  f_or_zkp_r2 s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations Build_t_OrZKPCommit {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {L6 : {fset Location}} {L7 : {fset Location}} {L8 : {fset Location}} {L9 : {fset Location}} {L10 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {I6 : Interface} {I7 : Interface} {I8 : Interface} {I9 : Interface} {I10 : Interface} {f_or_zkp_x : both L0 I0 t_Gt} {f_or_zkp_y : both L1 I1 t_Gt} {f_or_zkp_a1 : both L2 I2 t_Gt} {f_or_zkp_b1 : both L3 I3 t_Gt} {f_or_zkp_a2 : both L4 I4 t_Gt} {f_or_zkp_b2 : both L5 I5 t_Gt} {f_or_zkp_c : both L6 I6 f_Scalar} {f_or_zkp_d1 : both L7 I7 f_Scalar} {f_or_zkp_d2 : both L8 I8 f_Scalar} {f_or_zkp_r1 : both L9 I9 f_Scalar} {f_or_zkp_r2 : both L10 I10 f_Scalar} : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6:|:L7:|:L8:|:L9:|:L10) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6:|:I7:|:I8:|:I9:|:I10) (t_OrZKPCommit) :=
  Build_t_OrZKPCommit  :=
    bind_both f_or_zkp_r2 (fun f_or_zkp_r2 =>
      bind_both f_or_zkp_r1 (fun f_or_zkp_r1 =>
        bind_both f_or_zkp_d2 (fun f_or_zkp_d2 =>
          bind_both f_or_zkp_d1 (fun f_or_zkp_d1 =>
            bind_both f_or_zkp_c (fun f_or_zkp_c =>
              bind_both f_or_zkp_b2 (fun f_or_zkp_b2 =>
                bind_both f_or_zkp_a2 (fun f_or_zkp_a2 =>
                  bind_both f_or_zkp_b1 (fun f_or_zkp_b1 =>
                    bind_both f_or_zkp_a1 (fun f_or_zkp_a1 =>
                      bind_both f_or_zkp_y (fun f_or_zkp_y =>
                        bind_both f_or_zkp_x (fun f_or_zkp_x =>
                          solve_lift (ret_both ((f_or_zkp_x,f_or_zkp_y,f_or_zkp_a1,f_or_zkp_b1,f_or_zkp_a2,f_or_zkp_b2,f_or_zkp_c,f_or_zkp_d1,f_or_zkp_d2,f_or_zkp_r1,f_or_zkp_r2) : (t_OrZKPCommit)))))))))))))) : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5:|:L6:|:L7:|:L8:|:L9:|:L10) (I0:|:I1:|:I2:|:I3:|:I4:|:I5:|:I6:|:I7:|:I8:|:I9:|:I10) (t_OrZKPCommit).
Fail Next Obligation.
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_x' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := y) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_y' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := y) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_a1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := y) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_b1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := y) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_a2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := y) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_b2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := y) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_c' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := y) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_d1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := y) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_d2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := y) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_r1' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := y) (f_or_zkp_r2 := f_or_zkp_r2 x)).
Notation "'Build_t_OrZKPCommit' '[' x ']' '(' 'f_or_zkp_r2' ':=' y ')'" := (Build_t_OrZKPCommit (f_or_zkp_x := f_or_zkp_x x) (f_or_zkp_y := f_or_zkp_y x) (f_or_zkp_a1 := f_or_zkp_a1 x) (f_or_zkp_b1 := f_or_zkp_b1 x) (f_or_zkp_a2 := f_or_zkp_a2 x) (f_or_zkp_b2 := f_or_zkp_b2 x) (f_or_zkp_c := f_or_zkp_c x) (f_or_zkp_d1 := f_or_zkp_d1 x) (f_or_zkp_d2 := f_or_zkp_d2 x) (f_or_zkp_r1 := f_or_zkp_r1 x) (f_or_zkp_r2 := y)).

Definition t_RegisterParam {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} : choice_type :=
  (int32 × f_Scalar × f_Scalar × t_PhantomData v_S).
Equations f_rp_i {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_RegisterParam) : both L I int32 :=
  f_rp_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst x)) : int32))) : both L I int32.
Fail Next Obligation.
Equations f_rp_xi {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_RegisterParam) : both L I f_Scalar :=
  f_rp_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_rp_zkp_random {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_RegisterParam) : both L I f_Scalar :=
  f_rp_zkp_random s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_phantom {L : {fset Location}} {I : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} (s : both L I t_RegisterParam) : both L I (t_PhantomData v_S) :=
  f_phantom s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : (t_PhantomData v_S)))) : both L I (t_PhantomData v_S).
Fail Next Obligation.
Equations Build_t_RegisterParam {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} {f_rp_i : both L0 I0 int32} {f_rp_xi : both L1 I1 f_Scalar} {f_rp_zkp_random : both L2 I2 f_Scalar} {f_phantom : both L3 I3 (t_PhantomData v_S)} : both (L0:|:L1:|:L2:|:L3) (I0:|:I1:|:I2:|:I3) (t_RegisterParam) :=
  Build_t_RegisterParam  :=
    bind_both f_phantom (fun f_phantom =>
      bind_both f_rp_zkp_random (fun f_rp_zkp_random =>
        bind_both f_rp_xi (fun f_rp_xi =>
          bind_both f_rp_i (fun f_rp_i =>
            solve_lift (ret_both ((f_rp_i,f_rp_xi,f_rp_zkp_random,f_phantom) : (t_RegisterParam))))))) : both (L0:|:L1:|:L2:|:L3) (I0:|:I1:|:I2:|:I3) (t_RegisterParam).
Fail Next Obligation.
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_i' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := y) (f_rp_xi := f_rp_xi x) (f_rp_zkp_random := f_rp_zkp_random x) (f_phantom := f_phantom x)).
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_xi' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := f_rp_i x) (f_rp_xi := y) (f_rp_zkp_random := f_rp_zkp_random x) (f_phantom := f_phantom x)).
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_zkp_random' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := f_rp_i x) (f_rp_xi := f_rp_xi x) (f_rp_zkp_random := y) (f_phantom := f_phantom x)).
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_phantom' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := f_rp_i x) (f_rp_xi := f_rp_xi x) (f_rp_zkp_random := f_rp_zkp_random x) (f_phantom := y)).

#[global] Program Instance t_RegisterParam v_S_t_Serial {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} : t_Serial (t_RegisterParam v_S) :=
  let f_serial := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RegisterParam v_S)) (w : both L2 I2 v_W) => solve_lift (run (letb '(tmp0,out) := f_serial (f_rp_i self) w in
  letb _ := assign todo(term) in
  letb hoist42 := out in
  letb hoist43 := f_branch hoist42 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist43 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist41 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist41))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_serial (f_from (f_rp_xi self)) w in
  letb _ := assign todo(term) in
  letb hoist45 := out in
  letb hoist46 := f_branch hoist45 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist46 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist44 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist44))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_serial (f_from (f_rp_zkp_random self)) w in
  letb _ := assign todo(term) in
  letb hoist48 := out in
  letb hoist49 := f_branch hoist48 in
  letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist49 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist47 := ControlFlow_Break (prod_b (w,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist47))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('unit)) in
    ControlFlow_Continue (solve_lift val)
  end in
  ControlFlow_Continue (letb hax_temp_output := Result_Ok (ret_both (tt : 'unit)) in
  prod_b (w,hax_temp_output)))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) (v_W × t_Result 'unit f_Err) in
  {| f_serial_loc := (fset [] : {fset Location});
  f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_RegisterParam v_S_t_Serial.

#[global] Program Instance t_RegisterParam v_S_t_Deserial {v_S : _} `{ t_Sized v_S} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} : t_Deserial (t_RegisterParam v_S) :=
  let f_deserial := fun  {L1 : {fset Location}} {I1 : Interface} (r : both L1 I1 v_R) => solve_lift (run (letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist51 := out in
  letb hoist52 := f_branch hoist51 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_RegisterParam v_S) t_ParseError)] (rp_i : both _ _ int32) := matchb hoist52 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_RegisterParam v_S) t_ParseError)] hoist50 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist50))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (int32)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist54 := out in
  letb hoist55 := f_branch hoist54 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_RegisterParam v_S) t_ParseError)] hoist56 := matchb hoist55 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_RegisterParam v_S) t_ParseError)] hoist53 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist53))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (v_S)) in
    ControlFlow_Continue (solve_lift val)
  end in
  letb (rp_xi : both _ _ t_Scalar) := f_into hoist56 in
  letb '(tmp0,out) := f_get r in
  letb _ := assign todo(term) in
  letb hoist58 := out in
  letb hoist59 := f_branch hoist58 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_RegisterParam v_S) t_ParseError)] hoist60 := matchb hoist59 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result (t_RegisterParam v_S) t_ParseError)] hoist57 := ControlFlow_Break (prod_b (r,f_from_residual residual)) in
    ControlFlow_Continue (solve_lift (never_to_any hoist57))
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (v_S)) in
    ControlFlow_Continue (solve_lift val)
  end in
  ControlFlow_Continue (letb (rp_zkp_random : both _ _ t_Scalar) := f_into hoist60 in
  letb hax_temp_output := Result_Ok (Build_t_RegisterParam (f_rp_i := rp_i) (f_rp_xi := rp_xi) (f_rp_zkp_random := rp_zkp_random) (f_phantom := PhantomData)) in
  prod_b (r,hax_temp_output)))) : both (L1 :|: fset []) I1 (v_R × t_Result (t_RegisterParam v_S) t_ParseError) in
  {| f_deserial_loc := (fset [] : {fset Location});
  f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_RegisterParam v_S_t_Deserial.

Definition t_SchnorrZKPCommit : choice_type :=
  (t_Gt × f_Scalar × f_Scalar).
Equations f_schnorr_zkp_u {L : {fset Location}} {I : Interface} (s : both L I t_SchnorrZKPCommit) : both L I t_Gt :=
  f_schnorr_zkp_u s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : t_Gt))) : both L I t_Gt.
Fail Next Obligation.
Equations f_schnorr_zkp_c {L : {fset Location}} {I : Interface} (s : both L I t_SchnorrZKPCommit) : both L I f_Scalar :=
  f_schnorr_zkp_c s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_schnorr_zkp_z {L : {fset Location}} {I : Interface} (s : both L I t_SchnorrZKPCommit) : both L I f_Scalar :=
  f_schnorr_zkp_z s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations Build_t_SchnorrZKPCommit {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {f_schnorr_zkp_u : both L0 I0 t_Gt} {f_schnorr_zkp_c : both L1 I1 f_Scalar} {f_schnorr_zkp_z : both L2 I2 f_Scalar} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_SchnorrZKPCommit) :=
  Build_t_SchnorrZKPCommit  :=
    bind_both f_schnorr_zkp_z (fun f_schnorr_zkp_z =>
      bind_both f_schnorr_zkp_c (fun f_schnorr_zkp_c =>
        bind_both f_schnorr_zkp_u (fun f_schnorr_zkp_u =>
          solve_lift (ret_both ((f_schnorr_zkp_u,f_schnorr_zkp_c,f_schnorr_zkp_z) : (t_SchnorrZKPCommit)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_SchnorrZKPCommit).
Fail Next Obligation.
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_u' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := y) (f_schnorr_zkp_c := f_schnorr_zkp_c x) (f_schnorr_zkp_z := f_schnorr_zkp_z x)).
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_c' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_schnorr_zkp_u x) (f_schnorr_zkp_c := y) (f_schnorr_zkp_z := f_schnorr_zkp_z x)).
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_z' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_schnorr_zkp_u x) (f_schnorr_zkp_c := f_schnorr_zkp_c x) (f_schnorr_zkp_z := y)).

Definition t_TallyParameter : choice_type :=
  'unit.
Equations Build_t_TallyParameter : both (fset []) (fset []) (t_TallyParameter) :=
  Build_t_TallyParameter  :=
    solve_lift (ret_both (tt (* Empty tuple *) : (t_TallyParameter))) : both (fset []) (fset []) (t_TallyParameter).
Fail Next Obligation.

Equations schnorr_zkp {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (r : both L1 I1 t_Scalar) (h : both L2 I2 t_Gt) (x : both L3 I3 t_Scalar) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) t_SchnorrZKPCommit :=
  schnorr_zkp r h x  :=
    solve_lift (run (letb u := (f_generator (ret_both (tt : 'unit))) .* r in
    letb c := hash (impl__into_vec (unsize (box_new (array_from_list [f_generator (ret_both (tt : 'unit));
      h;
      u])))) in
    letb z := r .+ (c .* x) in
    letm[choice_typeMonad.result_bind_code t_SchnorrZKPCommit] hoist61 := ControlFlow_Break (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := u) (f_schnorr_zkp_c := c) (f_schnorr_zkp_z := z)) in
    ControlFlow_Continue (never_to_any hoist61))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) t_SchnorrZKPCommit.
Fail Next Obligation.

Equations schnorr_zkp_validate {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (h : both L1 I1 t_Gt) (pi : both L2 I2 t_SchnorrZKPCommit) : both (L1 :|: L2) (I1 :|: I2) 'bool :=
  schnorr_zkp_validate h pi  :=
    solve_lift (andb ((f_schnorr_zkp_c pi) =.? (hash (impl__into_vec (unsize (box_new (array_from_list [f_generator (ret_both (tt : 'unit));
      h;
      f_schnorr_zkp_u pi])))))) (((f_generator (ret_both (tt : 'unit))) .* (f_schnorr_zkp_z pi)) =.? ((f_schnorr_zkp_u pi) .+ (h .* (f_schnorr_zkp_c pi))))) : both (L1 :|: L2) (I1 :|: I2) 'bool.
Fail Next Obligation.

Equations zkp_one_out_of_two {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {L6 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {I6 : Interface} (w : both L1 I1 t_Scalar) (rand_r : both L2 I2 t_Scalar) (rand_d : both L3 I3 t_Scalar) (h : both L4 I4 t_Gt) (xi : both L5 I5 t_Scalar) (vi : both L6 I6 'bool) : both (L1 :|: L2 :|: L3 :|: L4 :|: L5 :|: L6) (I1 :|: I2 :|: I3 :|: I4 :|: I5 :|: I6) t_OrZKPCommit :=
  zkp_one_out_of_two w rand_r rand_d h xi vi  :=
    solve_lift (ifb vi
    then letb r1 := rand_r in
    letb d1 := rand_d in
    letb x := (f_generator (ret_both (tt : 'unit))) .* xi in
    letb y := (h .* xi) .+ (f_generator (ret_both (tt : 'unit))) in
    letb a1 := ((f_generator (ret_both (tt : 'unit))) .* r1) .+ (x .* d1) in
    letb b1 := (h .* r1) .+ (y .* d1) in
    letb a2 := (f_generator (ret_both (tt : 'unit))) .* w in
    letb b2 := h .* w in
    letb c := hash (impl__into_vec (unsize (box_new (array_from_list [x;
      y;
      a1;
      b1;
      a2;
      b2])))) in
    letb d2 := c .- d1 in
    letb r2 := w .- (xi .* d2) in
    Build_t_OrZKPCommit (f_or_zkp_x := x) (f_or_zkp_y := y) (f_or_zkp_a1 := a1) (f_or_zkp_b1 := b1) (f_or_zkp_a2 := a2) (f_or_zkp_b2 := b2) (f_or_zkp_c := c) (f_or_zkp_d1 := d1) (f_or_zkp_d2 := d2) (f_or_zkp_r1 := r1) (f_or_zkp_r2 := r2)
    else letb r2 := rand_r in
    letb d2 := rand_d in
    letb x := (f_generator (ret_both (tt : 'unit))) .* xi in
    letb y := h .* xi in
    letb a1 := (f_generator (ret_both (tt : 'unit))) .* w in
    letb b1 := h .* w in
    letb a2 := ((f_generator (ret_both (tt : 'unit))) .* r2) .+ (x .* d2) in
    letb b2 := (h .* r2) .+ ((y .- (f_generator (ret_both (tt : 'unit)))) .* d2) in
    letb c := hash (impl__into_vec (unsize (box_new (array_from_list [x;
      y;
      a1;
      b1;
      a2;
      b2])))) in
    letb d1 := c .- d2 in
    letb r1 := w .- (xi .* d1) in
    Build_t_OrZKPCommit (f_or_zkp_x := x) (f_or_zkp_y := y) (f_or_zkp_a1 := a1) (f_or_zkp_b1 := b1) (f_or_zkp_a2 := a2) (f_or_zkp_b2 := b2) (f_or_zkp_c := c) (f_or_zkp_d1 := d1) (f_or_zkp_d2 := d2) (f_or_zkp_r1 := r1) (f_or_zkp_r2 := r2)) : both (L1 :|: L2 :|: L3 :|: L4 :|: L5 :|: L6) (I1 :|: I2 :|: I3 :|: I4 :|: I5 :|: I6) t_OrZKPCommit.
Fail Next Obligation.

Equations zkp_one_out_of_two_validate {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (h : both L1 I1 t_Gt) (zkp : both L2 I2 t_OrZKPCommit) : both (L1 :|: L2) (I1 :|: I2) 'bool :=
  zkp_one_out_of_two_validate h zkp  :=
    letb c := hash (impl__into_vec (unsize (box_new (array_from_list [f_or_zkp_x zkp;
      f_or_zkp_y zkp;
      f_or_zkp_a1 zkp;
      f_or_zkp_b1 zkp;
      f_or_zkp_a2 zkp;
      f_or_zkp_b2 zkp])))) in
    solve_lift (andb (andb (andb (andb (c =.? ((f_or_zkp_d1 zkp) .+ (f_or_zkp_d2 zkp))) ((f_or_zkp_a1 zkp) =.? (((f_generator (ret_both (tt : 'unit))) .* (f_or_zkp_r1 zkp)) .+ ((f_or_zkp_x zkp) .* (f_or_zkp_d1 zkp))))) ((f_or_zkp_b1 zkp) =.? ((h .* (f_or_zkp_r1 zkp)) .+ ((f_or_zkp_y zkp) .* (f_or_zkp_d1 zkp))))) ((f_or_zkp_a2 zkp) =.? (((f_generator (ret_both (tt : 'unit))) .* (f_or_zkp_r2 zkp)) .+ ((f_or_zkp_x zkp) .* (f_or_zkp_d2 zkp))))) ((f_or_zkp_b2 zkp) =.? ((h .* (f_or_zkp_r2 zkp)) .+ (((f_or_zkp_y zkp) .- (f_generator (ret_both (tt : 'unit)))) .* (f_or_zkp_d2 zkp))))) : both (L1 :|: L2) (I1 :|: I2) 'bool.
Fail Next Obligation.

Definition t_OvnContractState {n : both (fset []) (fset []) uint_size} : choice_type :=
  (nseq t_Gt (is_pure (n)) × nseq t_SchnorrZKPCommit (is_pure (n)) × nseq f_Scalar (is_pure (n)) × nseq t_Gt (is_pure (n)) × nseq t_OrZKPCommit (is_pure (n)) × int32).
Equations f_g_pow_xis {L : {fset Location}} {I : Interface} {n : both (fset []) (fset []) uint_size} (s : both L I t_OvnContractState) : both L I (nseq t_Gt (is_pure (n))) :=
  f_g_pow_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst x)))) : (nseq t_Gt (is_pure (n)))))) : both L I (nseq t_Gt (is_pure (n))).
Fail Next Obligation.
Equations f_zkp_xis {L : {fset Location}} {I : Interface} {n : both (fset []) (fset []) uint_size} (s : both L I t_OvnContractState) : both L I (nseq t_SchnorrZKPCommit (is_pure (n))) :=
  f_zkp_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : (nseq t_SchnorrZKPCommit (is_pure (n)))))) : both L I (nseq t_SchnorrZKPCommit (is_pure (n))).
Fail Next Obligation.
Equations f_commit_vis {L : {fset Location}} {I : Interface} {n : both (fset []) (fset []) uint_size} (s : both L I t_OvnContractState) : both L I (nseq f_Scalar (is_pure (n))) :=
  f_commit_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : (nseq f_Scalar (is_pure (n)))))) : both L I (nseq f_Scalar (is_pure (n))).
Fail Next Obligation.
Equations f_g_pow_xi_yi_vis {L : {fset Location}} {I : Interface} {n : both (fset []) (fset []) uint_size} (s : both L I t_OvnContractState) : both L I (nseq t_Gt (is_pure (n))) :=
  f_g_pow_xi_yi_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : (nseq t_Gt (is_pure (n)))))) : both L I (nseq t_Gt (is_pure (n))).
Fail Next Obligation.
Equations f_zkp_vis {L : {fset Location}} {I : Interface} {n : both (fset []) (fset []) uint_size} (s : both L I t_OvnContractState) : both L I (nseq t_OrZKPCommit (is_pure (n))) :=
  f_zkp_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : (nseq t_OrZKPCommit (is_pure (n)))))) : both L I (nseq t_OrZKPCommit (is_pure (n))).
Fail Next Obligation.
Equations f_tally {L : {fset Location}} {I : Interface} {n : both (fset []) (fset []) uint_size} (s : both L I t_OvnContractState) : both L I int32 :=
  f_tally s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : int32))) : both L I int32.
Fail Next Obligation.
Equations Build_t_OvnContractState {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {n : both (fset []) (fset []) uint_size} {f_g_pow_xis : both L0 I0 (nseq t_Gt (is_pure (n)))} {f_zkp_xis : both L1 I1 (nseq t_SchnorrZKPCommit (is_pure (n)))} {f_commit_vis : both L2 I2 (nseq f_Scalar (is_pure (n)))} {f_g_pow_xi_yi_vis : both L3 I3 (nseq t_Gt (is_pure (n)))} {f_zkp_vis : both L4 I4 (nseq t_OrZKPCommit (is_pure (n)))} {f_tally : both L5 I5 int32} : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_OvnContractState) :=
  Build_t_OvnContractState  :=
    bind_both f_tally (fun f_tally =>
      bind_both f_zkp_vis (fun f_zkp_vis =>
        bind_both f_g_pow_xi_yi_vis (fun f_g_pow_xi_yi_vis =>
          bind_both f_commit_vis (fun f_commit_vis =>
            bind_both f_zkp_xis (fun f_zkp_xis =>
              bind_both f_g_pow_xis (fun f_g_pow_xis =>
                solve_lift (ret_both ((f_g_pow_xis,f_zkp_xis,f_commit_vis,f_g_pow_xi_yi_vis,f_zkp_vis,f_tally) : (t_OvnContractState))))))))) : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_OvnContractState).
Fail Next Obligation.
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := y) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := y) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_commit_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := y) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xi_yi_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := y) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := y) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_tally' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := y)).

Definition cast_vote_state_ret_loc {v_S : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_S} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState (both (fset []) (fset []) uint_size);2%nat).
Equations cast_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_S : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_S} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (ctx : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [cast_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError) :=
  cast_vote ctx state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code t_ParseError] (params : both _ _ (t_CastVoteParam v_S)) := out in
    Result_Ok (letb g_pow_yi := compute_g_pow_yi (cast (B := uint_size) (f_cvp_i params)) (f_g_pow_xis state) in
    letb g_pow_xi_yi_vi := compute_group_element_for_vote (f_cvp_xi params) (f_cvp_vote params) g_pow_yi in
    letb zkp_vi := zkp_one_out_of_two (f_cvp_zkp_random_w params) (f_cvp_zkp_random_r params) (f_cvp_zkp_random_d params) g_pow_yi (f_cvp_xi params) (f_cvp_vote params) in
    letb cast_vote_state_ret loc(cast_vote_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    letb _ := assign todo(term) in
    Result_Ok (prod_b (f_accept (ret_both (tt : 'unit)),cast_vote_state_ret))))) : both (L1 :|: L2 :|: fset [cast_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.

Definition commit_to_vote_state_ret_loc {v_S : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_S} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState (both (fset []) (fset []) uint_size);3%nat).
Equations commit_to_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_S : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_S} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (ctx : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [commit_to_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError) :=
  commit_to_vote ctx state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code t_ParseError] (params : both _ _ (t_CastVoteParam v_S)) := out in
    Result_Ok (letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := n))) (fun i =>
      ssp (fun _ =>
        solve_lift (ifb not (schnorr_zkp_validate ((f_g_pow_xis state).a[i]) ((f_zkp_xis state).a[i]))
        then letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError)] hoist62 := ControlFlow_Break (Result_Err ParseError) in
        ControlFlow_Continue (never_to_any hoist62)
        else ()) : (both (*0*)(L2:|:fset []) (I2) (t_ControlFlow (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError) 'unit)))) (ret_both (tt : 'unit)) in
    letb g_pow_yi := compute_g_pow_yi (cast (B := uint_size) (f_cvp_i params)) (f_g_pow_xis state) in
    letb g_pow_xi_yi_vi := compute_group_element_for_vote (f_cvp_xi params) (f_cvp_vote params) g_pow_yi in
    letb commit_vi := commit_to g_pow_xi_yi_vi in
    letb commit_to_vote_state_ret loc(commit_to_vote_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    Result_Ok (prod_b (f_accept (ret_both (tt : 'unit)),commit_to_vote_state_ret))))) : both (L1 :|: L2 :|: fset [commit_to_vote_state_ret_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.

Equations init_ovn_contract {L1 : {fset Location}} {I1 : Interface} {n : both (fset []) (fset []) uint_size} (_ : both L1 I1 'unit) : both L1 I1 (t_Result (t_OvnContractState (both (fset []) (fset []) uint_size)) t_Reject) :=
  init_ovn_contract _  :=
    Result_Ok (solve_lift (Build_t_OvnContractState (f_g_pow_xis := repeat (f_identity (ret_both (tt : 'unit))) n) (f_zkp_xis := repeat (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_identity (ret_both (tt : 'unit))) (f_schnorr_zkp_z := f_ZERO) (f_schnorr_zkp_c := f_ZERO)) n) (f_commit_vis := repeat f_ZERO n) (f_g_pow_xi_yi_vis := repeat (f_identity (ret_both (tt : 'unit))) n) (f_zkp_vis := repeat (Build_t_OrZKPCommit (f_or_zkp_x := f_identity (ret_both (tt : 'unit))) (f_or_zkp_y := f_identity (ret_both (tt : 'unit))) (f_or_zkp_a1 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_b1 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_a2 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_b2 := f_identity (ret_both (tt : 'unit))) (f_or_zkp_c := f_ZERO) (f_or_zkp_d1 := f_ZERO) (f_or_zkp_d2 := f_ZERO) (f_or_zkp_r1 := f_ZERO) (f_or_zkp_r2 := f_ZERO)) n) (f_tally := ret_both (0 : int32)))) : both L1 I1 (t_Result (t_OvnContractState (both (fset []) (fset []) uint_size)) t_Reject).
Fail Next Obligation.

Definition register_vote_state_ret_loc {v_S : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_S} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState (both (fset []) (fset []) uint_size);4%nat).
Equations register_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_S : _} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_S} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_Serialize v_S} `{ t_From v_S f_Scalar} `{ t_Into v_S f_Scalar} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (ctx : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [register_vote_state_ret_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError) :=
  register_vote ctx state  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code t_ParseError] (params : both _ _ (t_RegisterParam v_S)) := out in
    Result_Ok (letb g_pow_xi := (f_generator (ret_both (tt : 'unit))) .* (f_rp_xi params) in
    letb zkp_xi := schnorr_zkp (f_rp_zkp_random params) g_pow_xi (f_rp_xi params) in
    letb register_vote_state_ret loc(register_vote_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    letb _ := assign todo(term) in
    Result_Ok (prod_b (f_accept (ret_both (tt : 'unit)),register_vote_state_ret))))) : both (L1 :|: L2 :|: fset [register_vote_state_ret_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.

Definition curr_loc {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_Scalar;5%nat).
Definition tally_loc {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (int32;6%nat).
Definition tally_votes_state_ret_loc {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_OvnContractState (both (fset []) (fset []) uint_size);7%nat).
Definition vote_result_loc {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} : Location :=
  (t_Gt;8%nat).
Equations tally_votes {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {n : both (fset []) (fset []) uint_size} {v_A : _} {impl_574521470_ : _} `{ t_Sized v_A} `{ t_Sized impl_574521470_} `{ t_HasActions v_A} `{ t_HasReceiveContext impl_574521470_ 'unit} (_ : both L1 I1 impl_574521470_) (state : both L2 I2 (t_OvnContractState (both (fset []) (fset []) uint_size))) : both (L1 :|: L2 :|: fset [curr_loc;tally_loc;tally_votes_state_ret_loc;vote_result_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError) :=
  tally_votes _ state  :=
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := n))) (fun i =>
      ssp (fun _ =>
        letb g_pow_yi := compute_g_pow_yi i (f_g_pow_xis state) in
        letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError)] _ := ControlFlow_Continue (ifb not (zkp_one_out_of_two_validate g_pow_yi ((f_zkp_vis state).a[i]))
        then letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError)] hoist63 := ControlFlow_Break (Result_Err ParseError) in
        ControlFlow_Continue (never_to_any hoist63)
        else ()) in
        solve_lift (ifb not (check_commitment ((f_g_pow_xi_yi_vis state).a[i]) ((f_commit_vis state).a[i]))
        then letm[choice_typeMonad.result_bind_code (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError)] hoist64 := ControlFlow_Break (Result_Err ParseError) in
        ControlFlow_Continue (never_to_any hoist64)
        else ()) : (both (*2*)(L2:|:fset [prod1_loc;prod2_loc]) (I2) (t_ControlFlow (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError) 'unit)))) (ret_both (tt : 'unit)) in
    letb vote_result loc(vote_result_loc) := f_identity (ret_both (tt : 'unit)) in
    letb _ := foldi_both_list (f_into_iter (f_g_pow_xi_yi_vis state)) (fun g_pow_vote =>
      ssp (fun _ =>
        assign todo(term) : (both (*1*)(L2:|:fset [vote_result_loc]) (I2) 'unit))) (ret_both (tt : 'unit)) in
    letb tally loc(tally_loc) := ret_both (0 : int32) in
    letb curr loc(curr_loc) := f_ZERO in
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : int32)) (f_end := cast (B := int32) n))) (fun i =>
      ssp (fun _ =>
        letb _ := ifb ((f_generator (ret_both (tt : 'unit))) .* curr) =.? vote_result
        then letb _ := assign todo(term) in
        ret_both (tt : 'unit)
        else () in
        letb _ := assign todo(term) in
        solve_lift (ret_both (tt : 'unit)) : (both (*3*)(fset [curr_loc;tally_loc;vote_result_loc]) ((fset [])) 'unit))) (ret_both (tt : 'unit)) in
    letb tally_votes_state_ret loc(tally_votes_state_ret_loc) := f_clone state in
    letb _ := assign todo(term) in
    Result_Ok (solve_lift (prod_b (f_accept (ret_both (tt : 'unit)),tally_votes_state_ret))) : both (L1 :|: L2 :|: fset [curr_loc;tally_loc;tally_votes_state_ret_loc;vote_result_loc;prod1_loc;prod2_loc]) (I1 :|: I2) (t_Result (v_A × t_OvnContractState (both (fset []) (fset []) uint_size)) t_ParseError).
Fail Next Obligation.
