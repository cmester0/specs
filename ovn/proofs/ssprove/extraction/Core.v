(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib.

From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Require Import Lia.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Sumbool.

From mathcomp Require Import fintype.

From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset fmap.

From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith List.
Import ListNotations.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Declare Scope hacspec_scope.

Open Scope list_scope.
Open Scope hacspec_scope.
Open Scope nat_scope.

(* Require Import Hacspec_Lib_Comparable. *)

Import choice.Choice.Exports.

Class t_TryFrom (A : choice_type) := TryFrom : A -> A.
Class t_Into (A : choice_type) := Into : A -> A.
Class t_PartialEq (A : choice_type) := PartialEq : A -> A.
Class t_Copy (A : choice_type) := Copy : A -> A.
Class t_Clone (A : choice_type) := Clone : A -> A.
Class t_Sized (A : choice_type) := Sized : A -> A.
Definition t_Option : choice_type -> choice_type := chOption.
Inductive vec_typ :=
| t_Global.
Definition t_Vec : choice_type -> vec_typ -> choice_type := fun A _ => chList A.

Class t_Default A := { default : A }.

#[global] Instance bool_copy : t_Copy 'bool := {Copy x := x}.
#[global] Instance bool_clone : t_Clone 'bool := {Clone x := x}.
#[global] Instance bool_sized : t_Sized 'bool := {Sized x := x}.

Definition ilog2 {WS} {L I} (x : both L I (int WS)) : both L I (int WS) := x. (* TODO *)

Definition collect {A} {L I} (x : both L I (chList A)) : both L I (t_Vec A t_Global) := x.
  

Equations swap_both_list {A L I} (x : list (both L I A)) : both L I (chList A) :=
  swap_both_list x :=
  (List.fold_left (fun (x : both L I (chList A)) y =>
   bind_both x (fun x' =>
   bind_both y (fun y' =>
                  ret_both ((y' :: x') : chList A)))) x (ret_both ([] : chList A))).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.

Equations match_list {A B : choice_type} {L I} (x : both L I (chList A)) (f : list A -> B) : both L I B :=
  match_list x f :=
  bind_both x (fun x' => ret_both (f x')).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.

Equations map {A B} {L I} (x : both L I (chList A))  (f : both L I A -> both L I B) : both L I (chList B) :=
  map x f :=
  bind_both x (fun x' => swap_both_list (List.map (fun y => f (ret_both y)) x')).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.

Definition cloned {A} {L I} (x : both L I (chList A)) : both L I (chList A) := x.

Equations iter {A L I} (x : both L I (seq A)) : both L I (chList A) :=
  iter x :=
  bind_both x (fun x' => ret_both (seq_to_list _ x' : chList A)).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.

Definition dedup {A} {L I} (x : both L I (t_Vec A t_Global)) : both L I (t_Vec A t_Global) := x.

Definition t_String := Coq.Strings.String.string.
Definition new {A L I} : both L I (t_Vec A t_Global) := ret_both ([] : chList A).

Definition enumerate {A} {L I} (x : both L I (t_Vec A t_Global)) : both L I (t_Vec A t_Global) := x.

Definition t_Result A B := result B A.
Inductive ControlFlow {L I} (A : choice_type) (B : choice_type) :=
| ControlFlow_Continue (val : both L I A)
| ControlFlow_Break (val : both L I B).

Definition run {A B : choice_type} {L I} (x : ControlFlow A B) : both L I (t_Result A B) :=
  match x with
  | ControlFlow_Continue v => Ok v
  | ControlFlow_Break v => Err v
  end.

(* Program Definition build_under_impl_1 {A B} : (t_Result A B) := *)
(*   run (letb layers := (match branch (build_tree_under_impl_1 partial_layers depth) with *)
(*     | ControlFlow_Break residual => letb hoist1 := (v_Break (from_residual residual)) : both _ _ (t_Never) in *)
(*       ControlFlow_Continue (never_to_any hoist1) *)
(*     | ControlFlow_Continue val => ControlFlow_Continue val *)
(*     end) in *)
(*   ControlFlow_Continue (Result_Ok (Build_PartialTree layers))). *)
(* Fail Next Obligation. *)

(** How to handle enums: **)

(* Inductive t_ErrorKind : Type := *)
(* | ErrorKind_SerializedProofSizeIsIncorrectt_ErrorKind  *)
(* | ErrorKind_NotEnoughHelperNodest_ErrorKind  *)
(* | ErrorKind_HashConversionErrort_ErrorKind  *)
(* | ErrorKind_NotEnoughHashesToCalculateRoott_ErrorKind  *)
(* | ErrorKind_LeavesIndicesCountMismatcht_ErrorKind. *)

Definition t_ErrorKind : choice_type := chFin (mkpos 5).
Definition ErrorKind_SerializedProofSizeIsIncorrect {L I} : both L I t_ErrorKind := ret_both (fintype.Ordinal (n:=5) (m:=0) eq_refl : t_ErrorKind).
Definition ErrorKind_NotEnoughHelperNodes {L I} : both L I t_ErrorKind := ret_both (fintype.Ordinal (n:=5) (m:=1) eq_refl : t_ErrorKind).
Definition ErrorKind_HashConversionError {L I} : both L I t_ErrorKind := ret_both (fintype.Ordinal (n:=5) (m:=2) eq_refl : t_ErrorKind).
Definition ErrorKind_NotEnoughHashesToCalculateRoot {L I} : both L I t_ErrorKind := ret_both (fintype.Ordinal (n:=5) (m:=3) eq_refl : t_ErrorKind).
Definition ErrorKind_LeavesIndicesCountMismatch {L I} : both L I t_ErrorKind := ret_both (fintype.Ordinal (n:=5) (m:=4) eq_refl : t_ErrorKind).

(** How to handle records: **)
(* TODO: Remove them as a phase? *)

(* Record t_Error : Type := { *)
(*     f_kind1 : t_ErrorKind *)
(*     f_kind2 : t_ErrorKind *)
(*   }. *)

Definition t_Error : choice_type := t_ErrorKind × t_ErrorKind.
(* Uncurry is Build_.. fn *)
Equations Build_Error {L I} {f_kind1 : both L I t_ErrorKind} {f_kind2 : both L I t_ErrorKind} : both L I t_Error :=
  Build_Error (f_kind1 := x) (f_kind2 := y) :=
  bind_both x (fun x' =>
  bind_both y (fun y' =>
                 ret_both ((x', y') : t_Error))).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.
Definition f_kind1 (v : t_Error) := fst v.
Definition f_kind2 (v : t_Error) := snd v.
(* Make into tuple struct with named projctions! *)

(*** More functions *)
Definition t_Drain : choice_type -> vec_typ -> choice_type := t_Vec.
Inductive t_Range := RangeFull.
Equations drain : forall {L I A}, both L I (t_Vec A t_Global) -> t_Range -> both L I (t_Drain A t_Global × t_Vec A t_Global) :=
  drain x _ :=
    bind_both x (fun x' => ret_both ((x', []) : (t_Drain A t_Global × t_Vec A t_Global))).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.
Notation t_Rev := id.
Equations rev {L I A} (x : both L I (chList A)) : both L I (chList A) := rev x := bind_both x (fun x => ret_both (List.rev x : chList _)).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.

Definition pop {L I A} : both L I (chList A) -> both L I (chOption A × t_Vec A (t_Global)) :=
  lift1_both (fun (x : chList A) => (List.hd_error x , List.tl x) : (chOption A × t_Vec A (t_Global))).

Definition push {L1 L2 I1 I2 A} : both L1 I1 (t_Vec A t_Global) -> both L2 I2 A -> both (L1 :|: L2) (I1 :|: I2) (t_Vec A (t_Global)) :=
  lift2_both (fun  (x : chList A) y => y :: x : chList A).

Notation Option_Some := Some.
Definition append {L1 L2 I1 I2} {A : choice_type} (l : both L1 I1 (chList A)) (x : both L2 I2 (chList A)) : both (L2 :|: L1) (I2 :|: I1) (chList A × chList A) :=
  lift2_both (fun (x : chList A) (y : chList A) => (app y x, []) : chList A × chList A) x l.

Notation clone := id.
Definition seq_unzip {A B} (s : chList (A × B)) : chList A × chList B := (seq.unzip1 s, seq.unzip2 s).
Definition unzip {L I} {A B} : both L I (chList (A × B)) -> both L I (chList A × chList B) := lift1_both seq_unzip.
Equations deref {L I A} : both L I (t_Vec A t_Global) -> both L I (seq A) :=
  deref X := bind_both X (fun x : t_Vec A t_Global => ret_both (seq_from_list A x)).
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.
Definition t_Never := False.
Notation v_Break := id.
Notation Result_Err := Err.
Definition never_to_any := tt.
Notation Result_Ok := Ok.

Notation "'ret_both' 'tt'" := (ret_both (tt : 'unit)).
