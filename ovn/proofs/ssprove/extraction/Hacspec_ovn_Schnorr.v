(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_lib.
Export Hacspec_lib.

Require Import HashMap.
Export HashMap.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_ovn_Schnorr_Random_oracle.
Export Hacspec_ovn_Schnorr_Random_oracle.

Notation t_Transcript := ((t_G × t_G × t_Q × t_Q)).

Equations prod_assoc {L1 : {fset Location}} {I1 : Interface} (sm : both L1 I1 ((t_G × t_G))) : both (L1) (I1) (t_Q) :=
  prod_assoc sm  :=
    letb '(statement,message) := (sm) : both _ _ ((t_G × t_G)) in
    solve_lift (Build_t_Q (ret_both (1 : int32))) : both (L1) (I1) (t_Q).
Fail Next Obligation.

Equations verify {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (h : both L1 I1 (t_G)) (a : both L2 I2 (t_G)) (e : both L3 I3 (t_Q)) (z : both L4 I4 (t_Q)) : both (L1:|:L2:|:L3:|:L4) (I1:|:I2:|:I3:|:I4) ('bool) :=
  verify h a e z  :=
    solve_lift (ret_both (false : 'bool)) : both (L1:|:L2:|:L3:|:L4) (I1:|:I2:|:I3:|:I4) ('bool).
Fail Next Obligation.

Equations fiat_shamir_verify {L1 : {fset Location}} {I1 : Interface} (t : both L1 I1 ((t_G × t_G × t_Q × t_Q))) : both (L1) (I1) ('bool) :=
  fiat_shamir_verify t  :=
    letb QUERIES := (new) : both _ _ (t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState)) in
    letb '(h,a,e,z) := (t) : both _ _ ((t_G × t_G × t_Q × t_Q)) in
    letb '(QUERIES,eu) := (random_oracle_query QUERIES (prod_assoc (prod_b (h,a)))) : both _ _ ((t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState) × (t_G × t_G))) in
    solve_lift (verify h a e z) : both (L1) (I1) ('bool).
Fail Next Obligation.

Notation t_Relation := ((t_G × t_Q)).

Definition commit_loc : Location :=
  ((t_G × t_G) ; 0%nat).
Equations v_Commit {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (h : both L1 I1 (t_G)) (w : both L2 I2 (t_Q)) : both (L1:|:L2 :|: fset [commit_loc]) (I1:|:I2) (t_G) :=
  v_Commit h w  :=
    letb r := (sample_uniform) : both _ _ ((t_G × t_G)) in
    letbm commit loc(commit_loc) := (r) : both _ _ ((t_G × t_G)) in
    solve_lift (Build_t_G (ret_both (1 : int32))) : both (L1:|:L2 :|: fset [commit_loc]) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations v_Response {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (h : both L1 I1 (t_G)) (w : both L2 I2 (t_Q)) (a : both L3 I3 (t_G)) (e : both L4 I4 (t_Q)) : both (L1:|:L2:|:L3:|:L4) (I1:|:I2:|:I3:|:I4) (t_Q) :=
  v_Response h w a e  :=
    solve_lift (Build_t_Q (ret_both (1 : int32))) : both (L1:|:L2:|:L3:|:L4) (I1:|:I2:|:I3:|:I4) (t_Q).
Fail Next Obligation.

Equations fiat_shamir_run {L1 : {fset Location}} {I1 : Interface} (hw : both L1 I1 ((t_G × t_Q))) : both (L1 :|: fset [commit_loc]) (I1) ((t_G × t_G × t_Q × t_Q)) :=
  fiat_shamir_run hw  :=
    letb QUERIES := (new) : both _ _ (t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState)) in
    letb '(h,w) := (hw) : both _ _ ((t_G × t_Q)) in
    letb a := (v_Commit h w) : both _ _ (t_G) in
    letb _ := (random_oracle_init (ret_both (tt : 'unit))) : both _ _ ('unit) in
    letb _ := (ret_both (tt : 'unit)) : both _ _ ('unit) in
    letb '(QUERIES,eu) := (random_oracle_query QUERIES (prod_assoc (prod_b (h,a)))) : both _ _ ((t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState) × (t_G × t_G))) in
    letb e := (Build_t_Q (ret_both (1 : int32))) : both _ _ (t_Q) in
    letb z := (v_Response h w a e) : both _ _ (t_Q) in
    solve_lift (prod_b (h,a,e,z)) : both (L1 :|: fset [commit_loc]) (I1) ((t_G × t_G × t_Q × t_Q)).
Fail Next Obligation.
