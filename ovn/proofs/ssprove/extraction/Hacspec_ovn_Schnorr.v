(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_lib.

Require Import Std. (* as HashMap *)

(*Not implemented yet? todo(item)*)

Require Import Hacspec_ovn_Schnorr_Random_oracle.

Notation t_Transcript := ((t_G × t_G × t_Q × t_Q)).

Program Definition prod_assoc {L1 : {fset Location}} {I1 : Interface} (sm : both L1 I1 ((t_G × t_G))) : both (L1) (I1) (t_Q) :=
  letb '(statement,message) := (sm) : both _ _ ((t_G × t_G)) in
  Build_t_Q i32(1).
Fail Next Obligation.

Program Definition verify {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (h : both L1 I1 (t_G)) (a : both L2 I2 (t_G)) (e : both L3 I3 (t_Q)) (z : both L4 I4 (t_Q)) : both (L1:|:L2:|:L3:|:L4) (I1:|:I2:|:I3:|:I4) ('bool) :=
  false.
Fail Next Obligation.

Program Definition fiat_shamir_verify {L1 : {fset Location}} {I1 : Interface} (t : both L1 I1 ((t_G × t_G × t_Q × t_Q))) : both (L1) (I1) ('bool) :=
  letb QUERIES := (new_under_impl) : both _ _ (t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState)) in
  letb '(h,a,e,z) := (t) : both _ _ ((t_G × t_G × t_Q × t_Q)) in
  letb '(QUERIES,eu) := (random_oracle_query QUERIES (prod_assoc (prod_b (h,a)))) : both _ _ ((t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState) × (t_G × t_G))) in
  verify h a e z.
Fail Next Obligation.

Notation t_Relation := ((t_G × t_Q)).

Definition commit_loc : Location :=
  ((t_G × t_G) ; 0%nat).
Program Definition v_Commit {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (h : both L1 I1 (t_G)) (w : both L2 I2 (t_Q)) : both (L1:|:L2 :|: fset [commit_loc]) (I1:|:I2) (t_G) :=
  letb r := (sample_uniform) : both _ _ ((t_G × t_G)) in
  letbm commit loc(commit_loc) := (r) : both _ _ ((t_G × t_G)) in
  Build_t_G i32(1).
Fail Next Obligation.

Program Definition v_Response {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (h : both L1 I1 (t_G)) (w : both L2 I2 (t_Q)) (a : both L3 I3 (t_G)) (e : both L4 I4 (t_Q)) : both (L1:|:L2:|:L3:|:L4) (I1:|:I2:|:I3:|:I4) (t_Q) :=
  Build_t_Q i32(1).
Fail Next Obligation.

Program Definition fiat_shamir_run {L1 : {fset Location}} {I1 : Interface} (hw : both L1 I1 ((t_G × t_Q))) : both (L1 :|: fset [commit_loc]) (I1) ((t_G × t_G × t_Q × t_Q)) :=
  letb QUERIES := (new_under_impl) : both _ _ (t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState)) in
  letb '(h,w) := (hw) : both _ _ ((t_G × t_Q)) in
  letb a := (v_Commit h w) : both _ _ (t_G) in
  letb 'tt := (random_oracle_init (ret_both (tt : 'unit))) : both _ _ ('unit) in
  letb _ := (ret_both (tt : 'unit)) : both _ _ ('unit) in
  letb '(QUERIES,eu) := (random_oracle_query QUERIES (prod_assoc (prod_b (h,a)))) : both _ _ ((t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState) × (t_G × t_G))) in
  letb e := (Build_t_Q i32(1)) : both _ _ (t_Q) in
  letb z := (v_Response h w a e) : both _ _ (t_Q) in
  prod_b (h,a,e,z).
Fail Next Obligation.
