(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: prelude_import _  **)

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: macro_use _  **)
(*Not implemented yet? todo(item)*)

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: macro_use _  **)
(*Not implemented yet? todo(item)*)

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Require Import Hacspec_concordium.
Export Hacspec_concordium.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Require Import Hacspec_concordium_derive.
Export Hacspec_concordium_derive.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
DocComment:  Interface for group implementation  **)
Class t_Group (Self : choice_type) := {
  t_group_type : choice_type ;
  t_group_type_t_Group :> t_Group (t_group_type) ;
  q : forall {L0 I0}, both L0 I0 (int32) ;
  g : forall {L0 I0}, both L0 I0 (t_group_type) ;
  g_pow : forall {L0 I0}, both L0 I0 (int32) -> both L0 I0 (t_group_type) ;
  pow : forall {L0 L1 I0 I1}, both L0 I0 (t_group_type) -> both L1 I1 (int32) -> both (L0 :|: L1) (I0 :|: I1) (t_group_type) ;
  one : forall {L0 I0}, both L0 I0 (t_group_type) ;
  prod : forall {L0 L1 I0 I1}, both L0 I0 (t_group_type) -> both L1 I1 (t_group_type) -> both (L0 :|: L1) (I0 :|: I1) (t_group_type) ;
  inv : forall {L0 I0}, both L0 I0 (t_group_type) -> both L0 I0 (t_group_type) ;
  div : forall {L0 L1 I0 I1}, both L0 I0 (t_group_type) -> both L1 I1 (t_group_type) -> both (L0 :|: L1) (I0 :|: I1) (t_group_type) ;
}.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Definition t_z_17_ : choice_type :=
  'unit.
Equations Build_t_z_17_ {L : {fset Location}} {I : Interface} : both L I (t_z_17_) :=
  Build_t_z_17_  :=
    solve_lift (ret_both ((!TODO empty tuple!) : (t_z_17_))) : both L I (t_z_17_).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
#[global] Instance t_z_17__t_Group : t_Group t_z_17_ := {
  t_group_type := int32;
  q := solve_lift (ret_both (17 : int32));
  g := solve_lift (ret_both (3 : int32));
  g_pow (x : int32) := solve_lift ((g .^ x) .% q);
  pow (g : int32) (x : int32) := solve_lift ((g .^ x) .% q);
  one := solve_lift (ret_both (1 : int32));
  prod (x : int32) (y : int32) := solve_lift ((x .* y) .% q);
  inv (x : int32) := letbm res loc(res_loc) := ret_both (0 : int32) :of: int32 in
  letb res := foldi_both_list (into_iter (Build_t_Range  (ret_both (1 : int32)) q)) (fun {L I _ _} =>fun i =>
      ssp (fun res =>
        solve_lift (ifb (pow g i) =.? x
        then i
        else res))) res :of: int32 in
  solve_lift (q .- res);
  div (x : int32) (y : int32) := solve_lift (prod x (inv y));
}.

(*item error backend*)

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: export_name _  **)
Definition state_bytes_loc : Location :=
  (t_ContractState ; 0%nat).
Equations export_init_ovn_contract {L1 : {fset Location}} {I1 : Interface} (amount : both L1 I1 (t_Amount)) : both (L1 :|: fset [state_bytes_loc]) (I1) (int32) :=
  export_init_ovn_contract amount  :=
    solve_lift (run (letb _ := ifb (f_micro_ccd amount) <> (ret_both (0 : int64))
      then letb hoist1 := v_Break (ret_both (1 : int32)) :of: t_Never in
        ControlFlow_Continue (never_to_any hoist1)
      else ControlFlow_Continue (ret_both (tt : 'unit)) :of: 'unit in
    ControlFlow_Continue (letb ctx := open (ret_both (tt : 'unit)) :of: t_ExternContext (t_InitContextExtern) in
    matchb init_ovn_contract ctx with
    | Result_Ok state =>
      letbm state_bytes loc(state_bytes_loc) := open (ret_both (tt : 'unit)) :of: t_ContractState in
      letb '(tmp0,out) := serial state state_bytes :of: (t_ContractState × t_Result ('unit) (t_Err)) in
      letb state_bytes := tmp0 :of: t_ContractState in
      letb hoist2 := out :of: (t_ContractState × t_Result ('unit) (t_Err)) in
      letb hoist3 := is_err_under_impl hoist2 :of: 'bool in
      letb _ := ifb hoist3
        then never_to_any trap
        else ret_both (tt : 'unit) :of: 'unit in
      ret_both (0 : int32)
    | Result_Err reject =>
      letb code := get_under_impl_56 (f_error_code (from reject)) :of: int32 in
      ifb code <.? (ret_both (0 : int32))
      then code
      else never_to_any trap
    end))) : both (L1 :|: fset [state_bytes_loc]) (I1) (int32).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Equations init_ovn_contract {impl HasInitContext : _} `{ t_Sized (impl HasInitContext)} `{ t_HasInitContext (impl HasInitContext) ('unit)} {L1 : {fset Location}} {I1 : Interface} (ctx : both L1 I1 (impl HasInitContext)) : both (L1) (I1) (t_Result ('bool) ('unit)) :=
  init_ovn_contract ctx  :=
    Result_Ok (solve_lift (ret_both (true : 'bool))) : both (L1) (I1) (t_Result ('bool) ('unit)).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
DocComment:  Currently randomness needs to be injected  **)
Equations select_private_voting_key {G : _} `{ t_Sized (G)} `{ t_Group (G)} {L1 : {fset Location}} {I1 : Interface} (random : both L1 I1 (int32)) : both (L1) (I1) (int32) :=
  select_private_voting_key random  :=
    solve_lift (random .% q) : both (L1) (I1) (int32).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
DocComment:  TODO: Non-interactive Schnorr proof using Fiat-Shamir heuristics  **)
Equations v_ZKP {G : _} `{ t_Sized (G)} `{ t_Group (G)} {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi : both L1 I1 (t_group_type)) (xi : both L2 I2 (int32)) : both (L1:|:L2) (I1:|:I2) (int32) :=
  v_ZKP g_pow_xi xi  :=
    solve_lift (ret_both (0 : int32)) : both (L1:|:L2) (I1:|:I2) (int32).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Definition t_RegisterParam : choice_type :=
  (int32 × int32).
Equations Build_t_RegisterParam {L : {fset Location}} {I : Interface} (f_i : both L I (int32)) (f_xi : both L I (int32)) : both L I (t_RegisterParam) :=
  Build_t_RegisterParam f_i f_xi  :=
    bind_both f_xi (fun f_xi =>
      bind_both f_i (fun f_i =>
        solve_lift (ret_both ((f_i,f_xi) : (t_RegisterParam))))) : both L I (t_RegisterParam).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Notation t_G := (t_z_17_).

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Equations n : both (fset []) ([interface ]) (uint_size) :=
  n  :=
    solve_lift (ret_both (20 : uint_size)) : both (fset []) ([interface ]) (uint_size).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: export_name _  **)
Equations export_register_vote {L1 : {fset Location}} {I1 : Interface} (amount : both L1 I1 (t_Amount)) : both (L1) (I1) (int32) :=
  export_register_vote amount  :=
    solve_lift (failure (ret_both ((LocalMutation) The bindings ["state_bytes"] cannot be mutated here: they don't belong to the closure scope, and this is not allowed.
 : chString)) (ret_both ({
        let _: tuple0 = {
            (if core::cmp::PartialEq::ne(
                proj_concordium_contracts_common::types::Amount::f_micro_ccd(amount),
                0,
            ) {
                {
                    let hoist4: rust_primitives::hax::t_Never = { (return 1) };
                    rust_primitives::hax::never_to_any(hoist4)
                }
            })
        };
        {
            let ctx: hacspec_concordium::concordium_types::t_ExternContext<
                hacspec_concordium::concordium_types::t_ReceiveContextExtern,
            > = { hacspec_concordium::concordium_traits::HasReceiveContext::open(Tuple0()) };
            {
                let mut state_bytes: hacspec_concordium::concordium_types::t_ContractState =
                    { hacspec_concordium::concordium_traits::HasContractState::open(Tuple0()) };
                {
                    let Tuple2(tmp0, out): tuple2<
                        hacspec_concordium::concordium_types::t_ContractState,
                        core::result::t_Result<
                            hacspec_ovn::t_OvnContractState<
                                hacspec_ovn::t_z_17_,
                                generic_value!(todo),
                            >,
                            concordium_contracts_common::types::t_ParseError,
                        >,
                    > = { concordium_contracts_common::traits::Get::get(state_bytes) };
                    {
                        let _: tuple0 = { (state_bytes = tmp0) };
                        {
                            let hoist7: tuple2<
                                hacspec_concordium::concordium_types::t_ContractState,
                                core::result::t_Result<
                                    hacspec_ovn::t_OvnContractState<
                                        hacspec_ovn::t_z_17_,
                                        generic_value!(todo),
                                    >,
                                    concordium_contracts_common::types::t_ParseError,
                                >,
                            > = { out };
                            (match hoist7 {
                                core::result::Result_Ok(mut state) => {
                                    let pat_ascription!(
                                        res as core::result::t_Result<
                                            tuple2<
                                                hacspec_concordium::concordium_types::t_Action,
                                                hacspec_ovn::t_OvnContractState<
                                                    hacspec_ovn::t_z_17_,
                                                    generic_value!(todo),
                                                >,
                                            >,
                                            concordium_contracts_common::types::t_ParseError,
                                        >
                                    ): core::result::t_Result<
                                        tuple2<
                                            hacspec_concordium::concordium_types::t_Action,
                                            hacspec_ovn::t_OvnContractState<
                                                hacspec_ovn::t_z_17_,
                                                generic_value!(todo),
                                            >,
                                        >,
                                        concordium_contracts_common::types::t_ParseError,
                                    > = { hacspec_ovn::register_vote(ctx, state) };
                                    (match res {
                                        core::result::Result_Ok(Tuple2(act, state_res)) => {
                                            let _: tuple0 = { (state = state_res) };
                                            {
                                                let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {concordium_contracts_common::traits::Seek::seek(state_bytes,concordium_contracts_common::traits::SeekFrom_Start(0))};
                                                {
                                                    let _: tuple0 = { (state_bytes = tmp0) };
                                                    {
                                                        let hoist6: tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {out};
                                                        {
                                                            let hoist5: arrow!(int -> core::result::t_Result<tuple0, tuple0>) = {
                                                                (|_| {
                                                                    let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<tuple0, concordium_contracts_common::traits::Write::t_Err>> = {concordium_contracts_common::traits::Serial::serial(state,state_bytes)};
                                                                    {
                                                                        let _: tuple0 = {
                                                                            (state_bytes = tmp0)
                                                                        };
                                                                        out
                                                                    }
                                                                })
                                                            };
                                                            {
                                                                let res: core::result::t_Result<
                                                                    tuple0,
                                                                    tuple0,
                                                                > = {
                                                                    core::result::and_then_under_impl(hoist6,hoist5)
                                                                };
                                                                (if core::result::is_err_under_impl(
                                                                    res,
                                                                ) {
                                                                    rust_primitives::hax::never_to_any(hacspec_concordium::trap())
                                                                } else {
                                                                    cast(hacspec_concordium::concordium_types::tag_under_impl(act))
                                                                })
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        core::result::Result_Err(reject) => {
                                            let code: int = {
                                                core::num::nonzero::get_under_impl_56(proj_hacspec_concordium::concordium_types::Reject::f_error_code(core::convert::From::from(reject)))
                                            };
                                            (if core::cmp::PartialOrd::lt(code, 0) {
                                                code
                                            } else {
                                                rust_primitives::hax::never_to_any(
                                                    hacspec_concordium::trap(),
                                                )
                                            })
                                        }
                                    })
                                }
                                _ => rust_primitives::hax::never_to_any(hacspec_concordium::trap()),
                            })
                        }
                    }
                }
            }
        }
    } : chString))) : both (L1) (I1) (int32).
Fail Next Obligation.

(*item error backend*)

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Definition t_CastVoteParam : choice_type :=
  (int32 × int32 × 'bool).
Equations Build_t_CastVoteParam {L : {fset Location}} {I : Interface} (f_i : both L I (int32)) (f_xi : both L I (int32)) (f_vote : both L I ('bool)) : both L I (t_CastVoteParam) :=
  Build_t_CastVoteParam f_i f_xi f_vote  :=
    bind_both f_vote (fun f_vote =>
      bind_both f_xi (fun f_xi =>
        bind_both f_i (fun f_i =>
          solve_lift (ret_both ((f_i,f_xi,f_vote) : (t_CastVoteParam)))))) : both L I (t_CastVoteParam).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Equations check_valid {L1 : {fset Location}} {I1 : Interface} (zkp : both L1 I1 (int32)) : both (L1) (I1) ('bool) :=
  check_valid zkp  :=
    solve_lift (ret_both (true : 'bool)) : both (L1) (I1) ('bool).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Definition prod2_loc {G : _} `{ t_Sized (G)} `{ t_Group (G)} : Location :=
  (t_group_type ; 3%nat).
Definition prod1_loc {G : _} `{ t_Sized (G)} `{ t_Group (G)} : Location :=
  (t_group_type ; 2%nat).
Equations compute_group_element_for_vote {G : _} `{ t_Sized (G)} `{ t_Group (G)} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (i : both L1 I1 (int32)) (xi : both L2 I2 (int32)) (vote : both L3 I3 ('bool)) (xis : both L4 I4 (nseq t_group_type 20)) : both (L1:|:L2:|:L3:|:L4 :|: fset [prod1_loc; prod2_loc]) (I1:|:I2:|:I3:|:I4) (t_group_type) :=
  compute_group_element_for_vote i xi vote xis  :=
    letbm prod1 loc(prod1_loc) := one :of: t_group_type in
    letb prod1 := foldi_both_list (into_iter (Build_t_Range  (ret_both (0 : uint_size)) (cast_int (i .- (ret_both (1 : int32)))))) (fun {L I _ _} =>fun j =>
        ssp (fun prod1 =>
          solve_lift (prod prod1 (xis.a[j])))) prod1 :of: t_group_type in
    letbm prod2 loc(prod2_loc) := one :of: t_group_type in
    letb prod2 := foldi_both_list (into_iter (Build_t_Range  (cast_int (i .+ (ret_both (1 : int32)))) n)) (fun {L I _ _} =>fun j =>
        ssp (fun prod2 =>
          solve_lift (prod prod2 (xis.a[j])))) prod2 :of: t_group_type in
    letb Yi := div prod1 prod2 :of: t_group_type in
    solve_lift (prod (pow Yi xi) (g_pow (ifb vote
    then ret_both (1 : int32)
    else ret_both (0 : int32)))) : both (L1:|:L2:|:L3:|:L4 :|: fset [prod1_loc; prod2_loc]) (I1:|:I2:|:I3:|:I4) (t_group_type).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Equations commit_to {G : _} `{ t_Sized (G)} `{ t_Group (G)} {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_group_type)) : both (L1) (I1) (int32) :=
  commit_to x  :=
    solve_lift (ret_both (0 : int32)) : both (L1) (I1) (int32).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: export_name _  **)
Equations export_commit_to_vote {L1 : {fset Location}} {I1 : Interface} (amount : both L1 I1 (t_Amount)) : both (L1) (I1) (int32) :=
  export_commit_to_vote amount  :=
    solve_lift (failure (ret_both ((LocalMutation) The bindings ["state_bytes"] cannot be mutated here: they don't belong to the closure scope, and this is not allowed.
 : chString)) (ret_both ({
        let _: tuple0 = {
            (if core::cmp::PartialEq::ne(
                proj_concordium_contracts_common::types::Amount::f_micro_ccd(amount),
                0,
            ) {
                {
                    let hoist9: rust_primitives::hax::t_Never = { (return 1) };
                    rust_primitives::hax::never_to_any(hoist9)
                }
            })
        };
        {
            let ctx: hacspec_concordium::concordium_types::t_ExternContext<
                hacspec_concordium::concordium_types::t_ReceiveContextExtern,
            > = { hacspec_concordium::concordium_traits::HasReceiveContext::open(Tuple0()) };
            {
                let mut state_bytes: hacspec_concordium::concordium_types::t_ContractState =
                    { hacspec_concordium::concordium_traits::HasContractState::open(Tuple0()) };
                {
                    let Tuple2(tmp0, out): tuple2<
                        hacspec_concordium::concordium_types::t_ContractState,
                        core::result::t_Result<
                            hacspec_ovn::t_OvnContractState<
                                hacspec_ovn::t_z_17_,
                                generic_value!(todo),
                            >,
                            concordium_contracts_common::types::t_ParseError,
                        >,
                    > = { concordium_contracts_common::traits::Get::get(state_bytes) };
                    {
                        let _: tuple0 = { (state_bytes = tmp0) };
                        {
                            let hoist12: tuple2<
                                hacspec_concordium::concordium_types::t_ContractState,
                                core::result::t_Result<
                                    hacspec_ovn::t_OvnContractState<
                                        hacspec_ovn::t_z_17_,
                                        generic_value!(todo),
                                    >,
                                    concordium_contracts_common::types::t_ParseError,
                                >,
                            > = { out };
                            (match hoist12 {
                                core::result::Result_Ok(mut state) => {
                                    let pat_ascription!(
                                        res as core::result::t_Result<
                                            tuple2<
                                                hacspec_concordium::concordium_types::t_Action,
                                                hacspec_ovn::t_OvnContractState<
                                                    hacspec_ovn::t_z_17_,
                                                    generic_value!(todo),
                                                >,
                                            >,
                                            concordium_contracts_common::types::t_ParseError,
                                        >
                                    ): core::result::t_Result<
                                        tuple2<
                                            hacspec_concordium::concordium_types::t_Action,
                                            hacspec_ovn::t_OvnContractState<
                                                hacspec_ovn::t_z_17_,
                                                generic_value!(todo),
                                            >,
                                        >,
                                        concordium_contracts_common::types::t_ParseError,
                                    > = { hacspec_ovn::commit_to_vote(ctx, state) };
                                    (match res {
                                        core::result::Result_Ok(Tuple2(act, state_res)) => {
                                            let _: tuple0 = { (state = state_res) };
                                            {
                                                let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {concordium_contracts_common::traits::Seek::seek(state_bytes,concordium_contracts_common::traits::SeekFrom_Start(0))};
                                                {
                                                    let _: tuple0 = { (state_bytes = tmp0) };
                                                    {
                                                        let hoist11: tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {out};
                                                        {
                                                            let hoist10: arrow!(int -> core::result::t_Result<tuple0, tuple0>) = {
                                                                (|_| {
                                                                    let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<tuple0, concordium_contracts_common::traits::Write::t_Err>> = {concordium_contracts_common::traits::Serial::serial(state,state_bytes)};
                                                                    {
                                                                        let _: tuple0 = {
                                                                            (state_bytes = tmp0)
                                                                        };
                                                                        out
                                                                    }
                                                                })
                                                            };
                                                            {
                                                                let res: core::result::t_Result<
                                                                    tuple0,
                                                                    tuple0,
                                                                > = {
                                                                    core::result::and_then_under_impl(hoist11,hoist10)
                                                                };
                                                                (if core::result::is_err_under_impl(
                                                                    res,
                                                                ) {
                                                                    rust_primitives::hax::never_to_any(hacspec_concordium::trap())
                                                                } else {
                                                                    cast(hacspec_concordium::concordium_types::tag_under_impl(act))
                                                                })
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        core::result::Result_Err(reject) => {
                                            let code: int = {
                                                core::num::nonzero::get_under_impl_56(proj_hacspec_concordium::concordium_types::Reject::f_error_code(core::convert::From::from(reject)))
                                            };
                                            (if core::cmp::PartialOrd::lt(code, 0) {
                                                code
                                            } else {
                                                rust_primitives::hax::never_to_any(
                                                    hacspec_concordium::trap(),
                                                )
                                            })
                                        }
                                    })
                                }
                                _ => rust_primitives::hax::never_to_any(hacspec_concordium::trap()),
                            })
                        }
                    }
                }
            }
        }
    } : chString))) : both (L1) (I1) (int32).
Fail Next Obligation.

(*item error backend*)

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
DocComment:  Cramer, Damgård and Schoenmakers (CDS) technique  **)
Equations v_ZKP_one_out_of_two {G : _} `{ t_Sized (G)} `{ t_Group (G)} {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_vi : both L1 I1 (t_group_type)) (vi : both L2 I2 ('bool)) : both (L1:|:L2) (I1:|:I2) (int32) :=
  v_ZKP_one_out_of_two g_pow_vi vi  :=
    solve_lift (ret_both (32 : int32)) : both (L1:|:L2) (I1:|:I2) (int32).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: export_name _  **)
Equations export_cast_vote {L1 : {fset Location}} {I1 : Interface} (amount : both L1 I1 (t_Amount)) : both (L1) (I1) (int32) :=
  export_cast_vote amount  :=
    solve_lift (failure (ret_both ((LocalMutation) The bindings ["state_bytes"] cannot be mutated here: they don't belong to the closure scope, and this is not allowed.
 : chString)) (ret_both ({
        let _: tuple0 = {
            (if core::cmp::PartialEq::ne(
                proj_concordium_contracts_common::types::Amount::f_micro_ccd(amount),
                0,
            ) {
                {
                    let hoist14: rust_primitives::hax::t_Never = { (return 1) };
                    rust_primitives::hax::never_to_any(hoist14)
                }
            })
        };
        {
            let ctx: hacspec_concordium::concordium_types::t_ExternContext<
                hacspec_concordium::concordium_types::t_ReceiveContextExtern,
            > = { hacspec_concordium::concordium_traits::HasReceiveContext::open(Tuple0()) };
            {
                let mut state_bytes: hacspec_concordium::concordium_types::t_ContractState =
                    { hacspec_concordium::concordium_traits::HasContractState::open(Tuple0()) };
                {
                    let Tuple2(tmp0, out): tuple2<
                        hacspec_concordium::concordium_types::t_ContractState,
                        core::result::t_Result<
                            hacspec_ovn::t_OvnContractState<
                                hacspec_ovn::t_z_17_,
                                generic_value!(todo),
                            >,
                            concordium_contracts_common::types::t_ParseError,
                        >,
                    > = { concordium_contracts_common::traits::Get::get(state_bytes) };
                    {
                        let _: tuple0 = { (state_bytes = tmp0) };
                        {
                            let hoist17: tuple2<
                                hacspec_concordium::concordium_types::t_ContractState,
                                core::result::t_Result<
                                    hacspec_ovn::t_OvnContractState<
                                        hacspec_ovn::t_z_17_,
                                        generic_value!(todo),
                                    >,
                                    concordium_contracts_common::types::t_ParseError,
                                >,
                            > = { out };
                            (match hoist17 {
                                core::result::Result_Ok(mut state) => {
                                    let pat_ascription!(
                                        res as core::result::t_Result<
                                            tuple2<
                                                hacspec_concordium::concordium_types::t_Action,
                                                hacspec_ovn::t_OvnContractState<
                                                    hacspec_ovn::t_z_17_,
                                                    generic_value!(todo),
                                                >,
                                            >,
                                            concordium_contracts_common::types::t_ParseError,
                                        >
                                    ): core::result::t_Result<
                                        tuple2<
                                            hacspec_concordium::concordium_types::t_Action,
                                            hacspec_ovn::t_OvnContractState<
                                                hacspec_ovn::t_z_17_,
                                                generic_value!(todo),
                                            >,
                                        >,
                                        concordium_contracts_common::types::t_ParseError,
                                    > = { hacspec_ovn::cast_vote(ctx, state) };
                                    (match res {
                                        core::result::Result_Ok(Tuple2(act, state_res)) => {
                                            let _: tuple0 = { (state = state_res) };
                                            {
                                                let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {concordium_contracts_common::traits::Seek::seek(state_bytes,concordium_contracts_common::traits::SeekFrom_Start(0))};
                                                {
                                                    let _: tuple0 = { (state_bytes = tmp0) };
                                                    {
                                                        let hoist16: tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {out};
                                                        {
                                                            let hoist15: arrow!(int -> core::result::t_Result<tuple0, tuple0>) = {
                                                                (|_| {
                                                                    let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<tuple0, concordium_contracts_common::traits::Write::t_Err>> = {concordium_contracts_common::traits::Serial::serial(state,state_bytes)};
                                                                    {
                                                                        let _: tuple0 = {
                                                                            (state_bytes = tmp0)
                                                                        };
                                                                        out
                                                                    }
                                                                })
                                                            };
                                                            {
                                                                let res: core::result::t_Result<
                                                                    tuple0,
                                                                    tuple0,
                                                                > = {
                                                                    core::result::and_then_under_impl(hoist16,hoist15)
                                                                };
                                                                (if core::result::is_err_under_impl(
                                                                    res,
                                                                ) {
                                                                    rust_primitives::hax::never_to_any(hacspec_concordium::trap())
                                                                } else {
                                                                    cast(hacspec_concordium::concordium_types::tag_under_impl(act))
                                                                })
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        core::result::Result_Err(reject) => {
                                            let code: int = {
                                                core::num::nonzero::get_under_impl_56(proj_hacspec_concordium::concordium_types::Reject::f_error_code(core::convert::From::from(reject)))
                                            };
                                            (if core::cmp::PartialOrd::lt(code, 0) {
                                                code
                                            } else {
                                                rust_primitives::hax::never_to_any(
                                                    hacspec_concordium::trap(),
                                                )
                                            })
                                        }
                                    })
                                }
                                _ => rust_primitives::hax::never_to_any(hacspec_concordium::trap()),
                            })
                        }
                    }
                }
            }
        }
    } : chString))) : both (L1) (I1) (int32).
Fail Next Obligation.

(*item error backend*)

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Equations check_valid2 {G : _} `{ t_Sized (G)} `{ t_Group (G)} {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi_yi_vi : both L1 I1 (t_group_type)) (zkp : both L2 I2 (int32)) : both (L1:|:L2) (I1:|:I2) ('bool) :=
  check_valid2 g_pow_xi_yi_vi zkp  :=
    solve_lift (ret_both (true : 'bool)) : both (L1:|:L2) (I1:|:I2) ('bool).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Equations check_commitment {G : _} `{ t_Sized (G)} `{ t_Group (G)} {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi_yi_vi : both L1 I1 (t_group_type)) (zkp : both L2 I2 (int32)) : both (L1:|:L2) (I1:|:I2) ('bool) :=
  check_commitment g_pow_xi_yi_vi zkp  :=
    solve_lift (ret_both (true : 'bool)) : both (L1:|:L2) (I1:|:I2) ('bool).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax **)
Definition t_TallyParameter : choice_type :=
  'unit.
Equations Build_t_TallyParameter {L : {fset Location}} {I : Interface} : both L I (t_TallyParameter) :=
  Build_t_TallyParameter  :=
    solve_lift (ret_both ((!TODO empty tuple!) : (t_TallyParameter))) : both L I (t_TallyParameter).
Fail Next Obligation.

(** Tool: no_std _ 
Tool: feature _ register_tool
Tool: register_tool _ _hax
Tool: export_name _  **)
Equations export_tally_votes {L1 : {fset Location}} {I1 : Interface} (amount : both L1 I1 (t_Amount)) : both (L1) (I1) (int32) :=
  export_tally_votes amount  :=
    solve_lift (failure (ret_both ((LocalMutation) The bindings ["state_bytes"] cannot be mutated here: they don't belong to the closure scope, and this is not allowed.
 : chString)) (ret_both ({
        let _: tuple0 = {
            (if core::cmp::PartialEq::ne(
                proj_concordium_contracts_common::types::Amount::f_micro_ccd(amount),
                0,
            ) {
                {
                    let hoist19: rust_primitives::hax::t_Never = { (return 1) };
                    rust_primitives::hax::never_to_any(hoist19)
                }
            })
        };
        {
            let ctx: hacspec_concordium::concordium_types::t_ExternContext<
                hacspec_concordium::concordium_types::t_ReceiveContextExtern,
            > = { hacspec_concordium::concordium_traits::HasReceiveContext::open(Tuple0()) };
            {
                let mut state_bytes: hacspec_concordium::concordium_types::t_ContractState =
                    { hacspec_concordium::concordium_traits::HasContractState::open(Tuple0()) };
                {
                    let Tuple2(tmp0, out): tuple2<
                        hacspec_concordium::concordium_types::t_ContractState,
                        core::result::t_Result<
                            hacspec_ovn::t_OvnContractState<
                                hacspec_ovn::t_z_17_,
                                generic_value!(todo),
                            >,
                            concordium_contracts_common::types::t_ParseError,
                        >,
                    > = { concordium_contracts_common::traits::Get::get(state_bytes) };
                    {
                        let _: tuple0 = { (state_bytes = tmp0) };
                        {
                            let hoist22: tuple2<
                                hacspec_concordium::concordium_types::t_ContractState,
                                core::result::t_Result<
                                    hacspec_ovn::t_OvnContractState<
                                        hacspec_ovn::t_z_17_,
                                        generic_value!(todo),
                                    >,
                                    concordium_contracts_common::types::t_ParseError,
                                >,
                            > = { out };
                            (match hoist22 {
                                core::result::Result_Ok(mut state) => {
                                    let pat_ascription!(
                                        res as core::result::t_Result<
                                            tuple2<
                                                hacspec_concordium::concordium_types::t_Action,
                                                hacspec_ovn::t_OvnContractState<
                                                    hacspec_ovn::t_z_17_,
                                                    generic_value!(todo),
                                                >,
                                            >,
                                            concordium_contracts_common::types::t_ParseError,
                                        >
                                    ): core::result::t_Result<
                                        tuple2<
                                            hacspec_concordium::concordium_types::t_Action,
                                            hacspec_ovn::t_OvnContractState<
                                                hacspec_ovn::t_z_17_,
                                                generic_value!(todo),
                                            >,
                                        >,
                                        concordium_contracts_common::types::t_ParseError,
                                    > = { hacspec_ovn::tally_votes(ctx, state) };
                                    (match res {
                                        core::result::Result_Ok(Tuple2(act, state_res)) => {
                                            let _: tuple0 = { (state = state_res) };
                                            {
                                                let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {concordium_contracts_common::traits::Seek::seek(state_bytes,concordium_contracts_common::traits::SeekFrom_Start(0))};
                                                {
                                                    let _: tuple0 = { (state_bytes = tmp0) };
                                                    {
                                                        let hoist21: tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<int, concordium_contracts_common::traits::Seek::t_Err>> = {out};
                                                        {
                                                            let hoist20: arrow!(int -> core::result::t_Result<tuple0, tuple0>) = {
                                                                (|_| {
                                                                    let Tuple2(tmp0, out): tuple2<hacspec_concordium::concordium_types::t_ContractState, core::result::t_Result<tuple0, concordium_contracts_common::traits::Write::t_Err>> = {concordium_contracts_common::traits::Serial::serial(state,state_bytes)};
                                                                    {
                                                                        let _: tuple0 = {
                                                                            (state_bytes = tmp0)
                                                                        };
                                                                        out
                                                                    }
                                                                })
                                                            };
                                                            {
                                                                let res: core::result::t_Result<
                                                                    tuple0,
                                                                    tuple0,
                                                                > = {
                                                                    core::result::and_then_under_impl(hoist21,hoist20)
                                                                };
                                                                (if core::result::is_err_under_impl(
                                                                    res,
                                                                ) {
                                                                    rust_primitives::hax::never_to_any(hacspec_concordium::trap())
                                                                } else {
                                                                    cast(hacspec_concordium::concordium_types::tag_under_impl(act))
                                                                })
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        core::result::Result_Err(reject) => {
                                            let code: int = {
                                                core::num::nonzero::get_under_impl_56(proj_hacspec_concordium::concordium_types::Reject::f_error_code(core::convert::From::from(reject)))
                                            };
                                            (if core::cmp::PartialOrd::lt(code, 0) {
                                                code
                                            } else {
                                                rust_primitives::hax::never_to_any(
                                                    hacspec_concordium::trap(),
                                                )
                                            })
                                        }
                                    })
                                }
                                _ => rust_primitives::hax::never_to_any(hacspec_concordium::trap()),
                            })
                        }
                    }
                }
            }
        }
    } : chString))) : both (L1) (I1) (int32).
Fail Next Obligation.

(*item error backend*)
