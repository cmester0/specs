(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Require Import ConCertLib.
From ConCert.Execution Require Import Serializable.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Class t_Group (Self : choice_type) := {
  t_group_type : choice_type ;
  t_group_type_t_Serialize :> t_Serialize (t_group_type) ;
  t_group_type_t_Deserial :> t_Deserial (t_group_type) ;
  t_group_type_t_Serial :> t_Serial (t_group_type) ;
  t_group_type_t_Copy :> t_Copy (t_group_type) ;
  t_group_type_t_Clone :> t_Clone (t_group_type) ;
  t_group_type_t_Eq :> t_Eq (t_group_type) ;
  t_group_type_t_PartialEq :> t_PartialEq (t_group_type) ;
  t_group_type_t_Sized :> t_Sized (t_group_type) ;
  q : forall {L1 I1}, both L1 I1 (int32) ;
  g : forall {L1 I1}, both L1 I1 (t_group_type) ;
  g_pow_loc : {fset Location} ;
  g_pow : forall {L1 I1}, both L1 I1 (int32) -> both (L1 :|: g_pow_loc) I1 (t_group_type) ;
  pow_loc : {fset Location} ;
  pow : forall {L1 L2 I1 I2}, both L1 I1 (t_group_type) -> both L2 I2 (int32) -> both (L1 :|: L2 :|: pow_loc) (I1 :|: I2) (t_group_type) ;
  one_loc : {fset Location} ;
  one : forall {L1 I1}, both (L1 :|: one_loc) I1 (t_group_type) ;
  prod_loc : {fset Location} ;
  prod : forall {L1 L2 I1 I2}, both L1 I1 (t_group_type) -> both L2 I2 (t_group_type) -> both (L1 :|: L2 :|: prod_loc) (I1 :|: I2) (t_group_type) ;
  inv_loc : {fset Location} ;
  inv : forall {L1 I1}, both L1 I1 (t_group_type) -> both (L1 :|: inv_loc) I1 (t_group_type) ;
  div_loc : {fset Location} ;
  div : forall {L1 L2 I1 I2}, both L1 I1 (t_group_type) -> both L2 I2 (t_group_type) -> both (L1 :|: L2 :|: div_loc) (I1 :|: I2) (t_group_type) ;
}.
Hint Unfold g_pow_loc.
Hint Unfold pow_loc.
Hint Unfold one_loc.
Hint Unfold prod_loc.
Hint Unfold inv_loc.
Hint Unfold div_loc.

Definition t_z_17_ : choice_type :=
  'unit.
Equations Build_t_z_17_ : both (fset []) (fset []) (t_z_17_) :=
  Build_t_z_17_  :=
    solve_lift (ret_both ((_) : (t_z_17_))) : both (fset []) (fset []) (t_z_17_).
Fail Next Obligation.

Definition res_loc : Location :=
  (int32 ; 0%nat).

#[global] Program Instance t_z_17__t_Group : t_Group t_z_17_ :=
  let t_group_type := int32 : choice_type in
  let q := fun  {L : {fset Location}} {I : Interface} => solve_lift (ret_both (17 : int32)) : both L I (int32) in
  let g := fun  {L : {fset Location}} {I : Interface} => solve_lift (ret_both (3 : int32)) : both L I (int32) in
  let g_pow := fun  {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int32)) => solve_lift (((@g (fset []) (fset [])) .^ x) .% (@q (fset[]) (fset[]))) : both (L1 :|: fset []) I1 (int32) in
  let pow := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g : both L1 I1 (int32)) (x : both L2 I2 (int32)) => solve_lift ((g .^ x) .% (@q (fset[]) (fset[]))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) (int32) in
  let one := fun  {L : {fset Location}} {I : Interface} => solve_lift (ret_both (1 : int32)) : both (L :|: fset []) I (int32) in
  let prod := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (x : both L1 I1 (int32)) (y : both L2 I2 (int32)) => solve_lift ((x .* y) .% (@q (fset[]) (fset[]))) : both (L1 :|: L2 :|: fset []) (I1 :|: I2) (int32) in
  let inv := fun  {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int32)) => letb res loc(res_loc) := ret_both (0 : int32) in
  letb res := foldi_both (into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := (@q (fset[]) (fset[]))))) (fun i =>
    ssp (fun res =>
      solve_lift (ifb (g_pow i) =.? x
      then letb res := i in
        res
      else res))) res in
  (* solve_lift *) res : both (L1 :|: fset [res_loc]) I1 (int32) in
  let div := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (x : both L1 I1 (int32)) (y : both L2 I2 (int32)) => solve_lift (prod x (inv y)) : both (L1 :|: L2 :|: fset [res_loc]) (I1 :|: I2) (int32) in{| t_group_type := (@t_group_type);
  q := (@q);
  g := (@g);
  g_pow_loc := (fset [] : {fset Location});
  g_pow := (@g_pow);
  pow_loc := (fset [] : {fset Location});
  pow := (@pow);
  one_loc := (fset [] : {fset Location});
  one := (@one);
  prod_loc := (fset [] : {fset Location});
  prod := (@prod);
  inv_loc := (fset [res_loc] : {fset Location});
  inv := (@inv);
  div_loc := (fset [res_loc] : {fset Location});
  div := (@div);
  t_group_type_t_Eq := int_eqdec
  |}.
Fail Next Obligation.
Hint Unfold t_z_17__t_Group.

Notation "'t_G'" := (t_z_17_).

Equations n {L : {fset Location}} {I : Interface} : both L I (uint_size) :=
  n  :=
    solve_lift (ret_both (20 : uint_size)) : both L I (uint_size).
Fail Next Obligation.

Definition t_OvnContractState : choice_type :=
  (nseq t_group_type 20 × nseq int32 20 × nseq int32 20 × nseq t_group_type 20 × nseq int32 20 × int32).
Equations f_g_pow_xis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq t_group_type 20) :=
  f_g_pow_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst x)))) : nseq t_group_type 20))) : both L I (nseq t_group_type 20).
Fail Next Obligation.
Equations f_zkp_xis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq int32 20) :=
  f_zkp_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : nseq int32 20))) : both L I (nseq int32 20).
Fail Next Obligation.
Equations f_commit_vis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq int32 20) :=
  f_commit_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : nseq int32 20))) : both L I (nseq int32 20).
Fail Next Obligation.
Equations f_g_pow_xi_yi_vis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq t_group_type 20) :=
  f_g_pow_xi_yi_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : nseq t_group_type 20))) : both L I (nseq t_group_type 20).
Fail Next Obligation.
Equations f_zkp_vis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq int32 20) :=
  f_zkp_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : nseq int32 20))) : both L I (nseq int32 20).
Fail Next Obligation.
Equations f_tally {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (int32) :=
  f_tally s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : int32))) : both L I (int32).
Fail Next Obligation.
Equations Build_t_OvnContractState {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {f_g_pow_xis : both L0 I0 (nseq t_group_type 20)} {f_zkp_xis : both L1 I1 (nseq int32 20)} {f_commit_vis : both L2 I2 (nseq int32 20)} {f_g_pow_xi_yi_vis : both L3 I3 (nseq t_group_type 20)} {f_zkp_vis : both L4 I4 (nseq int32 20)} {f_tally : both L5 I5 (int32)} : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_OvnContractState) :=
  Build_t_OvnContractState  :=
    bind_both f_tally (fun f_tally =>
      bind_both f_zkp_vis (fun f_zkp_vis =>
        bind_both f_g_pow_xi_yi_vis (fun f_g_pow_xi_yi_vis =>
          bind_both f_commit_vis (fun f_commit_vis =>
            bind_both f_zkp_xis (fun f_zkp_xis =>
              bind_both f_g_pow_xis (fun f_g_pow_xis =>
                solve_lift (ret_both ((f_g_pow_xis,f_zkp_xis,f_commit_vis,f_g_pow_xi_yi_vis,f_zkp_vis,f_tally) : (t_OvnContractState))))))))) : both (L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_OvnContractState).
Fail Next Obligation.
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := y) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := y) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_commit_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := y) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xi_yi_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := y) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := y) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_tally' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := y)).
Definition state_OVN : choice_type :=
  t_OvnContractState.
Hint Unfold t_OvnContractState.
Hint Unfold state_OVN.

#[global] Program Instance serializable_state_OVN : Serializable state_OVN :=
  ltac:(serialize_enum).
Solve All Obligations with exact nseq_serializable || exact hacspec_int_serializable.

Equations init_ovn_contract {L1 : {fset Location}} {I1 : Interface} {T : _} `{ t_Sized (T)} `{ t_HasInitContext (T) ('unit)} (ctx : both L1 I1 (T)) : both L1 I1 (t_Result (t_OvnContractState) (t_Reject)) :=
  init_ovn_contract ctx  :=
    Result_Ok (solve_lift (Build_t_OvnContractState (f_g_pow_xis := repeat one (ret_both (20 : uint_size))) (f_zkp_xis := repeat (ret_both (0 : int32)) (ret_both (20 : uint_size))) (f_commit_vis := repeat (ret_both (0 : int32)) (ret_both (20 : uint_size))) (f_g_pow_xi_yi_vis := repeat one (ret_both (20 : uint_size))) (f_zkp_vis := repeat (ret_both (0 : int32)) (ret_both (20 : uint_size))) (f_tally := ret_both (0 : int32)))) : both L1 I1 (t_Result (t_OvnContractState) (t_Reject)).
Fail Next Obligation.

Equations select_private_voting_key {L1 : {fset Location}} {I1 : Interface} (random : both L1 I1 (int32)) : both L1 I1 (int32) :=
  select_private_voting_key random  :=
    solve_lift (random .% q) : both L1 I1 (int32).
Fail Next Obligation.

Equations v_ZKP {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi : both L1 I1 (int32)) (xi : both L2 I2 (int32)) : both (L1 :|: L2) (I1 :|: I2) (int32) :=
  v_ZKP g_pow_xi xi  :=
    solve_lift (ret_both (0 : int32)) : both (L1 :|: L2) (I1 :|: I2) (int32).
Fail Next Obligation.

Definition t_RegisterParam : choice_type :=
  (int32 × int32).
Equations f_rp_i {L : {fset Location}} {I : Interface} (s : both L I (t_RegisterParam)) : both L I (int32) :=
  f_rp_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : int32))) : both L I (int32).
Fail Next Obligation.
Equations f_rp_xi {L : {fset Location}} {I : Interface} (s : both L I (t_RegisterParam)) : both L I (int32) :=
  f_rp_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : int32))) : both L I (int32).
Fail Next Obligation.
Equations Build_t_RegisterParam {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_rp_i : both L0 I0 (int32)} {f_rp_xi : both L1 I1 (int32)} : both (L0:|:L1) (I0:|:I1) (t_RegisterParam) :=
  Build_t_RegisterParam  :=
    bind_both f_rp_xi (fun f_rp_xi =>
      bind_both f_rp_i (fun f_rp_i =>
        solve_lift (ret_both ((f_rp_i,f_rp_xi) : (t_RegisterParam))))) : both (L0:|:L1) (I0:|:I1) (t_RegisterParam).
Fail Next Obligation.
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_i' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := y) (f_rp_xi := f_rp_xi x)).
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_rp_xi' ':=' y ')'" := (Build_t_RegisterParam (f_rp_i := f_rp_i x) (f_rp_xi := y)).

Equations register_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {T : _} `{ t_Sized (A)} `{ t_Sized (T)} `{ t_HasActions (A)} `{ t_HasReceiveContext (T) ('unit)} `{ t_Sized (A)} `{ t_Sized (T)} `{ t_HasActions (A)} `{ t_HasReceiveContext (T) ('unit)} (ctx : both L1 I1 (T)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  register_vote ctx state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.
Instance t_sized_register : t_Sized t_RegisterParam.
Admitted.
Instance t_has_receive_context_register : t_HasReceiveContext t_RegisterParam 'unit .
Admitted.
Equations receive_OVN_register {L1 L2 I1 I2} {A : _} `{ t_Sized (A)}`{ t_HasActions (A)} (ctx : both L1 I1 t_RegisterParam) (st : both L2 I2 (state_OVN)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × state_OVN)) (t_ParseError)) :=
  receive_OVN_register ctx st :=
  register_vote ctx st.

Definition t_CastVoteParam : choice_type :=
  (int32 × int32 × 'bool).
Equations f_cvp_i {L : {fset Location}} {I : Interface} (s : both L I (t_CastVoteParam)) : both L I (int32) :=
  f_cvp_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : int32))) : both L I (int32).
Fail Next Obligation.
Equations f_cvp_xi {L : {fset Location}} {I : Interface} (s : both L I (t_CastVoteParam)) : both L I (int32) :=
  f_cvp_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : int32))) : both L I (int32).
Fail Next Obligation.
Equations f_cvp_vote {L : {fset Location}} {I : Interface} (s : both L I (t_CastVoteParam)) : both L I ('bool) :=
  f_cvp_vote s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : 'bool))) : both L I ('bool).
Fail Next Obligation.
Equations Build_t_CastVoteParam {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {f_cvp_i : both L0 I0 (int32)} {f_cvp_xi : both L1 I1 (int32)} {f_cvp_vote : both L2 I2 ('bool)} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_CastVoteParam) :=
  Build_t_CastVoteParam  :=
    bind_both f_cvp_vote (fun f_cvp_vote =>
      bind_both f_cvp_xi (fun f_cvp_xi =>
        bind_both f_cvp_i (fun f_cvp_i =>
          solve_lift (ret_both ((f_cvp_i,f_cvp_xi,f_cvp_vote) : (t_CastVoteParam)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_CastVoteParam).
Fail Next Obligation.
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_i' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := y) (f_cvp_xi := f_cvp_xi x) (f_cvp_vote := f_cvp_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_xi' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := y) (f_cvp_vote := f_cvp_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_cvp_vote' ':=' y ')'" := (Build_t_CastVoteParam (f_cvp_i := f_cvp_i x) (f_cvp_xi := f_cvp_xi x) (f_cvp_vote := y)).

Equations check_valid {L1 : {fset Location}} {I1 : Interface} (zkp : both L1 I1 (int32)) : both L1 I1 ('bool) :=
  check_valid zkp  :=
    solve_lift (ret_both (true : 'bool)) : both L1 I1 ('bool).
Fail Next Obligation.

Definition prod2_loc : Location :=
  (int32 ; 2%nat).
Definition prod1_loc : Location :=
  (int32 ; 1%nat).
Equations compute_group_element_for_vote {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (i : both L1 I1 (int32)) (xi : both L2 I2 (int32)) (vote : both L3 I3 ('bool)) (xis : both L4 I4 (nseq int32 20)) : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [prod2_loc;prod1_loc;res_loc]) (I1 :|: I2 :|: I3 :|: I4) (int32) :=
  compute_group_element_for_vote i xi vote xis  :=
    (letb prod1 loc(prod1_loc) := one in
    letb prod1 := foldi_both (L := (L1 :|: L2 :|: L3 :|: L4 :|: fset [prod2_loc;prod1_loc;res_loc])) (I := I1 :|: I2 :|: I3 :|: I4) (into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := cast_int (WS2 := U32) (i .- (ret_both (1 : int32)))))) (fun j =>
      ssp (fun prod1 =>
             solve_lift (prod prod1 (xis.a[j])))) prod1 in
    letb prod2 loc(prod2_loc) := one in
    letb prod2 := foldi_both (L := (L1 :|: L2 :|: L3 :|: L4 :|: fset [prod2_loc;prod1_loc;res_loc])) (I := I1 :|: I2 :|: I3 :|: I4) (into_iter (Build_t_Range (f_start := cast_int (WS2 := U32) (i .+ (ret_both (1 : int32)))) (f_end := n))) (fun j =>
      ssp (fun prod2 =>
        solve_lift (prod prod2 (xis.a[j])))) prod2 in
    letb Yi := div prod1 prod2 in
    solve_lift (prod (pow Yi xi) (g_pow (ifb vote
    then ret_both (1 : int32)
                                         else ret_both (0 : int32)))) : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [prod2_loc;prod1_loc;res_loc]) (I1 :|: I2 :|: I3 :|: I4) (int32)).
Fail Next Obligation.

Equations commit_to {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int32)) : both L1 I1 (int32) :=
  commit_to x  :=
    solve_lift (ret_both (0 : int32)) : both L1 I1 (int32).
Fail Next Obligation.

Equations commit_to_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {(* impl *) HasReceiveContext : _} `{ t_Sized (A)} `{ t_Sized ((* impl *) HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} (ctx : both L1 I1 (impl HasReceiveContext)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  commit_to_vote ctx state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.
Instance t_sized_cast_vote_param : t_Sized t_CastVoteParam.
Admitted.
Instance t_has_receive_cast_vote_param : t_HasReceiveContext t_CastVoteParam 'unit .
Admitted.
Definition receive_OVN_commit_to_vote {L1 L2 I1 I2} {A : _} `{ t_Sized (A)}`{ t_HasActions (A)} (ctx : both L1 I1 t_CastVoteParam) (st : both L2 I2 (state_OVN)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × state_OVN)) (t_ParseError)) :=
  commit_to_vote ctx st.

Equations v_ZKP_one_out_of_two {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_vi : both L1 I1 (int32)) (vi : both L2 I2 ('bool)) : both (L1 :|: L2) (I1 :|: I2) (int32) :=
  v_ZKP_one_out_of_two g_pow_vi vi  :=
    solve_lift (ret_both (32 : int32)) : both (L1 :|: L2) (I1 :|: I2) (int32).
Fail Next Obligation.

Equations cast_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {(* impl *) HasReceiveContext : _} `{ t_Sized (A)} `{ t_Sized ((* impl *) HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} (ctx : both L1 I1 (impl HasReceiveContext)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  cast_vote ctx state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.

Definition receive_OVN_cast_vote {L1 L2 I1 I2} {A : _} `{ t_Sized (A)}`{ t_HasActions (A)} (ctx : both L1 I1 t_CastVoteParam) (st : both L2 I2 (state_OVN)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × state_OVN)) (t_ParseError)) :=
  cast_vote ctx st.

Equations check_valid2 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi_yi_vi : both L1 I1 (int32)) (zkp : both L2 I2 (int32)) : both (L1 :|: L2) (I1 :|: I2) ('bool) :=
  check_valid2 g_pow_xi_yi_vi zkp  :=
    solve_lift (ret_both (true : 'bool)) : both (L1 :|: L2) (I1 :|: I2) ('bool).
Fail Next Obligation.

Equations check_commitment {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi_yi_vi : both L1 I1 (int32)) (zkp : both L2 I2 (int32)) : both (L1 :|: L2) (I1 :|: I2) ('bool) :=
  check_commitment g_pow_xi_yi_vi zkp  :=
    solve_lift (ret_both (true : 'bool)) : both (L1 :|: L2) (I1 :|: I2) ('bool).
Fail Next Obligation.

Definition t_TallyParameter : choice_type :=
  'unit.
Equations Build_t_TallyParameter : both (fset []) (fset []) (t_TallyParameter) :=
  Build_t_TallyParameter  :=
    solve_lift (ret_both ((_) : (t_TallyParameter))) : both (fset []) (fset []) (t_TallyParameter).
Fail Next Obligation.

Equations tally_votes {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {(* impl *) HasReceiveContext : _} `{ t_Sized (A)} `{ t_Sized ((* impl *) HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} (_ : both L1 I1 (impl HasReceiveContext)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  tally_votes _ state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.

Instance t_sized_TallyParameter : t_Sized t_TallyParameter.
Admitted.
Instance t_has_receive_context_TallyParameter : t_HasReceiveContext t_TallyParameter 'unit .
Admitted. 
Definition receive_OVN_tally {L1 L2 I1 I2} {A : _} `{ t_Sized (A)}`{ t_HasActions (A)} (ctx : both L1 I1 t_TallyParameter) (st : both L2 I2 (state_OVN)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × state_OVN)) (t_ParseError)) :=
  tally_votes ctx st.

From ConCert.Execution Require Import Blockchain.

Instance BaseTypes : ConCert.Execution.Blockchain.ChainBase :=
  {|
    Address := nat;
    address_eqb := Nat.eqb ;
    address_eqb_spec := Nat.eqb_spec;
    address_is_contract := Nat.even;
  |}.

Instance t_sized_state_OVN : t_Sized state_OVN.
Admitted.

Instance t_HasActions_state_OVN : t_HasActions state_OVN.
Admitted.


Definition init_OVN {L : {fset Location}} {I : Interface} (chain : Chain) (ctx : ContractCallContext) (st : both L I (state_OVN)) : ResultMonad.result (both L I (state_OVN)) (t_ParseError) :=
  ResultMonad.Ok st.
Inductive Msg_OVN: Type :=
| msg_OVN_register : t_RegisterParam -> Msg_OVN
| msg_OVN_commit_to_vote : t_CastVoteParam -> Msg_OVN
| msg_OVN_cast_vote : t_CastVoteParam -> Msg_OVN
| msg_OVN_tally : t_TallyParameter -> Msg_OVN.
Equations receive_OVN {L I} (chain : Chain) (ctx : ContractCallContext) (st : both L I (state_OVN)) (msg : Datatypes.option Msg_OVN) : ResultMonad.result (both L I state_OVN * list ActionBody) t_ParseError :=
  receive_OVN chain ctx st msg :=
  match msg with
  | Some (msg_OVN_register val) =>
      match (is_pure (both_prog (receive_OVN_register (ret_both val) (st)))) with
         | inl x => ResultMonad.Ok (solve_lift ret_both (fst x), [])
         | inr x => ResultMonad.Err x
         end
  | Some (msg_OVN_commit_to_vote val) =>
    match (is_pure (both_prog (receive_OVN_commit_to_vote (ret_both val) (st)))) with
         | inl x => ResultMonad.Ok (solve_lift ret_both (fst x), [])
         | inr x => ResultMonad.Err x
         end
  | Some (msg_OVN_cast_vote val) =>
    match (is_pure (both_prog (receive_OVN_cast_vote (ret_both val) (st)))) with
         | inl x => ResultMonad.Ok (solve_lift ret_both (fst x), [])
         | inr x => ResultMonad.Err x
         end
  | Some (msg_OVN_tally val) =>
    match (is_pure (both_prog (receive_OVN_tally (ret_both val) (st)))) with
         | inl x => ResultMonad.Ok (solve_lift ret_both (fst x), [])
         | inr x => ResultMonad.Err x
         end
  | _ =>
    ResultMonad.Err tt
  end.
Fail Next Obligation.

Inductive temp: Type :=
| temp_OVN : temp.

Instance serializable_both {L I} {A : choice_type} `{Serializable A} : Serializable (both L I A).
Proof.
Admitted.

Instance serializable_Msg_OVN : Serializable Msg_OVN :=
  (@serialize_by_other_option (Datatypes.option t_RegisterParam *
                         Datatypes.option t_CastVoteParam *
                         Datatypes.option t_CastVoteParam *
                         Datatypes.option t_TallyParameter)
                      _
                      (fun m => match m with
                             | @msg_OVN_register v => Some (Some v, None, None, None)
                             | @msg_OVN_commit_to_vote v => Some (None, Some v, None, None)
                             | @msg_OVN_cast_vote v => Some (None, None, Some v, None)
                             | @msg_OVN_tally v => Some (None, None, None, Some v)
                             end
                      )
                      (fun m => match m with
                             | Some (Some v, _, _, _) => Some (msg_OVN_register v)
                             | Some (_, Some v, _, _) => Some (msg_OVN_commit_to_vote v)
                             | Some (_, _, Some v, _) => Some (msg_OVN_cast_vote v)
                             | Some (_, _, _, Some v) => Some (msg_OVN_tally v)
                             | _ => None
                             end)
                      (ltac:(destruct m ; reflexivity)) _).

Definition contract_OVN {L I} : Contract (both L I state_OVN) (Msg_OVN) (both L I state_OVN) (t_ParseError) :=
  build_contract init_OVN receive_OVN.
