(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_lib.
Export Hacspec_lib.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_ovn_Schnorr.
Export Hacspec_ovn_Schnorr.

Notation t_Secret := (t_Q).

Equations sample_uniform : both (fset []) ([interface ]) (t_Q) :=
  sample_uniform  :=
    solve_lift (Build_t_Q (ret_both (1 : int32))) : both (fset []) ([interface ]) (t_Q).
Fail Next Obligation.

Notation t_public := (t_G).

Notation t_public_key := ((t_G × (t_G × t_G × t_Q × t_Q))).

Equations p_i_init {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 ('unit)) : both (L1 :|: fset [commit_loc]) (I1) ((t_G × (t_G × t_G × t_Q × t_Q))) :=
  p_i_init _  :=
    letb x := (sample_uniform) : both _ _ (t_Q) in
    letb y := (Build_t_G (ret_both (1 : int32))) : both _ _ (t_G) in
    letb zkp := (fiat_shamir_run (prod_b (y,x))) : both _ _ ((t_G × t_G × t_Q × t_Q)) in
    solve_lift (prod_b (y,zkp)) : both (L1 :|: fset [commit_loc]) (I1) ((t_G × (t_G × t_G × t_Q × t_Q))).
Fail Next Obligation.

Notation t_N := (nat_mod 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab).
Definition N {L : {fset Location}} {I : Interface} : both L I (t_N) -> both L I (t_N) :=
  id.

Notation t_pid := (t_N).

Require Import HashMap.
Export HashMap.

Notation t_public_keys := (t_HashMap (t_N) ((t_G × (t_G × t_G × t_Q × t_Q))) (t_RandomState)).

Equations p_i_construct {L1 : {fset Location}} {I1 : Interface} (m : both L1 I1 (t_HashMap (t_N) ((t_G × (t_G × t_G × t_Q × t_Q))) (t_RandomState))) : both (L1) (I1) ('unit) :=
  p_i_construct m  :=
    solve_lift (ret_both (tt : 'unit)) : both (L1) (I1) ('unit).
Fail Next Obligation.

Equations p_i_vote {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 ('bool)) : both (L1) (I1) (t_G) :=
  p_i_vote v  :=
    solve_lift (Build_t_G (ret_both (1 : int32))) : both (L1) (I1) (t_G).
Fail Next Obligation.

Equations exec {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 ('bool)) : both (L1 :|: fset [commit_loc]) (I1) (t_G) :=
  exec v  :=
    letb x := (sample_uniform) : both _ _ (t_Q) in
    letb y := (Build_t_G (ret_both (1 : int32))) : both _ _ (t_G) in
    letb zkp := (fiat_shamir_run (prod_b (y,x))) : both _ _ ((t_G × t_G × t_Q × t_Q)) in
    solve_lift (p_i_vote v) : both (L1 :|: fset [commit_loc]) (I1) (t_G).
Fail Next Obligation.
