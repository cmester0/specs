Class t_TryFrom (A : choice_type) := TryFrom : A -> A.
Class t_Into (A : choice_type) := Into : A -> A.
Class t_PartialEq (A : choice_type) := PartialEq : A -> A.
Class t_Copy (A : choice_type) := Copy : A -> A.
Class t_Clone (A : choice_type) := Clone : A -> A.
Class t_Sized (A : choice_type) := Sized : A -> A.
Axiom seq : choice_type -> choice_type.
Axiom int8 : choice_type.
Axiom t_Option : choice_type -> choice_type.
Axiom uint_size : choice_type.
Inductive vec_typ :=
| t_Global.
Axiom t_Vec : choice_type -> vec_typ -> choice_type.
Class t_Default A := { default : A }.


Class t_Hasher `{t_TryFrom} `{t_Into} `{t_PartialEq} `{t_Copy} `{t_Clone} := {
  t_temp_hash : choice_type ;
  t_Hash `{t_TryFrom} `{t_Into} `{t_PartialEq} `{t_Copy} `{t_Clone} : choice_type ;
  hash : seq int8 -> t_temp_hash ;
  concat_and_hash : t_Hash -> t_Option (t_Hash) -> t_Hash ;
  hash_size : uint_size ;
}.

Notation t_PartialTreeLayer := (fun (H : choice_type) => (t_Vec ((uint_size * H)) (t_Global))).

Record t_PartialTree `{T : t_Hasher} : choice_type :={
  f_layers : t_Vec (t_Vec ((uint_size * t_Hash)) (t_Global)) (t_Global);
}.
Definition new `{T : t_Hasher} : t_Vec (t_Vec ((uint_size * t_Hash)) (t_Global)) (t_Global). Admitted.

Require Import Coq.Program.Tactics.
Check Build_t_PartialTree.
Program Definition new_under_impl `{T : t_Hasher} :  (t_PartialTree) :=
  {| f_layers := new |}.
Fail Next Obligation.

#[local] Instance t_PartialTree_t_Default `{T : t_Hasher} : t_Default t_PartialTree := {|
  default := new_under_impl;
|}.
