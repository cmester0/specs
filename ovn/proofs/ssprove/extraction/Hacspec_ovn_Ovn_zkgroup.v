(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Crypt Require Import jasmin_word.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Group.
Export Group.

Require Import Group_Ff.
Export Group_Ff.

Require Import Field.
Export Field.

Require Import PrimeField.
Export PrimeField.

Require Import Group.
Export Group.

Class t_MGroup (Self : choice_type) := {
  f_hash_loc : {fset Location} ;
  f_hash : (forall {L1 I1}, both L1 I1 (t_Vec v_Self t_Global) -> both (L1 :|: f_hash_loc) I1 f_Scalar) ;
}.
Hint Unfold f_hash_loc : hacspec_hints.

Definition t_SchnorrZKPCommit {v_G : _} `{ t_Sized v_G} `{ t_MGroup v_G} : choice_type :=
  (v_G × f_Scalar × f_Scalar).
Equations f_schnorr_zkp_u {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_MGroup v_G} (s : both L I t_SchnorrZKPCommit) : both L I v_G :=
  f_schnorr_zkp_u s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : v_G))) : both L I v_G.
Fail Next Obligation.
Equations f_schnorr_zkp_c {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_MGroup v_G} (s : both L I t_SchnorrZKPCommit) : both L I f_Scalar :=
  f_schnorr_zkp_c s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations f_schnorr_zkp_z {L : {fset Location}} {I : Interface} {v_G : _} `{ t_Sized v_G} `{ t_MGroup v_G} (s : both L I t_SchnorrZKPCommit) : both L I f_Scalar :=
  f_schnorr_zkp_z s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : f_Scalar))) : both L I f_Scalar.
Fail Next Obligation.
Equations Build_t_SchnorrZKPCommit {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {v_G : _} `{ t_Sized v_G} `{ t_MGroup v_G} {f_schnorr_zkp_u : both L0 I0 v_G} {f_schnorr_zkp_c : both L1 I1 f_Scalar} {f_schnorr_zkp_z : both L2 I2 f_Scalar} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_SchnorrZKPCommit) :=
  Build_t_SchnorrZKPCommit  :=
    bind_both f_schnorr_zkp_z (fun f_schnorr_zkp_z =>
      bind_both f_schnorr_zkp_c (fun f_schnorr_zkp_c =>
        bind_both f_schnorr_zkp_u (fun f_schnorr_zkp_u =>
          solve_lift (ret_both ((f_schnorr_zkp_u,f_schnorr_zkp_c,f_schnorr_zkp_z) : (t_SchnorrZKPCommit)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_SchnorrZKPCommit).
Fail Next Obligation.
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_u' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := y) (f_schnorr_zkp_c := f_schnorr_zkp_c x) (f_schnorr_zkp_z := f_schnorr_zkp_z x)).
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_c' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_schnorr_zkp_u x) (f_schnorr_zkp_c := y) (f_schnorr_zkp_z := f_schnorr_zkp_z x)).
Notation "'Build_t_SchnorrZKPCommit' '[' x ']' '(' 'f_schnorr_zkp_z' ':=' y ')'" := (Build_t_SchnorrZKPCommit (f_schnorr_zkp_u := f_schnorr_zkp_u x) (f_schnorr_zkp_c := f_schnorr_zkp_c x) (f_schnorr_zkp_z := y)).
