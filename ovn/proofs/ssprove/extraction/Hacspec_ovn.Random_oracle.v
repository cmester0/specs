(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_lib.

Program Definition random_oracle_init {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 (unit)) : both (L1) (I1) (unit) :=
  tt.
Fail Next Obligation.

Definition t_QueryCanvas : choice_type :=
  (nseq int8 TODO: Int.to_string length × t_Sign × 'bool).
Equations Build_t_QueryCanvas {L : {fset Location}} {I : Interface} (f_b : both L I (nseq int8 TODO: Int.to_string length)) (f_sign : both L I (t_Sign)) (f_signed : both L I ('bool)) : both L I (t_QueryCanvas) :=
  Build_t_QueryCanvas f_b f_sign f_signed  :=
    bind_both f_signed (fun f_signed =>
      bind_both f_sign (fun f_sign =>
        bind_both f_b (fun f_b =>
          ret_both f_b f_sign f_signed))) : both L I (t_QueryCanvas).
Fail Next Obligation.

Program Definition max_under_impl_16 : both (fset []) ([interface ]) (t_Output) :=
  ((from i32(1)) shift_left i32(384)) .- one.
Fail Next Obligation.

Program Definition max_value_under_impl_16 : both (fset []) ([interface ]) (t_QueryCanvas) :=
  from max_under_impl_16.
Fail Next Obligation.

(*item error backend*)

Program Definition from_literal_under_impl_16 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_QueryCanvas) :=
  letb big_x := (from x) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_16)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type QueryCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_16 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_QueryCanvas) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_16)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type QueryCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition pow2_under_impl_16 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_QueryCanvas) :=
  into ((from i32(1)) shift_left x).
Fail Next Obligation.

(*item error backend*)

#[global] Instance t_QueryCanvas_t_From : t_From t_QueryCanvas t_BigUint := {
  from (x : t_BigUint) := from (from x);
}.

#[global] Instance t_QueryCanvas_t_From : t_From t_QueryCanvas t_BigInt := {
  from (x : t_BigInt) := letb max_value := (max_under_impl_16) : both _ _ (t_BigInt) in
  letb _ := (ifb not (x <=.? max_value)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type QueryCanvas!])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb '(sign,repr) := (to_bytes_be_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letb _ := (ifb andb (sign =.? Sign_Minus) (not false)
    then letb 'tt := (never_to_any (begin_panic Trying to convert a negative number into an unsigned integer!)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb _ := (ifb (len_under_impl_1 repr) >.? ((i32(384) .+ i32(7)) ./ i32(8))
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type QueryCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm out loc(out_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize out)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl_1 repr)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (out),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(repr)))))),
    )) : both _ _ (unit) in
  Build_t_QueryCanvas outsignfalse;
}.

#[global] Instance t_QueryCanvas_t_Default : t_Default t_QueryCanvas := {
  default := Build_t_QueryCanvas (repeat i8(0) i32(48))Sign_Plusfalse;
}.

#[global] Instance t_QueryCanvas_t_Into : t_Into t_QueryCanvas t_BigInt := {
  into (self : t_QueryCanvas) := from_bytes_be_under_impl_24 (f_sign self) (unsize (f_b self));
}.

#[global] Instance t_QueryCanvas_t_Into : t_Into t_QueryCanvas t_BigUint := {
  into (self : t_QueryCanvas) := from_bytes_be_under_impl_18 (unsize (f_b self));
}.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*item error backend*)

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 9%nat).
Program Definition from_be_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_QueryCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  Build_t_QueryCanvas reprSign_Plusfalse.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 10%nat).
Program Definition from_le_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_QueryCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  into (from_bytes_le_under_impl_24 Sign_Plus (unsize repr)).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_QueryCanvas)) : both (L1) (I1) (nseq int8 TODO: Int.to_string length) :=
  f_b self.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 11%nat).
Program Definition to_le_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_QueryCanvas)) : both (L1 :|: fset [repr_loc]) (I1) (nseq int8 TODO: Int.to_string length) :=
  letb x := (from_bytes_be_under_impl_24 Sign_Plus (unsize (f_b self))) : both _ _ (t_BigInt) in
  letb '(_,x_s) := (to_bytes_le_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: 0,
                f_end: alloc::vec::len_under_impl_1(&(x_s)),
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(x_s)))))),
    )) : both _ _ (unit) in
  repr.
Fail Next Obligation.

Program Definition comp_eq_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (rhs : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a =.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_QueryCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_ne_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (rhs : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <> b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_QueryCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gte_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (rhs : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >=.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_QueryCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gt_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (rhs : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_QueryCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lte_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (rhs : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <=.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_QueryCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lt_under_impl_15 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (rhs : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <.? b
  then letb one := (from_literal_under_impl_16 i128(1)) : both _ _ (t_QueryCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition inv_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (modval : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_QueryCanvas) :=
  letb biguintmodval := (into modval) : both _ _ (t_BigInt) in
  letb m := (biguintmodval .- (from i32(2))) : both _ _ (t_Output) in
  letb s := (into self) : both _ _ (t_BigInt) in
  into (modpow_under_impl_24 s m biguintmodval).
Fail Next Obligation.

Program Definition pow_felem_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_QueryCanvas)) (exp : both L2 I2 (t_QueryCanvas)) (modval : both L3 I3 (t_QueryCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_QueryCanvas) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into exp) : both _ _ (t_BigInt) in
  letb m := (into modval) : both _ _ (t_BigInt) in
  letb c := (modpow_under_impl_24 a b m) : both _ _ (t_BigInt) in
  into c.
Fail Next Obligation.

Program Definition pow_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_QueryCanvas)) (exp : both L2 I2 (int128)) (modval : both L3 I3 (t_QueryCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_QueryCanvas) :=
  pow_felem_under_impl_27 self (into (from exp)) modval.
Fail Next Obligation.

Program Definition rem_under_impl_27 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_QueryCanvas)) (n : both L2 I2 (t_QueryCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  self .% n.
Fail Next Obligation.

#[global] Instance t_QueryCanvas_t_Add : t_Add t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  add (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_16
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded addition overflow for type QueryCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_QueryCanvas_t_Sub : t_Sub t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  sub (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (ifb f_signed self
    then a .- b
    else unwrap_or_else_under_impl (checked_sub_under_impl_24 a b) (
        never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded substraction underflow for type QueryCanvas])) (unsize none_under_impl_1))))) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_QueryCanvas_t_Mul : t_Mul t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  mul (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_16
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded multiplication overflow for type QueryCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_QueryCanvas_t_Div : t_Div t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  div (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type QueryCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a ./ b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_QueryCanvas_t_Rem : t_Rem t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  rem (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type QueryCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a .% b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_QueryCanvas_t_Not : t_Not t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  not (self : t_QueryCanvas) := never_to_any (panic not implemented);
}.

#[global] Instance t_QueryCanvas_t_BitOr : t_BitOr t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  bitor (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .| b);
}.

#[global] Instance t_QueryCanvas_t_BitXor : t_BitXor t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  bitxor (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .^ b);
}.

#[global] Instance t_QueryCanvas_t_BitAnd : t_BitAnd t_QueryCanvas t_QueryCanvas := {
  t_Output := t_QueryCanvas;
  bitand (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .& b);
}.

#[global] Instance t_QueryCanvas_t_Shr : t_Shr t_QueryCanvas uint_size := {
  t_Output := t_QueryCanvas;
  shr (self : t_QueryCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_right b);
}.

#[global] Instance t_QueryCanvas_t_Shl : t_Shl t_QueryCanvas uint_size := {
  t_Output := t_QueryCanvas;
  shl (self : t_QueryCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_left b);
}.

#[global] Instance t_QueryCanvas_t_PartialEq : t_PartialEq t_QueryCanvas t_QueryCanvas := {
  eq (self : t_QueryCanvas) (rhs : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  a =.? b;
}.

#[global] Instance t_QueryCanvas_t_Eq : t_Eq t_QueryCanvas := {
}.

#[global] Instance t_QueryCanvas_t_PartialOrd : t_PartialOrd t_QueryCanvas t_QueryCanvas := {
  partial_cmp (self : t_QueryCanvas) (other : t_QueryCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into other) : both _ _ (t_BigInt) in
  partial_cmp a b;
}.

#[global] Instance t_QueryCanvas_t_Ord : t_Ord t_QueryCanvas := {
  cmp (self : t_QueryCanvas) (other : t_QueryCanvas) := unwrap_under_impl (partial_cmp self other);
}.

Program Definition from_byte_seq_be_under_impl_8 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_QueryCanvas) :=
  from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x)))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_8 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_QueryCanvas) :=
  from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x)))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_8 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_QueryCanvas)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (unsize (to_be_bytes_under_impl_15 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

#[global] Instance t_QueryCanvas_t_NumericCopy : t_NumericCopy t_QueryCanvas := {
}.

#[global] Instance t_QueryCanvas_t_UnsignedInteger : t_UnsignedInteger t_QueryCanvas := {
}.

#[global] Instance t_QueryCanvas_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_QueryCanvas := {
}.

#[global] Instance t_QueryCanvas_t_Integer : t_Integer t_QueryCanvas := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_16 i128(0);
  ONE := from_literal_under_impl_16 i128(1);
  TWO := from_literal_under_impl_16 i128(2);
  from_literal (val : int128) := from_literal_under_impl_16 val;
  from_hex_string (s : t_String) := from_hex_under_impl_15 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_QueryCanvas) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_QueryCanvas) (b : t_QueryCanvas) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_16 (not (i128(1) shift_left i))) : both _ _ (t_QueryCanvas) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_QueryCanvas) (pos : uint_size) (y : t_QueryCanvas) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_QueryCanvas) in
  set_bit self b pos;
  rotate_left (self : t_QueryCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_QueryCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_QueryCanvas_t_ModNumeric : t_ModNumeric t_QueryCanvas := {
  sub_mod (self : t_QueryCanvas) (rhs : t_QueryCanvas) (n : t_QueryCanvas) := (self .- rhs) .% n;
  add_mod (self : t_QueryCanvas) (rhs : t_QueryCanvas) (n : t_QueryCanvas) := (self .+ rhs) .% n;
  mul_mod (self : t_QueryCanvas) (rhs : t_QueryCanvas) (n : t_QueryCanvas) := (self .* rhs) .% n;
  pow_mod (self : t_QueryCanvas) (exp : t_QueryCanvas) (n : t_QueryCanvas) := pow_felem_under_impl_27 self exp n;
  modulo (self : t_QueryCanvas) (n : t_QueryCanvas) := self .% n;
  signed_modulo (self : t_QueryCanvas) (n : t_QueryCanvas) := modulo self n;
  absolute (self : t_QueryCanvas) := self;
}.

#[global] Instance t_QueryCanvas_t_Numeric : t_Numeric t_QueryCanvas := {
  max_val := max_value_under_impl_16;
  wrap_add (self : t_QueryCanvas) (rhs : t_QueryCanvas) := self .+ rhs;
  wrap_sub (self : t_QueryCanvas) (rhs : t_QueryCanvas) := self .- rhs;
  wrap_mul (self : t_QueryCanvas) (rhs : t_QueryCanvas) := self .* rhs;
  wrap_div (self : t_QueryCanvas) (rhs : t_QueryCanvas) := self ./ rhs;
  exp (self : t_QueryCanvas) (exp : int32) := pow_under_impl_27 self (into exp) max_val;
  pow_self (self : t_QueryCanvas) (exp : t_QueryCanvas) := pow_felem_under_impl_27 self (into exp) max_val;
  divide (self : t_QueryCanvas) (rhs : t_QueryCanvas) := self ./ rhs;
  inv (self : t_QueryCanvas) (n : t_QueryCanvas) := inv_under_impl_27 self n;
  equal (self : t_QueryCanvas) (other : t_QueryCanvas) := self =.? other;
  greater_than (self : t_QueryCanvas) (other : t_QueryCanvas) := self >.? other;
  greater_than_or_equal (self : t_QueryCanvas) (other : t_QueryCanvas) := self >=.? other;
  less_than (self : t_QueryCanvas) (other : t_QueryCanvas) := self <.? other;
  less_than_or_equal (self : t_QueryCanvas) (other : t_QueryCanvas) := self >=.? other;
  not_equal_bm (self : t_QueryCanvas) (other : t_QueryCanvas) := ifb not (equal self other)
  then max_val
  else from_literal_under_impl_16 i128(0);
  equal_bm (self : t_QueryCanvas) (other : t_QueryCanvas) := ifb equal self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  greater_than_bm (self : t_QueryCanvas) (other : t_QueryCanvas) := ifb greater_than self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  greater_than_or_equal_bm (self : t_QueryCanvas) (other : t_QueryCanvas) := ifb greater_than_or_equal self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  less_than_bm (self : t_QueryCanvas) (other : t_QueryCanvas) := ifb less_than self other
  then max_val
  else from_literal_under_impl_16 i128(0);
  less_than_or_equal_bm (self : t_QueryCanvas) (other : t_QueryCanvas) := ifb less_than_or_equal self other
  then max_val
  else from_literal_under_impl_16 i128(0);
}.

Definition t_Query : choice_type :=
  (t_QueryCanvas).
Equations Build_t_Query {L : {fset Location}} {I : Interface} (0 : both L I (t_QueryCanvas)) : both L I (t_Query) :=
  Build_t_Query 0  :=
    bind_both 0 (fun 0 =>
      ret_both 0) : both L I (t_Query).
Fail Next Obligation.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

#[global] Instance t_Query_t_From : t_From t_Query t_QueryCanvas := {
  from (x : t_QueryCanvas) := Query (rem_under_impl_27 x (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab));
}.

#[global] Instance t_Query_t_Into : t_Into t_Query t_QueryCanvas := {
  into (self : t_Query) := 0 self;
}.

Program Definition from_canvas_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_QueryCanvas)) : both (L1 :|: fset [x_loc]) (I1) (t_Query) :=
  Query (rem_under_impl_27 x (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)).
Fail Next Obligation.

Program Definition into_canvas_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1) (I1) (t_QueryCanvas) :=
  0 self.
Fail Next Obligation.

Program Definition max_under_impl_64 : both (fset [x_loc]) ([interface ]) (t_QueryCanvas) :=
  from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab.
Fail Next Obligation.

Program Definition declassify_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1) (I1) (t_BigInt) :=
  letb a := (into self) : both _ _ (t_QueryCanvas) in
  into a.
Fail Next Obligation.

(*item error backend*)

Program Definition from_be_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_Query) :=
  into (from_be_bytes_under_impl_15 v).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_be_bytes_under_impl_15 (into self))).
Fail Next Obligation.

Program Definition from_le_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_Query) :=
  into (from_le_bytes_under_impl_15 v).
Fail Next Obligation.

Program Definition to_le_bytes_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1 :|: fset [repr_loc]) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_le_bytes_under_impl_15 (into self))).
Fail Next Obligation.

Program Definition bit_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (i : both L2 I2 (uint_size)) : both (L1:|:L2) (I1:|:I2) ('bool) :=
  bit_under_impl_16 (into self) i.
Fail Next Obligation.

Program Definition from_literal_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_Query) :=
  letb big_x := (from x) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_64)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type Query])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  Query (into big_x).
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_Query) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_64)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type Query])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  Query (into big_x).
Fail Next Obligation.

Program Definition comp_eq_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (rhs : both L2 I2 (t_Query)) : both (L1:|:L2) (I1:|:I2) (t_Query) :=
  letb x := (into self) : both _ _ (t_QueryCanvas) in
  into (comp_eq_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_ne_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (rhs : both L2 I2 (t_Query)) : both (L1:|:L2) (I1:|:I2) (t_Query) :=
  letb x := (into self) : both _ _ (t_QueryCanvas) in
  into (comp_ne_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gte_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (rhs : both L2 I2 (t_Query)) : both (L1:|:L2) (I1:|:I2) (t_Query) :=
  letb x := (into self) : both _ _ (t_QueryCanvas) in
  into (comp_gte_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gt_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (rhs : both L2 I2 (t_Query)) : both (L1:|:L2) (I1:|:I2) (t_Query) :=
  letb x := (into self) : both _ _ (t_QueryCanvas) in
  into (comp_gt_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lte_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (rhs : both L2 I2 (t_Query)) : both (L1:|:L2) (I1:|:I2) (t_Query) :=
  letb x := (into self) : both _ _ (t_QueryCanvas) in
  into (comp_lte_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lt_under_impl_64 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (rhs : both L2 I2 (t_Query)) : both (L1:|:L2) (I1:|:I2) (t_Query) :=
  letb x := (into self) : both _ _ (t_QueryCanvas) in
  into (comp_lt_under_impl_15 x (into rhs)).
Fail Next Obligation.

Program Definition neg_under_impl_64 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1 :|: fset [x_loc]) (I1) (t_Query) :=
  letb mod_val := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigInt) in
  letb s := (into self) : both _ _ (t_QueryCanvas) in
  letb s := (into s) : both _ _ (t_BigInt) in
  letb result := (into (mod_val .- s)) : both _ _ (t_QueryCanvas) in
  into result.
Fail Next Obligation.

#[global] Instance t_Query_t_PartialOrd : t_PartialOrd t_Query t_Query := {
  partial_cmp (self : t_Query) (other : t_Query) := Option_Some (cmp self other);
}.

#[global] Instance t_Query_t_Ord : t_Ord t_Query := {
  cmp (self : t_Query) (other : t_Query) := cmp (0 self) (0 other);
}.

#[global] Instance t_Query_t_PartialEq : t_PartialEq t_Query t_Query := {
  eq (self : t_Query) (other : t_Query) := (0 self) =.? (0 other);
}.

#[global] Instance t_Query_t_Eq : t_Eq t_Query := {
}.

#[global] Instance t_Query_t_Add : t_Add t_Query t_Query := {
  t_Output := t_Query;
  add (self : t_Query) (rhs : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  letb b := (into rhs) : both _ _ (t_QueryCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QueryCanvas) in
  into d;
}.

#[global] Instance t_Query_t_Sub : t_Sub t_Query t_Query := {
  t_Output := t_Query;
  sub (self : t_Query) (rhs : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  letb b := (into rhs) : both _ _ (t_QueryCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb c := (ifb b >.? a
    then ((clone max) .- b) .+ a
    else a .- b) : both _ _ (t_Output) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QueryCanvas) in
  into d;
}.

#[global] Instance t_Query_t_Mul : t_Mul t_Query t_Query := {
  t_Output := t_Query;
  mul (self : t_Query) (rhs : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  letb b := (into rhs) : both _ _ (t_QueryCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QueryCanvas) in
  into d;
}.

#[global] Instance t_Query_t_Div : t_Div t_Query t_Query := {
  t_Output := t_Query;
  div (self : t_Query) (rhs : t_Query) := self .* (inv_under_impl_58 rhs);
}.

#[global] Instance t_Query_t_Rem : t_Rem t_Query t_Query := {
  t_Output := t_Query;
  rem (self : t_Query) (rhs : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  letb b := (into rhs) : both _ _ (t_QueryCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .% b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_15 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_QueryCanvas) in
  into d;
}.

#[global] Instance t_Query_t_Not : t_Not t_Query := {
  t_Output := t_Query;
  not (self : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  into (not a);
}.

#[global] Instance t_Query_t_BitOr : t_BitOr t_Query t_Query := {
  t_Output := t_Query;
  bitor (self : t_Query) (rhs : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  letb b := (into rhs) : both _ _ (t_QueryCanvas) in
  into (a .| b);
}.

#[global] Instance t_Query_t_BitXor : t_BitXor t_Query t_Query := {
  t_Output := t_Query;
  bitxor (self : t_Query) (rhs : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  letb b := (into rhs) : both _ _ (t_QueryCanvas) in
  into (a .^ b);
}.

#[global] Instance t_Query_t_BitAnd : t_BitAnd t_Query t_Query := {
  t_Output := t_Query;
  bitand (self : t_Query) (rhs : t_Query) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  letb b := (into rhs) : both _ _ (t_QueryCanvas) in
  into (a .& b);
}.

#[global] Instance t_Query_t_Shr : t_Shr t_Query uint_size := {
  t_Output := t_Query;
  shr (self : t_Query) (rhs : uint_size) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  into (a shift_right rhs);
}.

#[global] Instance t_Query_t_Shl : t_Shl t_Query uint_size := {
  t_Output := t_Query;
  shl (self : t_Query) (rhs : uint_size) := letb a := (into self) : both _ _ (t_QueryCanvas) in
  into (a shift_left rhs);
}.

Program Definition inv_under_impl_58 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1 :|: fset [x_loc]) (I1) (t_Query) :=
  letb base := (into self) : both _ _ (t_QueryCanvas) in
  into (inv_under_impl_27 base max_under_impl_64).
Fail Next Obligation.

Program Definition pow_felem_under_impl_58 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (exp : both L2 I2 (t_Query)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_Query) :=
  letb base := (into self) : both _ _ (t_QueryCanvas) in
  into (pow_felem_under_impl_27 base (into exp) max_under_impl_64).
Fail Next Obligation.

Program Definition pow_under_impl_58 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Query)) (exp : both L2 I2 (int128)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_Query) :=
  letb base := (into self) : both _ _ (t_QueryCanvas) in
  into (pow_under_impl_27 base exp max_under_impl_64).
Fail Next Obligation.

Program Definition pow2_under_impl_58 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_Query) :=
  into (pow2_under_impl_16 x).
Fail Next Obligation.

Program Definition from_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Query) :=
  into (from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Query) :=
  into (from_be_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_be_bytes_under_impl_64 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_be_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_be_bytes_under_impl_64 self).
Fail Next Obligation.

Program Definition from_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Query) :=
  into (from_le_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Query) :=
  into (from_le_bytes_under_impl_15 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_le_bytes_under_impl_64 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_le_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Query)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_le_bytes_under_impl_64 self).
Fail Next Obligation.

Program Definition from_secret_literal_under_impl_1 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_U128)) : both (L1) (I1) (t_Query) :=
  into (from_literal_under_impl_16 (declassify_under_impl_126 x)).
Fail Next Obligation.

#[global] Instance t_Query_t_NumericCopy : t_NumericCopy t_Query := {
}.

#[global] Instance t_Query_t_UnsignedInteger : t_UnsignedInteger t_Query := {
}.

#[global] Instance t_Query_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_Query := {
}.

#[global] Instance t_Query_t_Integer : t_Integer t_Query := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_64 i128(0);
  ONE := from_literal_under_impl_64 i128(1);
  TWO := from_literal_under_impl_64 i128(2);
  from_literal (val : int128) := from_literal_under_impl_64 val;
  from_hex_string (s : t_String) := from_hex_under_impl_64 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_Query) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_Query) (b : t_Query) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_64 (not (i128(1) shift_left i))) : both _ _ (t_Query) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_Query) (pos : uint_size) (y : t_Query) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_Query) in
  set_bit self b pos;
  rotate_left (self : t_Query) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_Query) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_Query_t_ModNumeric : t_ModNumeric t_Query := {
  sub_mod (self : t_Query) (rhs : t_Query) (n : t_Query) := self .- rhs;
  add_mod (self : t_Query) (rhs : t_Query) (n : t_Query) := self .+ rhs;
  mul_mod (self : t_Query) (rhs : t_Query) (n : t_Query) := self .* rhs;
  pow_mod (self : t_Query) (exp : t_Query) (n : t_Query) := pow_felem_under_impl_58 self exp;
  modulo (self : t_Query) (n : t_Query) := self .% n;
  signed_modulo (self : t_Query) (n : t_Query) := modulo self n;
  absolute (self : t_Query) := self;
}.

#[global] Instance t_Query_t_Numeric : t_Numeric t_Query := {
  max_val := into (max_under_impl_64 .- (from_literal_under_impl_16 i128(1)));
  wrap_add (self : t_Query) (rhs : t_Query) := self .+ rhs;
  wrap_sub (self : t_Query) (rhs : t_Query) := self .- rhs;
  wrap_mul (self : t_Query) (rhs : t_Query) := self .* rhs;
  wrap_div (self : t_Query) (rhs : t_Query) := self ./ rhs;
  exp (self : t_Query) (exp : int32) := pow_under_impl_58 self (into exp);
  pow_self (self : t_Query) (exp : t_Query) := pow_felem_under_impl_58 self exp;
  divide (self : t_Query) (rhs : t_Query) := self ./ rhs;
  inv (self : t_Query) (n : t_Query) := inv_under_impl_58 self;
  equal (self : t_Query) (other : t_Query) := self =.? other;
  greater_than (self : t_Query) (other : t_Query) := self >.? other;
  greater_than_or_equal (self : t_Query) (other : t_Query) := self >=.? other;
  less_than (self : t_Query) (other : t_Query) := self <.? other;
  less_than_or_equal (self : t_Query) (other : t_Query) := self <=.? other;
  not_equal_bm (self : t_Query) (other : t_Query) := ifb self <> other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  equal_bm (self : t_Query) (other : t_Query) := ifb self =.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_bm (self : t_Query) (other : t_Query) := ifb self >.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_or_equal_bm (self : t_Query) (other : t_Query) := ifb self >=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_bm (self : t_Query) (other : t_Query) := ifb self <.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_or_equal_bm (self : t_Query) (other : t_Query) := ifb self <=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
}.

Definition t_RandomCanvas : choice_type :=
  (nseq int8 TODO: Int.to_string length × t_Sign × 'bool).
Equations Build_t_RandomCanvas {L : {fset Location}} {I : Interface} (f_b : both L I (nseq int8 TODO: Int.to_string length)) (f_sign : both L I (t_Sign)) (f_signed : both L I ('bool)) : both L I (t_RandomCanvas) :=
  Build_t_RandomCanvas f_b f_sign f_signed  :=
    bind_both f_signed (fun f_signed =>
      bind_both f_sign (fun f_sign =>
        bind_both f_b (fun f_b =>
          ret_both f_b f_sign f_signed))) : both L I (t_RandomCanvas).
Fail Next Obligation.

Program Definition max_under_impl_83 : both (fset []) ([interface ]) (t_Output) :=
  ((from i32(1)) shift_left i32(384)) .- one.
Fail Next Obligation.

Program Definition max_value_under_impl_83 : both (fset []) ([interface ]) (t_RandomCanvas) :=
  from max_under_impl_83.
Fail Next Obligation.

(*item error backend*)

Program Definition from_literal_under_impl_83 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_RandomCanvas) :=
  letb big_x := (from x) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_83)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type RandomCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_83 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_RandomCanvas) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigInt) in
  letb _ := (ifb big_x >.? (into max_under_impl_83)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type RandomCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into big_x.
Fail Next Obligation.

Program Definition pow2_under_impl_83 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_RandomCanvas) :=
  into ((from i32(1)) shift_left x).
Fail Next Obligation.

(*item error backend*)

#[global] Instance t_RandomCanvas_t_From : t_From t_RandomCanvas t_BigUint := {
  from (x : t_BigUint) := from (from x);
}.

#[global] Instance t_RandomCanvas_t_From : t_From t_RandomCanvas t_BigInt := {
  from (x : t_BigInt) := letb max_value := (max_under_impl_83) : both _ _ (t_BigInt) in
  letb _ := (ifb not (x <=.? max_value)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type RandomCanvas!])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb '(sign,repr) := (to_bytes_be_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letb _ := (ifb andb (sign =.? Sign_Minus) (not false)
    then letb 'tt := (never_to_any (begin_panic Trying to convert a negative number into an unsigned integer!)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb _ := (ifb (len_under_impl_1 repr) >.? ((i32(384) .+ i32(7)) ./ i32(8))
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [;
           is too large for type RandomCanvas])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm out loc(out_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize out)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl_1 repr)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (out),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(repr)))))),
    )) : both _ _ (unit) in
  Build_t_RandomCanvas outsignfalse;
}.

#[global] Instance t_RandomCanvas_t_Default : t_Default t_RandomCanvas := {
  default := Build_t_RandomCanvas (repeat i8(0) i32(48))Sign_Plusfalse;
}.

#[global] Instance t_RandomCanvas_t_Into : t_Into t_RandomCanvas t_BigInt := {
  into (self : t_RandomCanvas) := from_bytes_be_under_impl_24 (f_sign self) (unsize (f_b self));
}.

#[global] Instance t_RandomCanvas_t_Into : t_Into t_RandomCanvas t_BigUint := {
  into (self : t_RandomCanvas) := from_bytes_be_under_impl_18 (unsize (f_b self));
}.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*item error backend*)

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 13%nat).
Program Definition from_be_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_RandomCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  Build_t_RandomCanvas reprSign_Plusfalse.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 14%nat).
Program Definition from_le_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_RandomCanvas) :=
  letb _ := (ifb true
    then letb _ := (ifb not ((len_under_impl v) <=.? ((i32(384) .+ i32(7)) ./ i32(8)))
        then letb 'tt := (never_to_any (begin_panic from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas)) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    )) : both _ _ (unit) in
  into (from_bytes_le_under_impl_24 Sign_Plus (unsize repr)).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_RandomCanvas)) : both (L1) (I1) (nseq int8 TODO: Int.to_string length) :=
  f_b self.
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 TODO: Int.to_string length ; 15%nat).
Program Definition to_le_bytes_under_impl_82 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_RandomCanvas)) : both (L1 :|: fset [repr_loc]) (I1) (nseq int8 TODO: Int.to_string length) :=
  letb x := (from_bytes_be_under_impl_24 Sign_Plus (unsize (f_b self))) : both _ _ (t_BigInt) in
  letb '(_,x_s) := (to_bytes_le_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letbm repr loc(repr_loc) := (repeat i8(0) i32(48)) : both _ _ (nseq int8 TODO: Int.to_string length) in
  letb _ := (failure RefMut:The mutation of this &mut is not allowed here.
 core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: 0,
                f_end: alloc::vec::len_under_impl_1(&(x_s)),
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(x_s)))))),
    )) : both _ _ (unit) in
  repr.
Fail Next Obligation.

Program Definition comp_eq_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (rhs : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a =.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_RandomCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_ne_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (rhs : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <> b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_RandomCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gte_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (rhs : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >=.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_RandomCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_gt_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (rhs : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a >.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_RandomCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lte_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (rhs : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <=.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_RandomCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition comp_lt_under_impl_82 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (rhs : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  ifb a <.? b
  then letb one := (from_literal_under_impl_83 i128(1)) : both _ _ (t_RandomCanvas) in
    (one shift_left (i32(384) .- i32(1))) .- one
  else default.
Fail Next Obligation.

Program Definition inv_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (modval : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_RandomCanvas) :=
  letb biguintmodval := (into modval) : both _ _ (t_BigInt) in
  letb m := (biguintmodval .- (from i32(2))) : both _ _ (t_Output) in
  letb s := (into self) : both _ _ (t_BigInt) in
  into (modpow_under_impl_24 s m biguintmodval).
Fail Next Obligation.

Program Definition pow_felem_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_RandomCanvas)) (exp : both L2 I2 (t_RandomCanvas)) (modval : both L3 I3 (t_RandomCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_RandomCanvas) :=
  letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into exp) : both _ _ (t_BigInt) in
  letb m := (into modval) : both _ _ (t_BigInt) in
  letb c := (modpow_under_impl_24 a b m) : both _ _ (t_BigInt) in
  into c.
Fail Next Obligation.

Program Definition pow_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_RandomCanvas)) (exp : both L2 I2 (int128)) (modval : both L3 I3 (t_RandomCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_RandomCanvas) :=
  pow_felem_under_impl_94 self (into (from exp)) modval.
Fail Next Obligation.

Program Definition rem_under_impl_94 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_RandomCanvas)) (n : both L2 I2 (t_RandomCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  self .% n.
Fail Next Obligation.

#[global] Instance t_RandomCanvas_t_Add : t_Add t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  add (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_83
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded addition overflow for type RandomCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_RandomCanvas_t_Sub : t_Sub t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  sub (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (ifb f_signed self
    then a .- b
    else unwrap_or_else_under_impl (checked_sub_under_impl_24 a b) (
        never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded substraction underflow for type RandomCanvas])) (unsize none_under_impl_1))))) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_RandomCanvas_t_Mul : t_Mul t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  mul (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_83
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [bounded multiplication overflow for type RandomCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  into c;
}.

#[global] Instance t_RandomCanvas_t_Div : t_Div t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  div (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type RandomCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a ./ b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_RandomCanvas_t_Rem : t_Rem t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  rem (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [dividing by zero in type RandomCanvas])) (unsize none_under_impl_1)))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb c := (a .% b) : both _ _ (t_Output) in
  into c;
}.

#[global] Instance t_RandomCanvas_t_Not : t_Not t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  not (self : t_RandomCanvas) := never_to_any (panic not implemented);
}.

#[global] Instance t_RandomCanvas_t_BitOr : t_BitOr t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  bitor (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .| b);
}.

#[global] Instance t_RandomCanvas_t_BitXor : t_BitXor t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  bitxor (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .^ b);
}.

#[global] Instance t_RandomCanvas_t_BitAnd : t_BitAnd t_RandomCanvas t_RandomCanvas := {
  t_Output := t_RandomCanvas;
  bitand (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  into (a .& b);
}.

#[global] Instance t_RandomCanvas_t_Shr : t_Shr t_RandomCanvas uint_size := {
  t_Output := t_RandomCanvas;
  shr (self : t_RandomCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_right b);
}.

#[global] Instance t_RandomCanvas_t_Shl : t_Shl t_RandomCanvas uint_size := {
  t_Output := t_RandomCanvas;
  shl (self : t_RandomCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  into (a shift_left b);
}.

#[global] Instance t_RandomCanvas_t_PartialEq : t_PartialEq t_RandomCanvas t_RandomCanvas := {
  eq (self : t_RandomCanvas) (rhs : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  a =.? b;
}.

#[global] Instance t_RandomCanvas_t_Eq : t_Eq t_RandomCanvas := {
}.

#[global] Instance t_RandomCanvas_t_PartialOrd : t_PartialOrd t_RandomCanvas t_RandomCanvas := {
  partial_cmp (self : t_RandomCanvas) (other : t_RandomCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into other) : both _ _ (t_BigInt) in
  partial_cmp a b;
}.

#[global] Instance t_RandomCanvas_t_Ord : t_Ord t_RandomCanvas := {
  cmp (self : t_RandomCanvas) (other : t_RandomCanvas) := unwrap_under_impl (partial_cmp self other);
}.

Program Definition from_byte_seq_be_under_impl_75 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_RandomCanvas) :=
  from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x)))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_75 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_RandomCanvas) :=
  from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x)))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_75 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_RandomCanvas)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (unsize (to_be_bytes_under_impl_82 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

#[global] Instance t_RandomCanvas_t_NumericCopy : t_NumericCopy t_RandomCanvas := {
}.

#[global] Instance t_RandomCanvas_t_UnsignedInteger : t_UnsignedInteger t_RandomCanvas := {
}.

#[global] Instance t_RandomCanvas_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_RandomCanvas := {
}.

#[global] Instance t_RandomCanvas_t_Integer : t_Integer t_RandomCanvas := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_83 i128(0);
  ONE := from_literal_under_impl_83 i128(1);
  TWO := from_literal_under_impl_83 i128(2);
  from_literal (val : int128) := from_literal_under_impl_83 val;
  from_hex_string (s : t_String) := from_hex_under_impl_82 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_RandomCanvas) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_RandomCanvas) (b : t_RandomCanvas) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_83 (not (i128(1) shift_left i))) : both _ _ (t_RandomCanvas) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_RandomCanvas) (pos : uint_size) (y : t_RandomCanvas) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_RandomCanvas) in
  set_bit self b pos;
  rotate_left (self : t_RandomCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_RandomCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_RandomCanvas_t_ModNumeric : t_ModNumeric t_RandomCanvas := {
  sub_mod (self : t_RandomCanvas) (rhs : t_RandomCanvas) (n : t_RandomCanvas) := (self .- rhs) .% n;
  add_mod (self : t_RandomCanvas) (rhs : t_RandomCanvas) (n : t_RandomCanvas) := (self .+ rhs) .% n;
  mul_mod (self : t_RandomCanvas) (rhs : t_RandomCanvas) (n : t_RandomCanvas) := (self .* rhs) .% n;
  pow_mod (self : t_RandomCanvas) (exp : t_RandomCanvas) (n : t_RandomCanvas) := pow_felem_under_impl_94 self exp n;
  modulo (self : t_RandomCanvas) (n : t_RandomCanvas) := self .% n;
  signed_modulo (self : t_RandomCanvas) (n : t_RandomCanvas) := modulo self n;
  absolute (self : t_RandomCanvas) := self;
}.

#[global] Instance t_RandomCanvas_t_Numeric : t_Numeric t_RandomCanvas := {
  max_val := max_value_under_impl_83;
  wrap_add (self : t_RandomCanvas) (rhs : t_RandomCanvas) := self .+ rhs;
  wrap_sub (self : t_RandomCanvas) (rhs : t_RandomCanvas) := self .- rhs;
  wrap_mul (self : t_RandomCanvas) (rhs : t_RandomCanvas) := self .* rhs;
  wrap_div (self : t_RandomCanvas) (rhs : t_RandomCanvas) := self ./ rhs;
  exp (self : t_RandomCanvas) (exp : int32) := pow_under_impl_94 self (into exp) max_val;
  pow_self (self : t_RandomCanvas) (exp : t_RandomCanvas) := pow_felem_under_impl_94 self (into exp) max_val;
  divide (self : t_RandomCanvas) (rhs : t_RandomCanvas) := self ./ rhs;
  inv (self : t_RandomCanvas) (n : t_RandomCanvas) := inv_under_impl_94 self n;
  equal (self : t_RandomCanvas) (other : t_RandomCanvas) := self =.? other;
  greater_than (self : t_RandomCanvas) (other : t_RandomCanvas) := self >.? other;
  greater_than_or_equal (self : t_RandomCanvas) (other : t_RandomCanvas) := self >=.? other;
  less_than (self : t_RandomCanvas) (other : t_RandomCanvas) := self <.? other;
  less_than_or_equal (self : t_RandomCanvas) (other : t_RandomCanvas) := self >=.? other;
  not_equal_bm (self : t_RandomCanvas) (other : t_RandomCanvas) := ifb not (equal self other)
  then max_val
  else from_literal_under_impl_83 i128(0);
  equal_bm (self : t_RandomCanvas) (other : t_RandomCanvas) := ifb equal self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  greater_than_bm (self : t_RandomCanvas) (other : t_RandomCanvas) := ifb greater_than self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  greater_than_or_equal_bm (self : t_RandomCanvas) (other : t_RandomCanvas) := ifb greater_than_or_equal self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  less_than_bm (self : t_RandomCanvas) (other : t_RandomCanvas) := ifb less_than self other
  then max_val
  else from_literal_under_impl_83 i128(0);
  less_than_or_equal_bm (self : t_RandomCanvas) (other : t_RandomCanvas) := ifb less_than_or_equal self other
  then max_val
  else from_literal_under_impl_83 i128(0);
}.

Definition t_Random : choice_type :=
  (t_RandomCanvas).
Equations Build_t_Random {L : {fset Location}} {I : Interface} (0 : both L I (t_RandomCanvas)) : both L I (t_Random) :=
  Build_t_Random 0  :=
    bind_both 0 (fun 0 =>
      ret_both 0) : both L I (t_Random).
Fail Next Obligation.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

#[global] Instance t_Random_t_From : t_From t_Random t_RandomCanvas := {
  from (x : t_RandomCanvas) := Random (rem_under_impl_94 x (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab));
}.

#[global] Instance t_Random_t_Into : t_Into t_Random t_RandomCanvas := {
  into (self : t_Random) := 0 self;
}.

Program Definition from_canvas_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_RandomCanvas)) : both (L1 :|: fset [x_loc]) (I1) (t_Random) :=
  Random (rem_under_impl_94 x (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)).
Fail Next Obligation.

Program Definition into_canvas_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1) (I1) (t_RandomCanvas) :=
  0 self.
Fail Next Obligation.

Program Definition max_under_impl_131 : both (fset [x_loc]) ([interface ]) (t_RandomCanvas) :=
  from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab.
Fail Next Obligation.

Program Definition declassify_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1) (I1) (t_BigInt) :=
  letb a := (into self) : both _ _ (t_RandomCanvas) in
  into a.
Fail Next Obligation.

(*item error backend*)

Program Definition from_be_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_Random) :=
  into (from_be_bytes_under_impl_82 v).
Fail Next Obligation.

Program Definition to_be_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_be_bytes_under_impl_82 (into self))).
Fail Next Obligation.

Program Definition from_le_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_Random) :=
  into (from_le_bytes_under_impl_82 v).
Fail Next Obligation.

Program Definition to_le_bytes_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1 :|: fset [repr_loc]) (I1) (t_Vec (int8) (t_Global)) :=
  to_vec_under_impl (unsize (to_le_bytes_under_impl_82 (into self))).
Fail Next Obligation.

Program Definition bit_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (i : both L2 I2 (uint_size)) : both (L1:|:L2) (I1:|:I2) ('bool) :=
  bit_under_impl_83 (into self) i.
Fail Next Obligation.

Program Definition from_literal_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_Random) :=
  letb big_x := (from x) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_131)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type Random])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  Random (into big_x).
Fail Next Obligation.

Program Definition from_signed_literal_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_Random) :=
  letb big_x := (from (cast_int x)) : both _ _ (t_BigUint) in
  letb _ := (ifb big_x >.? (into max_under_impl_131)
    then letb 'tt := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [literal ;
           too big for type Random])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  Random (into big_x).
Fail Next Obligation.

Program Definition comp_eq_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (rhs : both L2 I2 (t_Random)) : both (L1:|:L2) (I1:|:I2) (t_Random) :=
  letb x := (into self) : both _ _ (t_RandomCanvas) in
  into (comp_eq_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_ne_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (rhs : both L2 I2 (t_Random)) : both (L1:|:L2) (I1:|:I2) (t_Random) :=
  letb x := (into self) : both _ _ (t_RandomCanvas) in
  into (comp_ne_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gte_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (rhs : both L2 I2 (t_Random)) : both (L1:|:L2) (I1:|:I2) (t_Random) :=
  letb x := (into self) : both _ _ (t_RandomCanvas) in
  into (comp_gte_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_gt_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (rhs : both L2 I2 (t_Random)) : both (L1:|:L2) (I1:|:I2) (t_Random) :=
  letb x := (into self) : both _ _ (t_RandomCanvas) in
  into (comp_gt_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lte_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (rhs : both L2 I2 (t_Random)) : both (L1:|:L2) (I1:|:I2) (t_Random) :=
  letb x := (into self) : both _ _ (t_RandomCanvas) in
  into (comp_lte_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition comp_lt_under_impl_131 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (rhs : both L2 I2 (t_Random)) : both (L1:|:L2) (I1:|:I2) (t_Random) :=
  letb x := (into self) : both _ _ (t_RandomCanvas) in
  into (comp_lt_under_impl_82 x (into rhs)).
Fail Next Obligation.

Program Definition neg_under_impl_131 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1 :|: fset [x_loc]) (I1) (t_Random) :=
  letb mod_val := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigInt) in
  letb s := (into self) : both _ _ (t_RandomCanvas) in
  letb s := (into s) : both _ _ (t_BigInt) in
  letb result := (into (mod_val .- s)) : both _ _ (t_RandomCanvas) in
  into result.
Fail Next Obligation.

#[global] Instance t_Random_t_PartialOrd : t_PartialOrd t_Random t_Random := {
  partial_cmp (self : t_Random) (other : t_Random) := Option_Some (cmp self other);
}.

#[global] Instance t_Random_t_Ord : t_Ord t_Random := {
  cmp (self : t_Random) (other : t_Random) := cmp (0 self) (0 other);
}.

#[global] Instance t_Random_t_PartialEq : t_PartialEq t_Random t_Random := {
  eq (self : t_Random) (other : t_Random) := (0 self) =.? (0 other);
}.

#[global] Instance t_Random_t_Eq : t_Eq t_Random := {
}.

#[global] Instance t_Random_t_Add : t_Add t_Random t_Random := {
  t_Output := t_Random;
  add (self : t_Random) (rhs : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  letb b := (into rhs) : both _ _ (t_RandomCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_RandomCanvas) in
  into d;
}.

#[global] Instance t_Random_t_Sub : t_Sub t_Random t_Random := {
  t_Output := t_Random;
  sub (self : t_Random) (rhs : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  letb b := (into rhs) : both _ _ (t_RandomCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb c := (ifb b >.? a
    then ((clone max) .- b) .+ a
    else a .- b) : both _ _ (t_Output) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_RandomCanvas) in
  into d;
}.

#[global] Instance t_Random_t_Mul : t_Mul t_Random t_Random := {
  t_Output := t_Random;
  mul (self : t_Random) (rhs : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  letb b := (into rhs) : both _ _ (t_RandomCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_RandomCanvas) in
  into d;
}.

#[global] Instance t_Random_t_Div : t_Div t_Random t_Random := {
  t_Output := t_Random;
  div (self : t_Random) (rhs : t_Random) := self .* (inv_under_impl_125 rhs);
}.

#[global] Instance t_Random_t_Rem : t_Rem t_Random t_Random := {
  t_Output := t_Random;
  rem (self : t_Random) (rhs : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  letb b := (into rhs) : both _ _ (t_RandomCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .% b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_82 1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_RandomCanvas) in
  into d;
}.

#[global] Instance t_Random_t_Not : t_Not t_Random := {
  t_Output := t_Random;
  not (self : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  into (not a);
}.

#[global] Instance t_Random_t_BitOr : t_BitOr t_Random t_Random := {
  t_Output := t_Random;
  bitor (self : t_Random) (rhs : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  letb b := (into rhs) : both _ _ (t_RandomCanvas) in
  into (a .| b);
}.

#[global] Instance t_Random_t_BitXor : t_BitXor t_Random t_Random := {
  t_Output := t_Random;
  bitxor (self : t_Random) (rhs : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  letb b := (into rhs) : both _ _ (t_RandomCanvas) in
  into (a .^ b);
}.

#[global] Instance t_Random_t_BitAnd : t_BitAnd t_Random t_Random := {
  t_Output := t_Random;
  bitand (self : t_Random) (rhs : t_Random) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  letb b := (into rhs) : both _ _ (t_RandomCanvas) in
  into (a .& b);
}.

#[global] Instance t_Random_t_Shr : t_Shr t_Random uint_size := {
  t_Output := t_Random;
  shr (self : t_Random) (rhs : uint_size) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  into (a shift_right rhs);
}.

#[global] Instance t_Random_t_Shl : t_Shl t_Random uint_size := {
  t_Output := t_Random;
  shl (self : t_Random) (rhs : uint_size) := letb a := (into self) : both _ _ (t_RandomCanvas) in
  into (a shift_left rhs);
}.

Program Definition inv_under_impl_125 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1 :|: fset [x_loc]) (I1) (t_Random) :=
  letb base := (into self) : both _ _ (t_RandomCanvas) in
  into (inv_under_impl_94 base max_under_impl_131).
Fail Next Obligation.

Program Definition pow_felem_under_impl_125 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (exp : both L2 I2 (t_Random)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_Random) :=
  letb base := (into self) : both _ _ (t_RandomCanvas) in
  into (pow_felem_under_impl_94 base (into exp) max_under_impl_131).
Fail Next Obligation.

Program Definition pow_under_impl_125 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_Random)) (exp : both L2 I2 (int128)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_Random) :=
  letb base := (into self) : both _ _ (t_RandomCanvas) in
  into (pow_under_impl_94 base exp max_under_impl_131).
Fail Next Obligation.

Program Definition pow2_under_impl_125 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_Random) :=
  into (pow2_under_impl_83 x).
Fail Next Obligation.

Program Definition from_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Random) :=
  into (from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Random) :=
  into (from_be_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_be_bytes_under_impl_131 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_be_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_be_bytes_under_impl_131 self).
Fail Next Obligation.

Program Definition from_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Random) :=
  into (from_le_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    declassify_under_impl_2 x))))).
Fail Next Obligation.

Program Definition from_public_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_Random) :=
  into (from_le_bytes_under_impl_82 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
    x))))).
Fail Next Obligation.

Program Definition to_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (t_U8)) :=
  from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_le_bytes_under_impl_131 self))) (fun x =>
    classify_under_impl_2 x))).
Fail Next Obligation.

Program Definition to_public_byte_seq_le_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_Random)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (int8)) :=
  from_vec_under_impl_52 (to_le_bytes_under_impl_131 self).
Fail Next Obligation.

Program Definition from_secret_literal_under_impl_68 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_U128)) : both (L1) (I1) (t_Random) :=
  into (from_literal_under_impl_83 (declassify_under_impl_126 x)).
Fail Next Obligation.

#[global] Instance t_Random_t_NumericCopy : t_NumericCopy t_Random := {
}.

#[global] Instance t_Random_t_UnsignedInteger : t_UnsignedInteger t_Random := {
}.

#[global] Instance t_Random_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_Random := {
}.

#[global] Instance t_Random_t_Integer : t_Integer t_Random := {
  NUM_BITS := i32(384);
  ZERO := from_literal_under_impl_131 i128(0);
  ONE := from_literal_under_impl_131 i128(1);
  TWO := from_literal_under_impl_131 i128(2);
  from_literal (val : int128) := from_literal_under_impl_131 val;
  from_hex_string (s : t_String) := from_hex_under_impl_131 (deref (replace_under_impl_5 (deref s) 0x ));
  get_bit (self : t_Random) (i : uint_size) := (self shift_right i) .& v_ONE;
  set_bit (self : t_Random) (b : t_Random) (i : uint_size) := letb _ := (ifb true
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb 'tt := (never_to_any (panic assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()))) : both _ _ (unit) in
          tt
        else tt) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  letb tmp1 := (from_literal_under_impl_131 (not (i128(1) shift_left i))) : both _ _ (t_Random) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  (self .& tmp1) .| tmp2;
  set (self : t_Random) (pos : uint_size) (y : t_Random) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_Random) in
  set_bit self b pos;
  rotate_left (self : t_Random) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
  rotate_right (self : t_Random) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb 'tt := (never_to_any (panic assertion failed: n < Self::NUM_BITS)) : both _ _ (unit) in
      tt
    else tt) : both _ _ (unit) in
  ((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- i32(1))));
}.

#[global] Instance t_Random_t_ModNumeric : t_ModNumeric t_Random := {
  sub_mod (self : t_Random) (rhs : t_Random) (n : t_Random) := self .- rhs;
  add_mod (self : t_Random) (rhs : t_Random) (n : t_Random) := self .+ rhs;
  mul_mod (self : t_Random) (rhs : t_Random) (n : t_Random) := self .* rhs;
  pow_mod (self : t_Random) (exp : t_Random) (n : t_Random) := pow_felem_under_impl_125 self exp;
  modulo (self : t_Random) (n : t_Random) := self .% n;
  signed_modulo (self : t_Random) (n : t_Random) := modulo self n;
  absolute (self : t_Random) := self;
}.

#[global] Instance t_Random_t_Numeric : t_Numeric t_Random := {
  max_val := into (max_under_impl_131 .- (from_literal_under_impl_83 i128(1)));
  wrap_add (self : t_Random) (rhs : t_Random) := self .+ rhs;
  wrap_sub (self : t_Random) (rhs : t_Random) := self .- rhs;
  wrap_mul (self : t_Random) (rhs : t_Random) := self .* rhs;
  wrap_div (self : t_Random) (rhs : t_Random) := self ./ rhs;
  exp (self : t_Random) (exp : int32) := pow_under_impl_125 self (into exp);
  pow_self (self : t_Random) (exp : t_Random) := pow_felem_under_impl_125 self exp;
  divide (self : t_Random) (rhs : t_Random) := self ./ rhs;
  inv (self : t_Random) (n : t_Random) := inv_under_impl_125 self;
  equal (self : t_Random) (other : t_Random) := self =.? other;
  greater_than (self : t_Random) (other : t_Random) := self >.? other;
  greater_than_or_equal (self : t_Random) (other : t_Random) := self >=.? other;
  less_than (self : t_Random) (other : t_Random) := self <.? other;
  less_than_or_equal (self : t_Random) (other : t_Random) := self <=.? other;
  not_equal_bm (self : t_Random) (other : t_Random) := ifb self <> other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  equal_bm (self : t_Random) (other : t_Random) := ifb self =.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_bm (self : t_Random) (other : t_Random) := ifb self >.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  greater_than_or_equal_bm (self : t_Random) (other : t_Random) := ifb self >=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_bm (self : t_Random) (other : t_Random) := ifb self <.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
  less_than_or_equal_bm (self : t_Random) (other : t_Random) := ifb self <=.? other
  then (v_ONE shift_left (i32(384) .- i32(1))) .- v_ONE
  else v_ZERO;
}.

Program Definition sample_uniform : both (fset []) ([interface ]) (t_Random) :=
  v_ONE.
Fail Next Obligation.

Require Import Std. (* as HashMap *)

Require Import Std.

Require Import Std. (* as Hash *)

Require Import Std. (* as Hasher *)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

Program Definition random_oracle_query {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (QUERIES : both L1 I1 (t_HashMap (t_Query) (t_Random) (t_RandomState))) (q : both L2 I2 (t_Query)) : both (L1:|:L2) (I1:|:I2) ((t_HashMap (t_Query) (t_Random) (t_RandomState) × t_Random)) :=
  match get_under_impl_2 QUERIES q with
  | Option_Some r => prod_b(clone QUERIES,clone r)
  | Option_None  => letb r := (sample_uniform) : both _ _ (t_Random) in
    letb '(todo_fresh_var,QUERIES_temp) := (insert_under_impl_2 QUERIES q r) : both _ _ ((t_Option (t_Random) × t_HashMap (t_Query) (t_Random) (t_RandomState))) in
    letb QUERIES := (QUERIES_temp) : both _ _ (t_HashMap (t_Query) (t_Random) (t_RandomState)) in
    letb _ := (todo_fresh_var) : both _ _ (t_Option (t_Random)) in
    prod_b(QUERIES,r)
  end.
Fail Next Obligation.
