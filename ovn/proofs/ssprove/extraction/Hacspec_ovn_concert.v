(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Class t_Group (Self : choice_type) := {
  t_group_type : choice_type ;
  t_group_type_t_Serialize :> t_Serialize (t_group_type) ;
  t_group_type_t_Deserial :> t_Deserial (t_group_type) ;
  t_group_type_t_Serial :> t_Serial (t_group_type) ;
  t_group_type_t_Copy :> t_Copy (t_group_type) ;
  t_group_type_t_Clone :> t_Clone (t_group_type) ;
  t_group_type_t_Eq :> t_Eq (t_group_type) ;
  t_group_type_t_PartialEq :> t_PartialEq (t_group_type) ;
  t_group_type_t_Sized :> t_Sized (t_group_type) ;
  q : forall {L1 I1}, both L1 I1 (int32) ;
  g : forall {L1 I1}, both L1 I1 (t_group_type) ;
  g_pow_loc : {fset Location} ;
  g_pow : forall {L1 I1}, both L1 I1 (int32) -> both (L1 :|: g_pow_loc) I1 (t_group_type) ;
  pow_loc : {fset Location} ;
  pow : forall {L1 L2 I1 I2}, both L1 I1 (t_group_type) -> both L2 I2 (int32) -> both (L1 :|: L2 :|: pow_loc) (I1 :|: I2) (t_group_type) ;
  one_loc : {fset Location} ;
  one : forall {L1 I1}, both (L1 :|: one_loc) I1 (t_group_type) ;
  prod_loc : {fset Location} ;
  prod : forall {L1 L2 I1 I2}, both L1 I1 (t_group_type) -> both L2 I2 (t_group_type) -> both (L1 :|: L2 :|: prod_loc) (I1 :|: I2) (t_group_type) ;
  inv_loc : {fset Location} ;
  inv : forall {L1 I1}, both L1 I1 (t_group_type) -> both (L1 :|: inv_loc) I1 (t_group_type) ;
  div_loc : {fset Location} ;
  div : forall {L1 L2 I1 I2}, both L1 I1 (t_group_type) -> both L2 I2 (t_group_type) -> both (L1 :|: L2 :|: div_loc) (I1 :|: I2) (t_group_type) ;
}.

Definition t_z_17_ : choice_type :=
  'unit.
Equations Build_t_z_17_ : both(fset []) (fset []) (t_z_17_) :=
  Build_t_z_17_  :=
    solve_lift (ret_both ((_) : (t_z_17_))) : both(fset []) (fset []) (t_z_17_).
Fail Next Obligation.

Definition res_loc : Location :=
  (int32 ; 0%nat).
#[global] Program Instance t_z_17__t_Group : t_Group t_z_17_ :=
  let t_group_type := int32 : choice_type in
  let q := fun  {L : {fset Location}} {I : Interface} => solve_lift (ret_both (17 : int32)) : both L I (int32) in
  let g := fun  {L : {fset Location}} {I : Interface} => solve_lift (ret_both (3 : int32)) : both L I (int32) in
  let g_pow := fun  {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int32)) => solve_lift ((g .^ x) .% q) : both L1 I1 (int32) in
  let pow := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g : both L1 I1 (int32)) (x : both L2 I2 (int32)) => solve_lift ((g .^ x) .% q) : both (L1 :|: L2) (I1 :|: I2) (int32) in
  let one := fun  {L : {fset Location}} {I : Interface} => solve_lift (ret_both (1 : int32)) : both L I (int32) in
  let prod := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (x : both L1 I1 (int32)) (y : both L2 I2 (int32)) => solve_lift ((x .* y) .% q) : both (L1 :|: L2) (I1 :|: I2) (int32) in
  let inv := fun  {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int32)) => letb res loc(res_loc) := ret_both (0 : int32) in
  letb res := foldi_both (into_iter (Build_Range (f_start := ret_both (1 : int32)) (f_end := q))) (fun {L I _ _} =>fun i =>
    ssp (fun res =>
      solve_lift (ifb (g_pow i) =.? x
      then letb res := i in
        res
      else res))) res in
  solve_lift res : both (L1 :|: fset [res_loc]) I1 (int32) in
  let div := fun  {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (x : both L1 I1 (int32)) (y : both L2 I2 (int32)) => solve_lift (prod x (inv y)) : both (L1 :|: L2 :|: fset [res_loc]) (I1 :|: I2) (int32) in
  {| t_group_type := (@t_group_type);
  q := (@q);
  g := (@g);
  g_pow_loc := (fset [] : {fset Location});
  g_pow := (@g_pow);
  pow_loc := (fset [] : {fset Location});
  pow := (@pow);
  one_loc := (fset [] : {fset Location});
  one := (@one);
  prod_loc := (fset [] : {fset Location});
  prod := (@prod);
  inv_loc := (fset [res_loc] : {fset Location});
  inv := (@inv);
  div_loc := (fset [res_loc] : {fset Location});
  div := (@div)|}.
Solve All Obligations with exact int_eqdec.
Fail Next Obligation. 

Notation "'t_G'" := (t_z_17_).

Equations n {L : {fset Location}} {I : Interface} : both L I (uint_size) :=
  n  :=
    solve_lift (ret_both (20 : uint_size)) : both L I (uint_size).
Fail Next Obligation.

Definition t_OvnContractState : choice_type :=
  (nseq t_group_type 20 × nseq int32 20 × nseq int32 20 × nseq t_group_type 20 × nseq int32 20 × int32).
Equations f_g_pow_xis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq t_group_type 20) :=
  f_g_pow_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst (fst x)))) : nseq t_group_type 20))) : both L I (nseq t_group_type 20).
Fail Next Obligation.
Equations f_zkp_xis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq int32 20) :=
  f_zkp_xis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst (fst x)))) : nseq int32 20))) : both L I (nseq int32 20).
Fail Next Obligation.
Equations f_commit_vis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq int32 20) :=
  f_commit_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : nseq int32 20))) : both L I (nseq int32 20).
Fail Next Obligation.
Equations f_g_pow_xi_yi_vis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq t_group_type 20) :=
  f_g_pow_xi_yi_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : nseq t_group_type 20))) : both L I (nseq t_group_type 20).
Fail Next Obligation.
Equations f_zkp_vis {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (nseq int32 20) :=
  f_zkp_vis s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : nseq int32 20))) : both L I (nseq int32 20).
Fail Next Obligation.
Equations f_tally {L : {fset Location}} {I : Interface} (s : both L I (t_OvnContractState)) : both L I (int32) :=
  f_tally s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : int32))) : both L I (int32).
Fail Next Obligation.
Equations Build_t_OvnContractState {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {L5 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {I5 : Interface} {f_g_pow_xis : both L0 I0 (nseq t_group_type 20)} {f_zkp_xis : both L1 I1 (nseq int32 20)} {f_commit_vis : both L2 I2 (nseq int32 20)} {f_g_pow_xi_yi_vis : both L3 I3 (nseq t_group_type 20)} {f_zkp_vis : both L4 I4 (nseq int32 20)} {f_tally : both L5 I5 (int32)} : both(L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_OvnContractState) :=
  Build_t_OvnContractState  :=
    bind_both f_tally (fun f_tally =>
      bind_both f_zkp_vis (fun f_zkp_vis =>
        bind_both f_g_pow_xi_yi_vis (fun f_g_pow_xi_yi_vis =>
          bind_both f_commit_vis (fun f_commit_vis =>
            bind_both f_zkp_xis (fun f_zkp_xis =>
              bind_both f_g_pow_xis (fun f_g_pow_xis =>
                solve_lift (ret_both ((f_g_pow_xis,f_zkp_xis,f_commit_vis,f_g_pow_xi_yi_vis,f_zkp_vis,f_tally) : (t_OvnContractState))))))))) : both(L0:|:L1:|:L2:|:L3:|:L4:|:L5) (I0:|:I1:|:I2:|:I3:|:I4:|:I5) (t_OvnContractState).
Fail Next Obligation.
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := y) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_xis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := y) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_commit_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := y) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_g_pow_xi_yi_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := y) (f_zkp_vis := f_zkp_vis x) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_zkp_vis' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := y) (f_tally := f_tally x)).
Notation "'Build_t_OvnContractState' '[' x ']' '(' 'f_tally' ':=' y ')'" := (Build_t_OvnContractState (f_g_pow_xis := f_g_pow_xis x) (f_zkp_xis := f_zkp_xis x) (f_commit_vis := f_commit_vis x) (f_g_pow_xi_yi_vis := f_g_pow_xi_yi_vis x) (f_zkp_vis := f_zkp_vis x) (f_tally := y)).
Definition state_OVN : choice_type :=
  t_OvnContractState.

Equations init_ovn_contract {L1 : {fset Location}} {I1 : Interface} {T : _} `{ t_Sized (T)} `{ t_HasInitContext (T) ('unit)} (ctx : both L1 I1 (T)) : both L1 I1 (t_Result ('bool) ('unit)) :=
  init_ovn_contract ctx  :=
    Result_Ok (solve_lift (ret_both (true : 'bool))) : both L1 I1 (t_Result ('bool) ('unit)).
Fail Next Obligation.

From ConCert.Utils Require Import Extras.
From ConCert.Utils Require Import Automation.
From ConCert.Execution Require Import Serializable.
From ConCert.Execution Require Import Blockchain.
From ConCert.Execution Require Import ContractCommon.
Require Import ConCertLib.

Instance int_default {WS} : Default (int WS) := {| default := 0 |}.
Instance nseq_default {A : choice_type} {len} `{Default A} : Default (nseq_ A len) := {|
    default := eq_rect (Datatypes.length (List.repeat default len))
     (fun n : nat => nseq_ A n) (Hacspec_Lib_Pre.array_from_list (List.repeat default len)) len (List.repeat_length default len)
  |}.
Program Instance both_default {A : choice_type} `{Default A} : Default (both (fset []) (fset []) A) := {|
    default := ret_both default
  |}.
Solve All Obligations with solve_ssprove_obligations.
Fail Next Obligation.

Require Import ConCertLib.
(* Definition Setup :=  *)
Definition init_OVN (chain : Chain) (ctx : ContractCallContext) (st : state_OVN) : ResultMonad.result state_OVN state_OVN :=
  ResultMonad.Ok st.

Inductive OVN_Msg: Type :=
| register : OVN_Msg
| commit_to_vote : OVN_Msg
| cast_vote : OVN_Msg
| tally : OVN_Msg.

Definition OVN_receive (chain : Chain) (ctx : ContractCallContext) (state  : state_OVN) (msg : Datatypes.option OVN_Msg) : ResultMonad.result (state_OVN * list ActionBody) state_OVN :=
  match msg with
  | Some register => ResultMonad.Ok (state, [])
  | Some v => ResultMonad.Ok (state, [])
  | None => ResultMonad.Err state
  end.

Instance serializeable_msg : Serializable OVN_Msg.
Admitted.

Instance serializeable_state_ovn : Serializable state_OVN.
Admitted.

Definition auction_contract : Contract _ (* Setup *) OVN_Msg state_OVN _ := build_contract init_OVN OVN_receive.


Equations select_private_voting_key {L1 : {fset Location}} {I1 : Interface} (random : both L1 I1 (int32)) : both L1 I1 (int32) :=
  select_private_voting_key random  :=
    solve_lift (random .% q) : both L1 I1 (int32).
Fail Next Obligation.

Equations v_ZKP {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi : both L1 I1 (int32)) (xi : both L2 I2 (int32)) : both (L1 :|: L2) (I1 :|: I2) (int32) :=
  v_ZKP g_pow_xi xi  :=
    solve_lift (ret_both (0 : int32)) : both (L1 :|: L2) (I1 :|: I2) (int32).
Fail Next Obligation.

Definition t_RegisterParam : choice_type :=
  (int32 × int32).
Equations f_i {L : {fset Location}} {I : Interface} (s : both L I (t_RegisterParam)) : both L I (int32) :=
  f_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : int32))) : both L I (int32).
Fail Next Obligation.
Equations f_xi {L : {fset Location}} {I : Interface} (s : both L I (t_RegisterParam)) : both L I (int32) :=
  f_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : int32))) : both L I (int32).
Fail Next Obligation.
Equations Build_t_RegisterParam {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_i : both L0 I0 (int32)} {f_xi : both L1 I1 (int32)} : both(L0:|:L1) (I0:|:I1) (t_RegisterParam) :=
  Build_t_RegisterParam  :=
    bind_both f_xi (fun f_xi =>
      bind_both f_i (fun f_i =>
        solve_lift (ret_both ((f_i,f_xi) : (t_RegisterParam))))) : both(L0:|:L1) (I0:|:I1) (t_RegisterParam).
Fail Next Obligation.
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_i' ':=' y ')'" := (Build_t_RegisterParam (f_i := y) (f_xi := f_xi x)).
Notation "'Build_t_RegisterParam' '[' x ']' '(' 'f_xi' ':=' y ')'" := (Build_t_RegisterParam (f_i := f_i x) (f_xi := y)).

Equations register_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {T : _} `{ t_Sized (A)} `{ t_Sized (T)} `{ t_HasActions (A)} `{ t_HasReceiveContext (T) ('unit)} `{ t_Sized (A)} `{ t_Sized (T)} `{ t_HasActions (A)} `{ t_HasReceiveContext (T) ('unit)} (ctx : both L1 I1 (T)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  register_vote ctx state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.
Definition receive_OVN_register (RegisterParam : _) (st : state_OVN) : choice_type :=
  register_vote st.

Definition t_CastVoteParam : choice_type :=
  (int32 × int32 × 'bool).
Equations f_i {L : {fset Location}} {I : Interface} (s : both L I (t_CastVoteParam)) : both L I (int32) :=
  f_i s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : int32))) : both L I (int32).
Fail Next Obligation.
Equations f_xi {L : {fset Location}} {I : Interface} (s : both L I (t_CastVoteParam)) : both L I (int32) :=
  f_xi s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : int32))) : both L I (int32).
Fail Next Obligation.
Equations f_vote {L : {fset Location}} {I : Interface} (s : both L I (t_CastVoteParam)) : both L I ('bool) :=
  f_vote s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : 'bool))) : both L I ('bool).
Fail Next Obligation.
Equations Build_t_CastVoteParam {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {f_i : both L0 I0 (int32)} {f_xi : both L1 I1 (int32)} {f_vote : both L2 I2 ('bool)} : both(L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_CastVoteParam) :=
  Build_t_CastVoteParam  :=
    bind_both f_vote (fun f_vote =>
      bind_both f_xi (fun f_xi =>
        bind_both f_i (fun f_i =>
          solve_lift (ret_both ((f_i,f_xi,f_vote) : (t_CastVoteParam)))))) : both(L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_CastVoteParam).
Fail Next Obligation.
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_i' ':=' y ')'" := (Build_t_CastVoteParam (f_i := y) (f_xi := f_xi x) (f_vote := f_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_xi' ':=' y ')'" := (Build_t_CastVoteParam (f_i := f_i x) (f_xi := y) (f_vote := f_vote x)).
Notation "'Build_t_CastVoteParam' '[' x ']' '(' 'f_vote' ':=' y ')'" := (Build_t_CastVoteParam (f_i := f_i x) (f_xi := f_xi x) (f_vote := y)).

Equations check_valid {L1 : {fset Location}} {I1 : Interface} (zkp : both L1 I1 (int32)) : both L1 I1 ('bool) :=
  check_valid zkp  :=
    solve_lift (ret_both (true : 'bool)) : both L1 I1 ('bool).
Fail Next Obligation.

Definition prod2_loc : Location :=
  (int32 ; 2%nat).
Definition prod1_loc : Location :=
  (int32 ; 1%nat).
Equations compute_group_element_for_vote {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (i : both L1 I1 (int32)) (xi : both L2 I2 (int32)) (vote : both L3 I3 ('bool)) (xis : both L4 I4 (nseq int32 20)) : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [prod2_loc;prod1_loc;res_loc]) (I1 :|: I2 :|: I3 :|: I4) (int32) :=
  compute_group_element_for_vote i xi vote xis  :=
    letb prod1 loc(prod1_loc) := one in
    letb prod1 := foldi_both (into_iter (Build_Range (f_start := ret_both (0 : uint_size)) (f_end := cast_int (WS2 := _) (i .- (ret_both (1 : int32)))))) (fun {L I _ _} =>fun j =>
      ssp (fun prod1 =>
        solve_lift (prod prod1 (xis.a[j])))) prod1 in
    letb prod2 loc(prod2_loc) := one in
    letb prod2 := foldi_both (into_iter (Build_Range (f_start := cast_int (WS2 := _) (i .+ (ret_both (1 : int32)))) (f_end := n))) (fun {L I _ _} =>fun j =>
      ssp (fun prod2 =>
        solve_lift (prod prod2 (xis.a[j])))) prod2 in
    letb Yi := div prod1 prod2 in
    solve_lift (prod (pow Yi xi) (g_pow (ifb vote
    then ret_both (1 : int32)
    else ret_both (0 : int32)))) : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [prod2_loc;prod1_loc;res_loc]) (I1 :|: I2 :|: I3 :|: I4) (int32).
Fail Next Obligation.

Equations commit_to {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int32)) : both L1 I1 (int32) :=
  commit_to x  :=
    solve_lift (ret_both (0 : int32)) : both L1 I1 (int32).
Fail Next Obligation.

Equations commit_to_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {impl HasReceiveContext : _} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} (ctx : both L1 I1 (impl HasReceiveContext)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  commit_to_vote ctx state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.
Definition receive_OVN_commit_to_vote (CastVoteParam : _) (st : state_OVN) : choice_type :=
  commit_to_vote st.

Equations v_ZKP_one_out_of_two {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_vi : both L1 I1 (int32)) (vi : both L2 I2 ('bool)) : both (L1 :|: L2) (I1 :|: I2) (int32) :=
  v_ZKP_one_out_of_two g_pow_vi vi  :=
    solve_lift (ret_both (32 : int32)) : both (L1 :|: L2) (I1 :|: I2) (int32).
Fail Next Obligation.

Equations cast_vote {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {impl HasReceiveContext : _} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} (ctx : both L1 I1 (impl HasReceiveContext)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  cast_vote ctx state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.
Definition receive_OVN_cast_vote (CastVoteParam : _) (st : state_OVN) : choice_type :=
  cast_vote st.

Equations check_valid2 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi_yi_vi : both L1 I1 (int32)) (zkp : both L2 I2 (int32)) : both (L1 :|: L2) (I1 :|: I2) ('bool) :=
  check_valid2 g_pow_xi_yi_vi zkp  :=
    solve_lift (ret_both (true : 'bool)) : both (L1 :|: L2) (I1 :|: I2) ('bool).
Fail Next Obligation.

Equations check_commitment {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (g_pow_xi_yi_vi : both L1 I1 (int32)) (zkp : both L2 I2 (int32)) : both (L1 :|: L2) (I1 :|: I2) ('bool) :=
  check_commitment g_pow_xi_yi_vi zkp  :=
    solve_lift (ret_both (true : 'bool)) : both (L1 :|: L2) (I1 :|: I2) ('bool).
Fail Next Obligation.

Definition t_TallyParameter : choice_type :=
  'unit.
Equations Build_t_TallyParameter : both(fset []) (fset []) (t_TallyParameter) :=
  Build_t_TallyParameter  :=
    solve_lift (ret_both ((_) : (t_TallyParameter))) : both(fset []) (fset []) (t_TallyParameter).
Fail Next Obligation.

Equations tally_votes {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {A : _} {impl HasReceiveContext : _} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} `{ t_Sized (A)} `{ t_Sized (impl HasReceiveContext)} `{ t_HasActions (A)} `{ t_HasReceiveContext (impl HasReceiveContext) ('unit)} (_ : both L1 I1 (impl HasReceiveContext)) (state : both L2 I2 (t_OvnContractState)) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)) :=
  tally_votes _ state  :=
    Result_Ok (solve_lift (prod_b (accept,state))) : both (L1 :|: L2) (I1 :|: I2) (t_Result ((A × t_OvnContractState)) (t_ParseError)).
Fail Next Obligation.
Definition receive_OVN_tally (TallyParameter : _) (st : state_OVN) : choice_type :=
  tally_votes st.
