(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_lib.

Program Definition random_oracle_init {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 ('unit)) : both (L1) (I1) ('unit) :=
  ret_both (tt : 'unit).
Fail Next Obligation.

Definition t_G : choice_type :=
  (int32).
Equations Build_t_G {L : {fset Location}} {I : Interface} (f_v : both L I (int32)) : both L I (t_G) :=
  Build_t_G f_v  :=
    bind_both f_v (fun f_v =>
      ret_both ((f_v) : (t_G))) : both L I (t_G).
Fail Next Obligation.

Definition t_Q : choice_type :=
  (int32).
Equations Build_t_Q {L : {fset Location}} {I : Interface} (f_v : both L I (int32)) : both L I (t_Q) :=
  Build_t_Q f_v  :=
    bind_both f_v (fun f_v =>
      ret_both ((f_v) : (t_Q))) : both L I (t_Q).
Fail Next Obligation.

Notation t_Witness := (t_Q).

Notation t_Statement := (t_G).

Notation t_Message := (t_G).

Notation t_Challenge := (t_Q).

Notation t_Response := (t_Q).

Notation t_Random := ((t_G × t_G)).

Notation t_Query := (t_Q).

Program Definition sample_uniform : both (fset []) ([interface ]) ((t_G × t_G)) :=
  prod_b (Build_t_G i32(1),Build_t_G i32(1)).
Fail Next Obligation.

Require Import Std. (* as HashMap *)

Program Definition random_oracle_query {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (QUERIES : both L1 I1 (t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState))) (q : both L2 I2 (t_Q)) : both (L1:|:L2) (I1:|:I2) ((t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState) × (t_G × t_G))) :=
  match get_under_impl_2 QUERIES q with
  | Option_Some r => prod_b (clone QUERIES,clone r)
  | Option_None  => letb r := (sample_uniform) : both _ _ ((t_G × t_G)) in
    letb '(todo_fresh_var,QUERIES_temp) := (insert_under_impl_2 QUERIES q r) : both _ _ ((t_Option ((t_G × t_G)) × t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState))) in
    letb QUERIES := (QUERIES_temp) : both _ _ (t_HashMap (t_Q) ((t_G × t_G)) (t_RandomState)) in
    letb _ := (todo_fresh_var) : both _ _ (t_Option ((t_G × t_G))) in
    prod_b (QUERIES,r)
  end.
Fail Next Obligation.
