(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
   Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_ovn_Schnorr_Random_oracle_Hacspec_lib.
Export Hacspec_ovn_Schnorr_Random_oracle_Hacspec_lib.

Equations random_oracle_init {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 ('unit)) : both (L1) (I1) ('unit) :=
  random_oracle_init _  :=
    solve_lift (ret_both (tt : 'unit)) : both (L1) (I1) ('unit).
Fail Next Obligation.

Definition t_GCanvas : choice_type :=
  (nseq int8 48 × t_Sign × 'bool).
Equations Build_t_GCanvas {L : {fset Location}} {I : Interface} (f_b : both L I (nseq int8 48)) (f_sign : both L I (t_Sign)) (f_signed : both L I ('bool)) : both L I (t_GCanvas) :=
  Build_t_GCanvas f_b f_sign f_signed  :=
    bind_both f_signed (fun f_signed =>
      bind_both f_sign (fun f_sign =>
        bind_both f_b (fun f_b =>
          solve_lift (ret_both ((f_b,f_sign,f_signed) : (t_GCanvas)))))) : both L I (t_GCanvas).
Fail Next Obligation.

Equations max_under_impl_15 : both (fset []) ([interface ]) (t_Output) :=
  max_under_impl_15  :=
    solve_lift (((from (ret_both (1 : int32))) shift_left (ret_both (384 : int32))) .- one) : both (fset []) ([interface ]) (t_Output).
Fail Next Obligation.

Equations max_value_under_impl_15 : both (fset []) ([interface ]) (t_GCanvas) :=
  max_value_under_impl_15  :=
    solve_lift (from max_under_impl_15) : both (fset []) ([interface ]) (t_GCanvas).
Fail Next Obligation.

Definition x_loc : Location :=
  (t_String ; 1%nat).
Equations hex_string_to_bytes_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (chString)) : both (L1 :|: fset [x_loc]) (I1) (t_Vec (int8) (t_Global)) :=
  hex_string_to_bytes_under_impl_15 s  :=
    letb s := (ifb ((len_under_impl s) .% (ret_both (2 : uint_size))) <> (ret_both (0 : uint_size))
      then letbm x loc(x_loc) := (to_string (ret_both (0 : chString))) : both _ _ (t_String) in
        letb x := (push_str_under_impl x s) : both _ _ (t_String) in
        x
      else to_string s) : both _ _ (t_String) in
    letb _ := (ifb not (((len_under_impl s) .% (ret_both (2 : uint_size))) =.? (ret_both (0 : uint_size)))
      then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (length of hex string  : chString);
            ret_both (:  : chString)])) (unsize (array_from_list [new_display_under_impl_1 s;
            new_display_under_impl_1 (len_under_impl s)]))))) : both _ _ ('unit) in
        ret_both (tt : 'unit)
      else ret_both (tt : 'unit)) : both _ _ ('unit) in
    letb b := (collect (map (step_by (Build_t_Range (ret_both (0 : uint_size))(len_under_impl s)) (ret_both (2 : uint_size))) (fun i =>
        from_str_radix_under_impl_6 (s.a[(Build_t_Range i(i .+ (ret_both (2 : uint_size))))]) (ret_both (16 : int32))))) : both _ _ (t_Result (t_Vec (int8) (t_Global)) (t_ParseIntError)) in
    solve_lift (expect_under_impl b (ret_both (Error parsing hex string : chString))) : both (L1 :|: fset [x_loc]) (I1) (t_Vec (int8) (t_Global)).
Fail Next Obligation.

Equations from_literal_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_GCanvas) :=
  from_literal_under_impl_15 x  :=
    letb big_x := (from x) : both _ _ (t_BigInt) in
    letb _ := (ifb big_x >.? (into max_under_impl_15)
      then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (literal  : chString);
            ret_both ( too big for type GCanvas : chString)])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ ('unit) in
        ret_both (tt : 'unit)
      else ret_both (tt : 'unit)) : both _ _ ('unit) in
    solve_lift (into big_x) : both (L1) (I1) (t_GCanvas).
Fail Next Obligation.

Equations from_signed_literal_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1) (I1) (t_GCanvas) :=
  from_signed_literal_under_impl_15 x  :=
    letb big_x := (from (cast_int x)) : both _ _ (t_BigInt) in
    letb _ := (ifb big_x >.? (into max_under_impl_15)
      then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (literal  : chString);
            ret_both ( too big for type GCanvas : chString)])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ ('unit) in
        ret_both (tt : 'unit)
      else ret_both (tt : 'unit)) : both _ _ ('unit) in
    solve_lift (into big_x) : both (L1) (I1) (t_GCanvas).
Fail Next Obligation.

Equations pow2_under_impl_15 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_GCanvas) :=
  pow2_under_impl_15 x  :=
    solve_lift (into ((from (ret_both (1 : int32))) shift_left x)) : both (L1) (I1) (t_GCanvas).
Fail Next Obligation.

(*item error backend*)

#[global] Instance t_GCanvas_t_From : t_From t_GCanvas t_BigUint := {
  from (x : t_BigUint) := solve_lift (from (from x));
}.

#[global] Instance t_GCanvas_t_From : t_From t_GCanvas t_BigInt := {
  from (x : t_BigInt) := letb max_value := (max_under_impl_15) : both _ _ (t_BigInt) in
  letb _ := (ifb not (x <=.? max_value)
    then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both ( : chString);
          ret_both ( is too large for type GCanvas! : chString)])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  letb '(sign,repr) := (to_bytes_be_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
  letb _ := (ifb andb (sign =.? Sign_Minus) (not (ret_both (false : 'bool)))
    then letb _ := (never_to_any (begin_panic (ret_both (Trying to convert a negative number into an unsigned integer! : chString)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  letb _ := (ifb (len_under_impl_1 repr) >.? (((ret_both (384 : uint_size)) .+ (ret_both (7 : uint_size))) ./ (ret_both (8 : uint_size)))
    then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both ( : chString);
          ret_both ( is too large for type GCanvas : chString)])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  letbm out loc(out_loc) := (repeat (ret_both (0 : int8)) (ret_both (48 : uint_size))) : both _ _ (nseq int8 48) in
  letb upper := (len_under_impl (unsize out)) : both _ _ (uint_size) in
  letb lower := (upper .- (len_under_impl_1 repr)) : both _ _ (uint_size) in
  letb _ := (failure (ret_both (RefMut:The mutation of this &mut is not allowed here.
 : chString)) (ret_both (core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (out),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(repr)))))),
    ) : chString))) : both _ _ ('unit) in
  solve_lift (Build_t_GCanvas outsign(ret_both (false : 'bool)));
}.

#[global] Instance t_GCanvas_t_Default : t_Default t_GCanvas := {
  default := solve_lift (Build_t_GCanvas (repeat (ret_both (0 : int8)) (ret_both (48 : uint_size)))Sign_Plus(ret_both (false : 'bool)));
}.

#[global] Instance t_GCanvas_t_Into : t_Into t_GCanvas t_BigInt := {
  into (self : t_GCanvas) := solve_lift (from_bytes_be_under_impl_24 (f_sign self) (unsize (f_b self)));
}.

#[global] Instance t_GCanvas_t_Into : t_Into t_GCanvas t_BigUint := {
  into (self : t_GCanvas) := solve_lift (from_bytes_be_under_impl_18 (unsize (f_b self)));
}.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

Equations from_hex_under_impl_14 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (chString)) : both (L1 :|: fset [x_loc]) (I1) (t_GCanvas) :=
  from_hex_under_impl_14 s  :=
    solve_lift (into (from_bytes_be_under_impl_24 Sign_Plus (deref (hex_string_to_bytes_under_impl_15 s)))) : both (L1 :|: fset [x_loc]) (I1) (t_GCanvas).
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 48 ; 2%nat).
Equations from_be_bytes_under_impl_14 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  from_be_bytes_under_impl_14 v  :=
    letb _ := (ifb ret_both (true : 'bool)
      then letb _ := (ifb not ((len_under_impl v) <=.? (((ret_both (384 : uint_size)) .+ (ret_both (7 : uint_size))) ./ (ret_both (8 : uint_size))))
          then letb _ := (never_to_any (begin_panic (ret_both (from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas : chString)))) : both _ _ ('unit) in
            ret_both (tt : 'unit)
          else ret_both (tt : 'unit)) : both _ _ ('unit) in
        ret_both (tt : 'unit)
      else ret_both (tt : 'unit)) : both _ _ ('unit) in
    letbm repr loc(repr_loc) := (repeat (ret_both (0 : int8)) (ret_both (48 : uint_size))) : both _ _ (nseq int8 48) in
    letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
    letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
    letb _ := (failure (ret_both (RefMut:The mutation of this &mut is not allowed here.
 : chString)) (ret_both (core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    ) : chString))) : both _ _ ('unit) in
    solve_lift (Build_t_GCanvas reprSign_Plus(ret_both (false : 'bool))) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas).
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 48 ; 3%nat).
Equations from_le_bytes_under_impl_14 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  from_le_bytes_under_impl_14 v  :=
    letb _ := (ifb ret_both (true : 'bool)
      then letb _ := (ifb not ((len_under_impl v) <=.? (((ret_both (384 : uint_size)) .+ (ret_both (7 : uint_size))) ./ (ret_both (8 : uint_size))))
          then letb _ := (never_to_any (begin_panic (ret_both (from_be_bytes: lenght of bytes should be lesser than the lenght of the canvas : chString)))) : both _ _ ('unit) in
            ret_both (tt : 'unit)
          else ret_both (tt : 'unit)) : both _ _ ('unit) in
        ret_both (tt : 'unit)
      else ret_both (tt : 'unit)) : both _ _ ('unit) in
    letbm repr loc(repr_loc) := (repeat (ret_both (0 : int8)) (ret_both (48 : uint_size))) : both _ _ (nseq int8 48) in
    letb upper := (len_under_impl (unsize repr)) : both _ _ (uint_size) in
    letb lower := (upper .- (len_under_impl v)) : both _ _ (uint_size) in
    letb _ := (failure (ret_both (RefMut:The mutation of this &mut is not allowed here.
 : chString)) (ret_both (core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: lower,
                f_end: upper,
            },
        ))),
        &(deref(deref(&(v)))),
    ) : chString))) : both _ _ ('unit) in
    solve_lift (into (from_bytes_le_under_impl_24 Sign_Plus (unsize repr))) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas).
Fail Next Obligation.

Equations to_be_bytes_under_impl_14 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_GCanvas)) : both (L1) (I1) (nseq int8 48) :=
  to_be_bytes_under_impl_14 self  :=
    solve_lift (f_b self) : both (L1) (I1) (nseq int8 48).
Fail Next Obligation.

Definition repr_loc : Location :=
  (nseq int8 48 ; 4%nat).
Equations to_le_bytes_under_impl_14 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_GCanvas)) : both (L1 :|: fset [repr_loc]) (I1) (nseq int8 48) :=
  to_le_bytes_under_impl_14 self  :=
    letb x := (from_bytes_be_under_impl_24 Sign_Plus (unsize (f_b self))) : both _ _ (t_BigInt) in
    letb '(_,x_s) := (to_bytes_le_under_impl_24 x) : both _ _ ((t_Sign × t_Vec (int8) (t_Global))) in
    letbm repr loc(repr_loc) := (repeat (ret_both (0 : int8)) (ret_both (48 : uint_size))) : both _ _ (nseq int8 48) in
    letb _ := (failure (ret_both (RefMut:The mutation of this &mut is not allowed here.
 : chString)) (ret_both (core::slice::copy_from_slice_under_impl(
        &mut (deref(core::ops::index::IndexMut::index_mut(
            &mut (repr),
            core::ops::range::Range {
                f_start: 0,
                f_end: alloc::vec::len_under_impl_1(&(x_s)),
            },
        ))),
        &(deref(core::ops::deref::Deref::deref(&(deref(&(x_s)))))),
    ) : chString))) : both _ _ ('unit) in
    repr : both (L1 :|: fset [repr_loc]) (I1) (nseq int8 48).
Fail Next Obligation.

Equations comp_eq_under_impl_14 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  comp_eq_under_impl_14 self rhs  :=
    letb a := (into self) : both _ _ (t_BigInt) in
    letb b := (into rhs) : both _ _ (t_BigInt) in
    ifb solve_lift (a =.? b)
    then letb one := (from_literal_under_impl_15 (ret_both (1 : int128))) : both _ _ (t_GCanvas) in
      solve_lift ((one shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- one)
    else solve_lift default : both (L1:|:L2) (I1:|:I2) (t_Output).
Fail Next Obligation.

Equations comp_ne_under_impl_14 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  comp_ne_under_impl_14 self rhs  :=
    letb a := (into self) : both _ _ (t_BigInt) in
    letb b := (into rhs) : both _ _ (t_BigInt) in
    ifb solve_lift (a <> b)
    then letb one := (from_literal_under_impl_15 (ret_both (1 : int128))) : both _ _ (t_GCanvas) in
      solve_lift ((one shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- one)
    else solve_lift default : both (L1:|:L2) (I1:|:I2) (t_Output).
Fail Next Obligation.

Equations comp_gte_under_impl_14 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  comp_gte_under_impl_14 self rhs  :=
    letb a := (into self) : both _ _ (t_BigInt) in
    letb b := (into rhs) : both _ _ (t_BigInt) in
    ifb solve_lift (a >=.? b)
    then letb one := (from_literal_under_impl_15 (ret_both (1 : int128))) : both _ _ (t_GCanvas) in
      solve_lift ((one shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- one)
    else solve_lift default : both (L1:|:L2) (I1:|:I2) (t_Output).
Fail Next Obligation.

Equations comp_gt_under_impl_14 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  comp_gt_under_impl_14 self rhs  :=
    letb a := (into self) : both _ _ (t_BigInt) in
    letb b := (into rhs) : both _ _ (t_BigInt) in
    ifb solve_lift (a >.? b)
    then letb one := (from_literal_under_impl_15 (ret_both (1 : int128))) : both _ _ (t_GCanvas) in
      solve_lift ((one shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- one)
    else solve_lift default : both (L1:|:L2) (I1:|:I2) (t_Output).
Fail Next Obligation.

Equations comp_lte_under_impl_14 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  comp_lte_under_impl_14 self rhs  :=
    letb a := (into self) : both _ _ (t_BigInt) in
    letb b := (into rhs) : both _ _ (t_BigInt) in
    ifb solve_lift (a <=.? b)
    then letb one := (from_literal_under_impl_15 (ret_both (1 : int128))) : both _ _ (t_GCanvas) in
      solve_lift ((one shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- one)
    else solve_lift default : both (L1:|:L2) (I1:|:I2) (t_Output).
Fail Next Obligation.

Equations comp_lt_under_impl_14 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (rhs : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  comp_lt_under_impl_14 self rhs  :=
    letb a := (into self) : both _ _ (t_BigInt) in
    letb b := (into rhs) : both _ _ (t_BigInt) in
    ifb solve_lift (a <.? b)
    then letb one := (from_literal_under_impl_15 (ret_both (1 : int128))) : both _ _ (t_GCanvas) in
      solve_lift ((one shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- one)
    else solve_lift default : both (L1:|:L2) (I1:|:I2) (t_Output).
Fail Next Obligation.

Equations inv_under_impl_26 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (modval : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_GCanvas) :=
  inv_under_impl_26 self modval  :=
    letb biguintmodval := (into modval) : both _ _ (t_BigInt) in
    letb m := (biguintmodval .- (from (ret_both (2 : int32)))) : both _ _ (t_Output) in
    letb s := (into self) : both _ _ (t_BigInt) in
    solve_lift (into (modpow_under_impl_24 s m biguintmodval)) : both (L1:|:L2) (I1:|:I2) (t_GCanvas).
Fail Next Obligation.

Equations pow_felem_under_impl_26 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_GCanvas)) (exp : both L2 I2 (t_GCanvas)) (modval : both L3 I3 (t_GCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_GCanvas) :=
  pow_felem_under_impl_26 self exp modval  :=
    letb a := (into self) : both _ _ (t_BigInt) in
    letb b := (into exp) : both _ _ (t_BigInt) in
    letb m := (into modval) : both _ _ (t_BigInt) in
    letb c := (modpow_under_impl_24 a b m) : both _ _ (t_BigInt) in
    solve_lift (into c) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_GCanvas).
Fail Next Obligation.

Equations pow_under_impl_26 {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (self : both L1 I1 (t_GCanvas)) (exp : both L2 I2 (int128)) (modval : both L3 I3 (t_GCanvas)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_GCanvas) :=
  pow_under_impl_26 self exp modval  :=
    solve_lift (pow_felem_under_impl_26 self (into (from exp)) modval) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) (t_GCanvas).
Fail Next Obligation.

Equations rem_under_impl_26 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_GCanvas)) (n : both L2 I2 (t_GCanvas)) : both (L1:|:L2) (I1:|:I2) (t_Output) :=
  rem_under_impl_26 self n  :=
    solve_lift (self .% n) : both (L1:|:L2) (I1:|:I2) (t_Output).
Fail Next Obligation.

#[global] Instance t_GCanvas_t_Add : t_Add t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  add (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_15
    then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (bounded addition overflow for type GCanvas : chString)])) (unsize none_under_impl_1)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  solve_lift (into c);
}.

#[global] Instance t_GCanvas_t_Sub : t_Sub t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  sub (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (ifb f_signed self
    then a .- b
    else unwrap_or_else_under_impl (checked_sub_under_impl_24 a b) (
        never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (bounded substraction underflow for type GCanvas : chString)])) (unsize none_under_impl_1))))) : both _ _ (t_Output) in
  solve_lift (into c);
}.

#[global] Instance t_GCanvas_t_Mul : t_Mul t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  mul (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb _ := (ifb c >.? max_under_impl_15
    then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (bounded multiplication overflow for type GCanvas : chString)])) (unsize none_under_impl_1)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  solve_lift (into c);
}.

#[global] Instance t_GCanvas_t_Div : t_Div t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  div (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (dividing by zero in type GCanvas : chString)])) (unsize none_under_impl_1)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  letb c := (a ./ b) : both _ _ (t_Output) in
  solve_lift (into c);
}.

#[global] Instance t_GCanvas_t_Rem : t_Rem t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  rem (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  letb _ := (ifb b =.? zero
    then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (dividing by zero in type GCanvas : chString)])) (unsize none_under_impl_1)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  letb c := (a .% b) : both _ _ (t_Output) in
  solve_lift (into c);
}.

#[global] Instance t_GCanvas_t_Not : t_Not t_GCanvas := {
  t_Output := t_GCanvas;
  not (self : t_GCanvas) := solve_lift (never_to_any (panic (ret_both (not implemented : chString))));
}.

#[global] Instance t_GCanvas_t_BitOr : t_BitOr t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  bitor (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  solve_lift (into (a .| b));
}.

#[global] Instance t_GCanvas_t_BitXor : t_BitXor t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  bitxor (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  solve_lift (into (a .^ b));
}.

#[global] Instance t_GCanvas_t_BitAnd : t_BitAnd t_GCanvas t_GCanvas := {
  t_Output := t_GCanvas;
  bitand (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  solve_lift (into (a .& b));
}.

#[global] Instance t_GCanvas_t_Shr : t_Shr t_GCanvas uint_size := {
  t_Output := t_GCanvas;
  shr (self : t_GCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  solve_lift (into (a shift_right b));
}.

#[global] Instance t_GCanvas_t_Shl : t_Shl t_GCanvas uint_size := {
  t_Output := t_GCanvas;
  shl (self : t_GCanvas) (rhs : uint_size) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (rhs) : both _ _ (uint_size) in
  solve_lift (into (a shift_left b));
}.

#[global] Instance t_GCanvas_t_PartialEq : t_PartialEq t_GCanvas t_GCanvas := {
  eq (self : t_GCanvas) (rhs : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into rhs) : both _ _ (t_BigInt) in
  solve_lift (a =.? b);
}.

#[global] Instance t_GCanvas_t_Eq : t_Eq t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_PartialOrd : t_PartialOrd t_GCanvas t_GCanvas := {
  partial_cmp (self : t_GCanvas) (other : t_GCanvas) := letb a := (into self) : both _ _ (t_BigInt) in
  letb b := (into other) : both _ _ (t_BigInt) in
  solve_lift (partial_cmp a b);
}.

#[global] Instance t_GCanvas_t_Ord : t_Ord t_GCanvas := {
  cmp (self : t_GCanvas) (other : t_GCanvas) := solve_lift (unwrap_under_impl (partial_cmp self other));
}.

Equations from_byte_seq_be_under_impl_7 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  from_byte_seq_be_under_impl_7 s  :=
    solve_lift (from_be_bytes_under_impl_14 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
      declassify_under_impl_2 x))))) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas).
Fail Next Obligation.

Equations from_public_byte_seq_be_under_impl_7 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas) :=
  from_public_byte_seq_be_under_impl_7 s  :=
    solve_lift (from_be_bytes_under_impl_14 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
      x))))) : both (L1 :|: fset [repr_loc]) (I1) (t_GCanvas).
Fail Next Obligation.

Equations to_byte_seq_be_under_impl_7 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_GCanvas)) : both (L1) (I1) (t_Seq (t_U8)) :=
  to_byte_seq_be_under_impl_7 self  :=
    solve_lift (from_vec_under_impl_52 (collect (map (iter_under_impl (unsize (to_be_bytes_under_impl_14 self))) (fun x =>
      classify_under_impl_2 x)))) : both (L1) (I1) (t_Seq (t_U8)).
Fail Next Obligation.

#[global] Instance t_GCanvas_t_NumericCopy : t_NumericCopy t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_UnsignedInteger : t_UnsignedInteger t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_GCanvas := {
}.

#[global] Instance t_GCanvas_t_Integer : t_Integer t_GCanvas := {
  NUM_BITS := solve_lift (ret_both (384 : uint_size));
  ZERO := solve_lift (from_literal_under_impl_15 (ret_both (0 : int128)));
  ONE := solve_lift (from_literal_under_impl_15 (ret_both (1 : int128)));
  TWO := solve_lift (from_literal_under_impl_15 (ret_both (2 : int128)));
  from_literal (val : int128) := solve_lift (from_literal_under_impl_15 val);
  from_hex_string (s : t_String) := solve_lift (from_hex_under_impl_14 (deref (replace_under_impl_5 (deref s) (ret_both (0x : chString)) (ret_both ( : chString)))));
  get_bit (self : t_GCanvas) (i : uint_size) := solve_lift ((self shift_right i) .& v_ONE);
  set_bit (self : t_GCanvas) (b : t_GCanvas) (i : uint_size) := letb _ := (ifb ret_both (true : 'bool)
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb _ := (never_to_any (panic (ret_both (assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()) : chString)))) : both _ _ ('unit) in
          ret_both (tt : 'unit)
        else ret_both (tt : 'unit)) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  letb tmp1 := (from_literal_under_impl_15 (not ((ret_both (1 : int128)) shift_left i))) : both _ _ (t_GCanvas) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  solve_lift ((self .& tmp1) .| tmp2);
  set (self : t_GCanvas) (pos : uint_size) (y : t_GCanvas) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_GCanvas) in
  solve_lift (set_bit self b pos);
  rotate_left (self : t_GCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb _ := (never_to_any (panic (ret_both (assertion failed: n < Self::NUM_BITS : chString)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  solve_lift (((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- (ret_both (1 : uint_size))))));
  rotate_right (self : t_GCanvas) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb _ := (never_to_any (panic (ret_both (assertion failed: n < Self::NUM_BITS : chString)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  solve_lift (((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- (ret_both (1 : uint_size))))));
}.

#[global] Instance t_GCanvas_t_ModNumeric : t_ModNumeric t_GCanvas := {
  sub_mod (self : t_GCanvas) (rhs : t_GCanvas) (n : t_GCanvas) := solve_lift ((self .- rhs) .% n);
  add_mod (self : t_GCanvas) (rhs : t_GCanvas) (n : t_GCanvas) := solve_lift ((self .+ rhs) .% n);
  mul_mod (self : t_GCanvas) (rhs : t_GCanvas) (n : t_GCanvas) := solve_lift ((self .* rhs) .% n);
  pow_mod (self : t_GCanvas) (exp : t_GCanvas) (n : t_GCanvas) := solve_lift (pow_felem_under_impl_26 self exp n);
  modulo (self : t_GCanvas) (n : t_GCanvas) := solve_lift (self .% n);
  signed_modulo (self : t_GCanvas) (n : t_GCanvas) := solve_lift (modulo self n);
  absolute (self : t_GCanvas) := self;
}.

#[global] Instance t_GCanvas_t_Numeric : t_Numeric t_GCanvas := {
  max_val := solve_lift max_value_under_impl_15;
  wrap_add (self : t_GCanvas) (rhs : t_GCanvas) := solve_lift (self .+ rhs);
  wrap_sub (self : t_GCanvas) (rhs : t_GCanvas) := solve_lift (self .- rhs);
  wrap_mul (self : t_GCanvas) (rhs : t_GCanvas) := solve_lift (self .* rhs);
  wrap_div (self : t_GCanvas) (rhs : t_GCanvas) := solve_lift (self ./ rhs);
  exp (self : t_GCanvas) (exp : int32) := solve_lift (pow_under_impl_26 self (into exp) max_val);
  pow_self (self : t_GCanvas) (exp : t_GCanvas) := solve_lift (pow_felem_under_impl_26 self (into exp) max_val);
  divide (self : t_GCanvas) (rhs : t_GCanvas) := solve_lift (self ./ rhs);
  inv (self : t_GCanvas) (n : t_GCanvas) := solve_lift (inv_under_impl_26 self n);
  equal (self : t_GCanvas) (other : t_GCanvas) := solve_lift (self =.? other);
  greater_than (self : t_GCanvas) (other : t_GCanvas) := solve_lift (self >.? other);
  greater_than_or_equal (self : t_GCanvas) (other : t_GCanvas) := solve_lift (self >=.? other);
  less_than (self : t_GCanvas) (other : t_GCanvas) := solve_lift (self <.? other);
  less_than_or_equal (self : t_GCanvas) (other : t_GCanvas) := solve_lift (self >=.? other);
  not_equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb solve_lift (not (equal self other))
  then solve_lift max_val
  else solve_lift (from_literal_under_impl_15 (ret_both (0 : int128)));
  equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb solve_lift (equal self other)
  then solve_lift max_val
  else solve_lift (from_literal_under_impl_15 (ret_both (0 : int128)));
  greater_than_bm (self : t_GCanvas) (other : t_GCanvas) := ifb solve_lift (greater_than self other)
  then solve_lift max_val
  else solve_lift (from_literal_under_impl_15 (ret_both (0 : int128)));
  greater_than_or_equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb solve_lift (greater_than_or_equal self other)
  then solve_lift max_val
  else solve_lift (from_literal_under_impl_15 (ret_both (0 : int128)));
  less_than_bm (self : t_GCanvas) (other : t_GCanvas) := ifb solve_lift (less_than self other)
  then solve_lift max_val
  else solve_lift (from_literal_under_impl_15 (ret_both (0 : int128)));
  less_than_or_equal_bm (self : t_GCanvas) (other : t_GCanvas) := ifb solve_lift (less_than_or_equal self other)
  then solve_lift max_val
  else solve_lift (from_literal_under_impl_15 (ret_both (0 : int128)));
}.

Definition t_G : choice_type :=
  (t_GCanvas).
Equations Build_t_G {L : {fset Location}} {I : Interface} (0 : both L I (t_GCanvas)) : both L I (t_G) :=
  Build_t_G 0  :=
    bind_both 0 (fun 0 =>
      solve_lift (ret_both ((0) : (t_G)))) : both L I (t_G).
Fail Next Obligation.

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

(*RefMut:The mutation of this &mut is not allowed here.

Last available AST for this item:

/* TO DO */
 todo(item)*)

#[global] Instance t_G_t_From : t_From t_G t_GCanvas := {
  from (x : t_GCanvas) := G (solve_lift (rem_under_impl_26 x (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString)))));
}.

#[global] Instance t_G_t_Into : t_Into t_G t_GCanvas := {
  into (self : t_G) := solve_lift (0 self);
}.

Equations from_canvas_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_GCanvas)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  from_canvas_under_impl_63 x  :=
    G (solve_lift (rem_under_impl_26 x (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString))))) : both (L1 :|: fset [x_loc]) (I1) (t_G).
Fail Next Obligation.

Equations into_canvas_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_GCanvas) :=
  into_canvas_under_impl_63 self  :=
    solve_lift (0 self) : both (L1) (I1) (t_GCanvas).
Fail Next Obligation.

Equations max_under_impl_63 : both (fset [x_loc]) ([interface ]) (t_GCanvas) :=
  max_under_impl_63  :=
    solve_lift (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString))) : both (fset [x_loc]) ([interface ]) (t_GCanvas).
Fail Next Obligation.

Equations declassify_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_BigInt) :=
  declassify_under_impl_63 self  :=
    letb a := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into a) : both (L1) (I1) (t_BigInt).
Fail Next Obligation.

Equations from_hex_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (chString)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  from_hex_under_impl_63 s  :=
    solve_lift (into (from_hex_under_impl_14 s)) : both (L1 :|: fset [x_loc]) (I1) (t_G).
Fail Next Obligation.

Equations from_be_bytes_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  from_be_bytes_under_impl_63 v  :=
    solve_lift (into (from_be_bytes_under_impl_14 v)) : both (L1 :|: fset [repr_loc]) (I1) (t_G).
Fail Next Obligation.

Equations to_be_bytes_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_Vec (int8) (t_Global)) :=
  to_be_bytes_under_impl_63 self  :=
    solve_lift (to_vec_under_impl (unsize (to_be_bytes_under_impl_14 (into self)))) : both (L1) (I1) (t_Vec (int8) (t_Global)).
Fail Next Obligation.

Equations from_le_bytes_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (v : both L1 I1 (seq int8)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  from_le_bytes_under_impl_63 v  :=
    solve_lift (into (from_le_bytes_under_impl_14 v)) : both (L1 :|: fset [repr_loc]) (I1) (t_G).
Fail Next Obligation.

Equations to_le_bytes_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [repr_loc]) (I1) (t_Vec (int8) (t_Global)) :=
  to_le_bytes_under_impl_63 self  :=
    solve_lift (to_vec_under_impl (unsize (to_le_bytes_under_impl_14 (into self)))) : both (L1 :|: fset [repr_loc]) (I1) (t_Vec (int8) (t_Global)).
Fail Next Obligation.

Equations bit_under_impl_63 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (i : both L2 I2 (uint_size)) : both (L1:|:L2) (I1:|:I2) ('bool) :=
  bit_under_impl_63 self i  :=
    solve_lift (bit_under_impl_15 (into self) i) : both (L1:|:L2) (I1:|:I2) ('bool).
Fail Next Obligation.

Equations from_literal_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  from_literal_under_impl_63 x  :=
    letb big_x := (from x) : both _ _ (t_BigUint) in
    letb _ := (ifb big_x >.? (into max_under_impl_63)
      then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (literal  : chString);
            ret_both ( too big for type G : chString)])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ ('unit) in
        ret_both (tt : 'unit)
      else ret_both (tt : 'unit)) : both _ _ ('unit) in
    G (solve_lift (into big_x)) : both (L1 :|: fset [x_loc]) (I1) (t_G).
Fail Next Obligation.

Equations from_signed_literal_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (int128)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  from_signed_literal_under_impl_63 x  :=
    letb big_x := (from (cast_int x)) : both _ _ (t_BigUint) in
    letb _ := (ifb big_x >.? (into max_under_impl_63)
      then letb _ := (never_to_any (panic_fmt (new_v1_under_impl_2 (unsize (array_from_list [ret_both (literal  : chString);
            ret_both ( too big for type G : chString)])) (unsize (array_from_list [new_display_under_impl_1 x]))))) : both _ _ ('unit) in
        ret_both (tt : 'unit)
      else ret_both (tt : 'unit)) : both _ _ ('unit) in
    G (solve_lift (into big_x)) : both (L1 :|: fset [x_loc]) (I1) (t_G).
Fail Next Obligation.

Equations comp_eq_under_impl_63 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  comp_eq_under_impl_63 self rhs  :=
    letb x := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (comp_eq_under_impl_14 x (into rhs))) : both (L1:|:L2) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations comp_ne_under_impl_63 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  comp_ne_under_impl_63 self rhs  :=
    letb x := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (comp_ne_under_impl_14 x (into rhs))) : both (L1:|:L2) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations comp_gte_under_impl_63 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  comp_gte_under_impl_63 self rhs  :=
    letb x := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (comp_gte_under_impl_14 x (into rhs))) : both (L1:|:L2) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations comp_gt_under_impl_63 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  comp_gt_under_impl_63 self rhs  :=
    letb x := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (comp_gt_under_impl_14 x (into rhs))) : both (L1:|:L2) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations comp_lte_under_impl_63 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  comp_lte_under_impl_63 self rhs  :=
    letb x := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (comp_lte_under_impl_14 x (into rhs))) : both (L1:|:L2) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations comp_lt_under_impl_63 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (rhs : both L2 I2 (t_G)) : both (L1:|:L2) (I1:|:I2) (t_G) :=
  comp_lt_under_impl_63 self rhs  :=
    letb x := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (comp_lt_under_impl_14 x (into rhs))) : both (L1:|:L2) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations neg_under_impl_63 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  neg_under_impl_63 self  :=
    letb mod_val := (into (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString)))) : both _ _ (t_BigInt) in
    letb s := (into self) : both _ _ (t_GCanvas) in
    letb s := (into s) : both _ _ (t_BigInt) in
    letb result := (into (mod_val .- s)) : both _ _ (t_GCanvas) in
    solve_lift (into result) : both (L1 :|: fset [x_loc]) (I1) (t_G).
Fail Next Obligation.

#[global] Instance t_G_t_PartialOrd : t_PartialOrd t_G t_G := {
  partial_cmp (self : t_G) (other : t_G) := Option_Some (solve_lift (cmp self other));
}.

#[global] Instance t_G_t_Ord : t_Ord t_G := {
  cmp (self : t_G) (other : t_G) := solve_lift (cmp (0 self) (0 other));
}.

#[global] Instance t_G_t_PartialEq : t_PartialEq t_G t_G := {
  eq (self : t_G) (other : t_G) := solve_lift ((0 self) =.? (0 other));
}.

#[global] Instance t_G_t_Eq : t_Eq t_G := {
}.

#[global] Instance t_G_t_Add : t_Add t_G t_G := {
  t_Output := t_G;
  add (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .+ b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString)))) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  solve_lift (into d);
}.

#[global] Instance t_G_t_Sub : t_Sub t_G t_G := {
  t_Output := t_G;
  sub (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb max := (into (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString)))) : both _ _ (t_BigUint) in
  letb c := (ifb b >.? a
    then ((clone max) .- b) .+ a
    else a .- b) : both _ _ (t_Output) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  solve_lift (into d);
}.

#[global] Instance t_G_t_Mul : t_Mul t_G t_G := {
  t_Output := t_G;
  mul (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .* b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString)))) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  solve_lift (into d);
}.

#[global] Instance t_G_t_Div : t_Div t_G t_G := {
  t_Output := t_G;
  div (self : t_G) (rhs : t_G) := solve_lift (self .* (inv_under_impl_57 rhs));
}.

#[global] Instance t_G_t_Rem : t_Rem t_G t_G := {
  t_Output := t_G;
  rem (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  letb a := (into a) : both _ _ (t_BigUint) in
  letb b := (into b) : both _ _ (t_BigUint) in
  letb c := (a .% b) : both _ _ (t_Output) in
  letb max := (into (from_hex_under_impl_14 (ret_both (1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab : chString)))) : both _ _ (t_BigUint) in
  letb d := (c .% max) : both _ _ (t_Output) in
  letb d := (into d) : both _ _ (t_GCanvas) in
  solve_lift (into d);
}.

#[global] Instance t_G_t_Not : t_Not t_G := {
  t_Output := t_G;
  not (self : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  solve_lift (into (not a));
}.

#[global] Instance t_G_t_BitOr : t_BitOr t_G t_G := {
  t_Output := t_G;
  bitor (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  solve_lift (into (a .| b));
}.

#[global] Instance t_G_t_BitXor : t_BitXor t_G t_G := {
  t_Output := t_G;
  bitxor (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  solve_lift (into (a .^ b));
}.

#[global] Instance t_G_t_BitAnd : t_BitAnd t_G t_G := {
  t_Output := t_G;
  bitand (self : t_G) (rhs : t_G) := letb a := (into self) : both _ _ (t_GCanvas) in
  letb b := (into rhs) : both _ _ (t_GCanvas) in
  solve_lift (into (a .& b));
}.

#[global] Instance t_G_t_Shr : t_Shr t_G uint_size := {
  t_Output := t_G;
  shr (self : t_G) (rhs : uint_size) := letb a := (into self) : both _ _ (t_GCanvas) in
  solve_lift (into (a shift_right rhs));
}.

#[global] Instance t_G_t_Shl : t_Shl t_G uint_size := {
  t_Output := t_G;
  shl (self : t_G) (rhs : uint_size) := letb a := (into self) : both _ _ (t_GCanvas) in
  solve_lift (into (a shift_left rhs));
}.

Equations inv_under_impl_57 {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [x_loc]) (I1) (t_G) :=
  inv_under_impl_57 self  :=
    letb base := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (inv_under_impl_26 base max_under_impl_63)) : both (L1 :|: fset [x_loc]) (I1) (t_G).
Fail Next Obligation.

Equations pow_felem_under_impl_57 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (exp : both L2 I2 (t_G)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_G) :=
  pow_felem_under_impl_57 self exp  :=
    letb base := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (pow_felem_under_impl_26 base (into exp) max_under_impl_63)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations pow_under_impl_57 {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (self : both L1 I1 (t_G)) (exp : both L2 I2 (int128)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_G) :=
  pow_under_impl_57 self exp  :=
    letb base := (into self) : both _ _ (t_GCanvas) in
    solve_lift (into (pow_under_impl_26 base exp max_under_impl_63)) : both (L1:|:L2 :|: fset [x_loc]) (I1:|:I2) (t_G).
Fail Next Obligation.

Equations pow2_under_impl_57 {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (uint_size)) : both (L1) (I1) (t_G) :=
  pow2_under_impl_57 x  :=
    solve_lift (into (pow2_under_impl_15 x)) : both (L1) (I1) (t_G).
Fail Next Obligation.

Equations from_byte_seq_be_under_impl {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  from_byte_seq_be_under_impl s  :=
    solve_lift (into (from_be_bytes_under_impl_14 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
      declassify_under_impl_2 x)))))) : both (L1 :|: fset [repr_loc]) (I1) (t_G).
Fail Next Obligation.

Equations from_public_byte_seq_be_under_impl {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  from_public_byte_seq_be_under_impl s  :=
    solve_lift (into (from_be_bytes_under_impl_14 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
      x)))))) : both (L1 :|: fset [repr_loc]) (I1) (t_G).
Fail Next Obligation.

Equations to_byte_seq_be_under_impl {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_Seq (t_U8)) :=
  to_byte_seq_be_under_impl self  :=
    solve_lift (from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_be_bytes_under_impl_63 self))) (fun x =>
      classify_under_impl_2 x)))) : both (L1) (I1) (t_Seq (t_U8)).
Fail Next Obligation.

Equations to_public_byte_seq_be_under_impl {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1) (I1) (t_Seq (int8)) :=
  to_public_byte_seq_be_under_impl self  :=
    solve_lift (from_vec_under_impl_52 (to_be_bytes_under_impl_63 self)) : both (L1) (I1) (t_Seq (int8)).
Fail Next Obligation.

Equations from_byte_seq_le_under_impl {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  from_byte_seq_le_under_impl s  :=
    solve_lift (into (from_le_bytes_under_impl_14 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
      declassify_under_impl_2 x)))))) : both (L1 :|: fset [repr_loc]) (I1) (t_G).
Fail Next Obligation.

Equations from_public_byte_seq_le_under_impl {L1 : {fset Location}} {I1 : Interface} (s : both L1 I1 (A)) : both (L1 :|: fset [repr_loc]) (I1) (t_G) :=
  from_public_byte_seq_le_under_impl s  :=
    solve_lift (into (from_le_bytes_under_impl_14 (as_slice_under_impl_1 (collect (map (iter s) (fun x =>
      x)))))) : both (L1 :|: fset [repr_loc]) (I1) (t_G).
Fail Next Obligation.

Equations to_byte_seq_le_under_impl {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (t_U8)) :=
  to_byte_seq_le_under_impl self  :=
    solve_lift (from_vec_under_impl_52 (collect (map (iter_under_impl (deref (to_le_bytes_under_impl_63 self))) (fun x =>
      classify_under_impl_2 x)))) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (t_U8)).
Fail Next Obligation.

Equations to_public_byte_seq_le_under_impl {L1 : {fset Location}} {I1 : Interface} (self : both L1 I1 (t_G)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (int8)) :=
  to_public_byte_seq_le_under_impl self  :=
    solve_lift (from_vec_under_impl_52 (to_le_bytes_under_impl_63 self)) : both (L1 :|: fset [repr_loc]) (I1) (t_Seq (int8)).
Fail Next Obligation.

Equations from_secret_literal_under_impl {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 (t_U128)) : both (L1) (I1) (t_G) :=
  from_secret_literal_under_impl x  :=
    solve_lift (into (from_literal_under_impl_15 (declassify_under_impl_126 x))) : both (L1) (I1) (t_G).
Fail Next Obligation.

#[global] Instance t_G_t_NumericCopy : t_NumericCopy t_G := {
}.

#[global] Instance t_G_t_UnsignedInteger : t_UnsignedInteger t_G := {
}.

#[global] Instance t_G_t_UnsignedIntegerCopy : t_UnsignedIntegerCopy t_G := {
}.

#[global] Instance t_G_t_Integer : t_Integer t_G := {
  NUM_BITS := solve_lift (ret_both (384 : uint_size));
  ZERO := solve_lift (from_literal_under_impl_63 (ret_both (0 : int128)));
  ONE := solve_lift (from_literal_under_impl_63 (ret_both (1 : int128)));
  TWO := solve_lift (from_literal_under_impl_63 (ret_both (2 : int128)));
  from_literal (val : int128) := solve_lift (from_literal_under_impl_63 val);
  from_hex_string (s : t_String) := solve_lift (from_hex_under_impl_63 (deref (replace_under_impl_5 (deref s) (ret_both (0x : chString)) (ret_both ( : chString)))));
  get_bit (self : t_G) (i : uint_size) := solve_lift ((self shift_right i) .& v_ONE);
  set_bit (self : t_G) (b : t_G) (i : uint_size) := letb _ := (ifb ret_both (true : 'bool)
    then letb _ := (ifb not (orb (equal (clone b) v_ONE) (equal (clone b) v_ZERO))
        then letb _ := (never_to_any (panic (ret_both (assertion failed: b.clone().equal(Self::ONE()) || b.clone().equal(Self::ZERO()) : chString)))) : both _ _ ('unit) in
          ret_both (tt : 'unit)
        else ret_both (tt : 'unit)) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  letb tmp1 := (from_literal_under_impl_63 (not ((ret_both (1 : int128)) shift_left i))) : both _ _ (t_G) in
  letb tmp2 := (b shift_left i) : both _ _ (t_Output) in
  solve_lift ((self .& tmp1) .| tmp2);
  set (self : t_G) (pos : uint_size) (y : t_G) (yi : uint_size) := letb b := (get_bit y yi) : both _ _ (t_G) in
  solve_lift (set_bit self b pos);
  rotate_left (self : t_G) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb _ := (never_to_any (panic (ret_both (assertion failed: n < Self::NUM_BITS : chString)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  solve_lift (((clone self) shift_left n) .| (self shift_right ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- (ret_both (1 : uint_size))))));
  rotate_right (self : t_G) (n : uint_size) := letb _ := (ifb not (n <.? v_NUM_BITS)
    then letb _ := (never_to_any (panic (ret_both (assertion failed: n < Self::NUM_BITS : chString)))) : both _ _ ('unit) in
      ret_both (tt : 'unit)
    else ret_both (tt : 'unit)) : both _ _ ('unit) in
  solve_lift (((clone self) shift_right n) .| (self shift_left ((cast_int (neg (cast_int n))) .& (v_NUM_BITS .- (ret_both (1 : uint_size))))));
}.

#[global] Instance t_G_t_ModNumeric : t_ModNumeric t_G := {
  sub_mod (self : t_G) (rhs : t_G) (n : t_G) := solve_lift (self .- rhs);
  add_mod (self : t_G) (rhs : t_G) (n : t_G) := solve_lift (self .+ rhs);
  mul_mod (self : t_G) (rhs : t_G) (n : t_G) := solve_lift (self .* rhs);
  pow_mod (self : t_G) (exp : t_G) (n : t_G) := solve_lift (pow_felem_under_impl_57 self exp);
  modulo (self : t_G) (n : t_G) := solve_lift (self .% n);
  signed_modulo (self : t_G) (n : t_G) := solve_lift (modulo self n);
  absolute (self : t_G) := self;
}.

#[global] Instance t_G_t_Numeric : t_Numeric t_G := {
  max_val := solve_lift (into (max_under_impl_63 .- (from_literal_under_impl_15 (ret_both (1 : int128)))));
  wrap_add (self : t_G) (rhs : t_G) := solve_lift (self .+ rhs);
  wrap_sub (self : t_G) (rhs : t_G) := solve_lift (self .- rhs);
  wrap_mul (self : t_G) (rhs : t_G) := solve_lift (self .* rhs);
  wrap_div (self : t_G) (rhs : t_G) := solve_lift (self ./ rhs);
  exp (self : t_G) (exp : int32) := solve_lift (pow_under_impl_57 self (into exp));
  pow_self (self : t_G) (exp : t_G) := solve_lift (pow_felem_under_impl_57 self exp);
  divide (self : t_G) (rhs : t_G) := solve_lift (self ./ rhs);
  inv (self : t_G) (n : t_G) := solve_lift (inv_under_impl_57 self);
  equal (self : t_G) (other : t_G) := solve_lift (self =.? other);
  greater_than (self : t_G) (other : t_G) := solve_lift (self >.? other);
  greater_than_or_equal (self : t_G) (other : t_G) := solve_lift (self >=.? other);
  less_than (self : t_G) (other : t_G) := solve_lift (self <.? other);
  less_than_or_equal (self : t_G) (other : t_G) := solve_lift (self <=.? other);
  not_equal_bm (self : t_G) (other : t_G) := ifb solve_lift (self <> other)
  then solve_lift ((v_ONE shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- v_ONE)
  else solve_lift v_ZERO;
  equal_bm (self : t_G) (other : t_G) := ifb solve_lift (self =.? other)
  then solve_lift ((v_ONE shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- v_ONE)
  else solve_lift v_ZERO;
  greater_than_bm (self : t_G) (other : t_G) := ifb solve_lift (self >.? other)
  then solve_lift ((v_ONE shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- v_ONE)
  else solve_lift v_ZERO;
  greater_than_or_equal_bm (self : t_G) (other : t_G) := ifb solve_lift (self >=.? other)
  then solve_lift ((v_ONE shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- v_ONE)
  else solve_lift v_ZERO;
  less_than_bm (self : t_G) (other : t_G) := ifb solve_lift (self <.? other)
  then solve_lift ((v_ONE shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- v_ONE)
  else solve_lift v_ZERO;
  less_than_or_equal_bm (self : t_G) (other : t_G) := ifb solve_lift (self <=.? other)
  then solve_lift ((v_ONE shift_left ((ret_both (384 : uint_size)) .- (ret_both (1 : uint_size)))) .- v_ONE)
  else solve_lift v_ZERO;
}.

Definition t_Q : choice_type :=
  (int32).
Equations Build_t_Q {L : {fset Location}} {I : Interface} (f_v : both L I (int32)) : both L I (t_Q) :=
  Build_t_Q f_v  :=
    bind_both f_v (fun f_v =>
      solve_lift (ret_both ((f_v) : (t_Q)))) : both L I (t_Q).
Fail Next Obligation.

Notation t_Witness := (t_Q).

Notation t_Statement := (t_G).

Notation t_Message := (t_G).

Notation t_Challenge := (t_Q).

Notation t_Response := (t_Q).

Notation t_Random := (t_Q).

Notation t_Query := (t_Q).

Require Import HashMap.
Export HashMap.

Notation t_QueriesType := (t_HashMap (t_Q) (t_Q) (t_RandomState)).

Equations random_oracle_query {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} (QUERIES : both L1 I1 (t_HashMap (t_Q) (t_Q) (t_RandomState))) (q : both L2 I2 (t_Q)) (uniform_sample : both L3 I3 (t_Q)) : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) ((t_HashMap (t_Q) (t_Q) (t_RandomState) × t_Q)) :=
  random_oracle_query QUERIES q uniform_sample  :=
    solve_lift matchb get_under_impl_2 QUERIES q with
    | Option_Some r =>
      prod_b (clone QUERIES,clone r)
    | Option_None  =>
      letb r := (uniform_sample) : both _ _ (t_Q) in
      letb '(todo_fresh_var,QUERIES_temp) := (insert_under_impl_2 QUERIES q r) : both _ _ ((t_Option (t_Q) × t_HashMap (t_Q) (t_Q) (t_RandomState))) in
      letb QUERIES := (QUERIES_temp) : both _ _ (t_HashMap (t_Q) (t_Q) (t_RandomState)) in
      letb _ := (todo_fresh_var) : both _ _ (t_Option (t_Q)) in
      prod_b (QUERIES,r)
    end : both (L1:|:L2:|:L3) (I1:|:I2:|:I3) ((t_HashMap (t_Q) (t_Q) (t_RandomState) × t_Q)).
Fail Next Obligation.
