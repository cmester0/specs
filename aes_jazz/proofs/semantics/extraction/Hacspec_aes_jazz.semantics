(* Automatically Generated Functional Semantics *)
Import Usestd prelude rust_2018

(Unimplemented NotImplementedYet)

Import Usehacspec_lib

Macro public_bytes((SBox, 256))

Macro public_bytes((RCon, 15))

Macro public_bytes((PBytes256, 256))

Definition v_SBOX :=
  λ (), SBox [99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22]

Definition v_RCON :=
  λ (), RCon [141,1,2,4,8,16,32,64,128,27,54,108,216,171,77]

Definition index_u32 :=
  λ (s : int) (i : int),
  cast ((rem ((shr s) ((mul i) 32))) ((shl 1) 32))

Definition index_u8 :=
  λ (s : int) (i : int),
  cast ((rem ((shr s) ((mul i) 8))) ((shl 1) 8))

Definition rebuild_u32 :=
  λ (s0 : int) (s1 : int) (s2 : int) (s3 : int),
  (bitor (cast s0)) ((bitor ((shl (cast s1)) 8)) ((bitor ((shl (cast s2)) 16)) ((shl (cast s3)) 24)))

Definition rebuild_u128 :=
  λ (s0 : int) (s1 : int) (s2 : int) (s3 : int),
  (bitor (cast s0)) ((bitor ((shl (cast s1)) 32)) ((bitor ((shl (cast s2)) 64)) ((shl (cast s3)) 96)))

Definition subword :=
  λ (v : int),
  (((rebuild_u32 ((index v_SBOX) ((index_u8 v) 0))) ((index v_SBOX) ((index_u8 v) 1))) ((index v_SBOX) ((index_u8 v) 2))) ((index v_SBOX) ((index_u8 v) 3))

Definition rotword :=
  λ (v : int),
  (((rebuild_u32 ((index_u8 v) 1)) ((index_u8 v) 2)) ((index_u8 v) 3)) ((index_u8 v) 0)

Definition vpshufd1 :=
  λ (s : int) (o : int) (i : int),
  (index_u32 ((shr s) ((mul 32) (cast ((rem ((shr o) ((mul 2) i))) 4))))) 0

Definition vpshufd :=
  λ (s : int) (o : int),
  let d1 : int := ((vpshufd1 s) o) 0 in
  let d2 : int := ((vpshufd1 s) o) 1 in
  let d3 : int := ((vpshufd1 s) o) 2 in
  let d4 : int := ((vpshufd1 s) o) 3 in
  (((rebuild_u128 d1) d2) d3) d4

Definition vshufps :=
  λ (s1 : int) (s2 : int) (o : int),
  let d1 : int := ((vpshufd1 s1) o) 0 in
  let d2 : int := ((vpshufd1 s1) o) 1 in
  let d3 : int := ((vpshufd1 s2) o) 2 in
  let d4 : int := ((vpshufd1 s2) o) 3 in
  (((rebuild_u128 d1) d2) d3) d4

Definition key_combine :=
  λ (rkey : int) (temp1 : int) (temp2 : int),
  let temp1 := (vpshufd temp1) 255 in
  let temp2 := ((vshufps temp2) rkey) 16 in
  let rkey := (bitxor rkey) temp2 in
  let temp2 := ((vshufps temp2) rkey) 140 in
  let rkey := (bitxor rkey) temp2 in
  let rkey := (bitxor rkey) temp1 in
  (rkey,temp2)is2

Definition aeskeygenassist :=
  λ (v1 : int) (v2 : int),
  let x1 := (index_u32 v1) 1 in
  let x3 := (index_u32 v1) 3 in
  let y0 := subword x1 in
  let y1 := (bitxor (rotword y0)) (cast v2) in
  let y2 := subword x3 in
  let y3 := (bitxor (rotword y2)) (cast v2) in
  (((rebuild_u128 y0) y1) y2) y3

Definition key_expand :=
  λ (rcon : int) (rkey : int) (temp2 : int),
  let temp1 := (aeskeygenassist rkey) rcon in
  ((key_combine rkey) temp1) temp2

TypeDefinition t_KeyList :=t_Seq_t

Definition keys_expand :=
  λ (key : int),
  let rkeys : t_Seq_t := new_under_impl_41 0 in
  let key := key in
  let rkeys := (push_under_impl_41 rkeys) key in
  let temp2 : int := 0 in
  let (key,rkeys,temp2) := ((fold (into_iter Range[f_start := 1][f_end := 11])) (key,rkeys,temp2)is3) (λ (key,rkeys,temp2) round,
  let rcon := (index v_RCON) round in
  let (key_temp,temp2_temp) := ((key_expand rcon) key) temp2 in
  let key := key_temp in
  let temp2 := temp2_temp in
  let rkeys := (push_under_impl_41 rkeys) key in
  (key,rkeys,temp2)is3) in
  rkeys

Definition subbytes :=
  λ (s : int),
  (((rebuild_u128 (subword ((index_u32 s) 0))) (subword ((index_u32 s) 1))) (subword ((index_u32 s) 2))) (subword ((index_u32 s) 3))

Definition matrix_index :=
  λ (s : int) (i : int) (j : int),
  (index_u8 ((index_u32 s) j)) i

Definition shiftrows :=
  λ (s : int),
  (((rebuild_u128 ((((rebuild_u32 (((matrix_index s) 0) 0)) (((matrix_index s) 1) 1)) (((matrix_index s) 2) 2)) (((matrix_index s) 3) 3))) ((((rebuild_u32 (((matrix_index s) 0) 1)) (((matrix_index s) 1) 2)) (((matrix_index s) 2) 3)) (((matrix_index s) 3) 0))) ((((rebuild_u32 (((matrix_index s) 0) 2)) (((matrix_index s) 1) 3)) (((matrix_index s) 2) 0)) (((matrix_index s) 3) 1))) ((((rebuild_u32 (((matrix_index s) 0) 3)) (((matrix_index s) 1) 0)) (((matrix_index s) 2) 1)) (((matrix_index s) 3) 2))

Definition xtime :=
  λ (x : int),
  let x1 := (shl x) 1 in
  let x7 := (shr x) 7 in
  let x71 := (bitand x7) 1 in
  let x711b := (mul x71) 27 in
  (bitxor x1) x711b

Definition mixcolumn :=
  λ (c : int) (state : int),
  let s0 := ((matrix_index state) 0) c in
  let s1 := ((matrix_index state) 1) c in
  let s2 := ((matrix_index state) 2) c in
  let s3 := ((matrix_index state) 3) c in
  let tmp := (bitxor ((bitxor ((bitxor s0) s1)) s2)) s3 in
  let r0 := (bitxor ((bitxor s0) tmp)) (xtime ((bitxor s0) s1)) in
  let r1 := (bitxor ((bitxor s1) tmp)) (xtime ((bitxor s1) s2)) in
  let r2 := (bitxor ((bitxor s2) tmp)) (xtime ((bitxor s2) s3)) in
  let r3 := (bitxor ((bitxor s3) tmp)) (xtime ((bitxor s3) s0)) in
  (((rebuild_u32 r0) r1) r2) r3

Definition mixcolumns :=
  λ (state : int),
  let c0 := (mixcolumn 0) state in
  let c1 := (mixcolumn 1) state in
  let c2 := (mixcolumn 2) state in
  let c3 := (mixcolumn 3) state in
  (((rebuild_u128 c0) c1) c2) c3

Definition aesenc :=
  λ (state : int) (rkey : int),
  let state := shiftrows state in
  let state := subbytes state in
  let state := mixcolumns state in
  (bitxor state) rkey

Definition aesenclast :=
  λ (state : int) (rkey : int),
  let state := shiftrows state in
  let state := subbytes state in
  (bitxor state) rkey

Definition aes_rounds :=
  λ (rkeys : t_Seq_t) (inp : int),
  let state : int := (bitxor inp) ((index rkeys) 0) in
  let state := ((fold (into_iter Range[f_start := 1][f_end := 10])) state) (λ state round,
  (aesenc state) ((index rkeys) round)) in
  (aesenclast state) ((index rkeys) 10)

Definition aes :=
  λ (key : int) (inp : int),
  let rkeys := keys_expand key in
  (aes_rounds rkeys) inp
