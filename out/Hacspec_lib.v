(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib.

From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Require Import Lia.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Sumbool.

From mathcomp Require Import fintype.

From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset fmap.

From mathcomp Require Import ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith List.
Import ListNotations.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Declare Scope hacspec_scope.

Open Scope list_scope.
Open Scope hacspec_scope.
Open Scope nat_scope.

Require Import Hacspec_Lib_Comparable.

Import choice.Choice.Exports.

(** Should be moved to Hacspec_Lib.v **)
Program Definition int_xI {WS : wsize} (a : (* both0  *)(@int WS)) : (* both0 *) (@int WS) :=
  Hacspec_Lib_Pre.int_add (Hacspec_Lib_Pre.int_mul a ((* lift_to_both0 *) (@repr WS 2))) ((* lift_to_both0 *) (@one WS)).
(* Next Obligation. intros ; now do 2 rewrite fsetU0. Defined. *)
(* Next Obligation. intros ; rewrite <- fset0E ; now do 2 rewrite fsetU0. Defined. *)

Program Definition int_xO {WS : wsize} (a : int WS) : int WS :=
  Hacspec_Lib_Pre.int_mul a (@repr WS 2).
(* Next Obligation. intros ; now rewrite fsetU0. Defined. *)
(* Next Obligation. intros ; rewrite <- fset0E ; now rewrite fsetU0. Defined. *)

Definition both_int_one {WS : wsize} : both0 (@int WS) := lift_to_both0 (one).

Compute (Hacspec_Lib_Pre.int_add (repr U32 3%Z) (repr U32 8%Z)).

Open Scope hacspec_scope.
Definition int_num {WS : wsize} := int WS.
Number Notation int_num Pos.of_num_int Pos.to_num_int (via positive mapping [[int_xI] => xI, [int_xO] => xO , [one] => xH]) : hacspec_scope.

Notation "0" := (repr _ 0%Z) : hacspec_scope.

Check 5 : int8.
Check 3 : int8.
Check 8 : int8.

(* Notation U8_t := int8. *)
(* Notation U8 := id. *)
(* Notation U16_t := int16. *)
(* Notation U16 := id. *)
(* Notation U32_t := int32. *)
(* Notation U32 := id. *)
(* Notation U64_t := int64. *)
(* Notation U64 := id. *)
(* Notation U128_t := int128. *)
(* Notation U128 := id. *)

Class Addition L1 L2 I1 I2 (A : choice_type) := add : both L1 I1 A -> both L2 I2 A -> both (L1 :|: L2) (I1 :|: I2) A.
Notation "a .+ b" := (add a b).
Instance array_add_inst {ws : wsize} {len: uint_size} {L1 L2 I1 I2} : Addition L1 L2 I1 I2 (nseq (int ws) len) := { add a b := a array_add b }.
Instance int_add_inst {ws : wsize} {L1 L2 I1 I2} : Addition L1 L2 I1 I2 (@int ws) := { add a b := int_add a b }.

Class Subtraction L1 L2 I1 I2 A := sub : both L1 I1 A -> both L2 I2 A -> both (L1 :|: L2) (I1 :|: I2) A.
Notation "a .- b" := (sub a b).
Instance array_sub_inst {ws : wsize} {len: uint_size} {L1 L2 I1 I2} : Subtraction L1 L2 I1 I2 (nseq (@int ws) len) := { sub a b := a array_minus b }.
Instance int_sub_inst {ws : wsize} {L1 L2 I1 I2} : Subtraction L1 L2 I1 I2 (@int ws) := { sub a b := int_sub a b }.

Class Multiplication L1 L2 I1 I2 A := mul : both L1 I1 A -> both L2 I2 A -> both (L1 :|: L2) (I1 :|: I2) A.
Notation "a .* b" := (mul a b).
Instance array_mul_inst {ws : wsize} {len: uint_size} { L1 L2 I1 I2} : Multiplication L1 L2 I1 I2 (nseq (@int ws) len) := { mul a b := a array_mul b }.
Instance int_mul_inst {ws : wsize} { L1 L2 I1 I2} : Multiplication  L1 L2 I1 I2 (@int ws) := { mul a b := int_mul a b }.

Class Xor L1 L2 I1 I2 A := xor : both L1 I1 A -> both L2 I2 A -> both (L1 :|: L2) (I1 :|: I2) A.
Notation "a .^ b" := (xor a b).

Instance array_xor_inst {ws : wsize} {len: uint_size} {L1 L2 I1 I2} : Xor L1 L2 I1 I2 (nseq (@int ws) len) := { xor a b := a array_xor b }.
Instance int_xor_inst {ws : wsize} {L1 L2 I1 I2} : Xor L1 L2 I1 I2 (@int ws) := { xor a b := int_xor a b }.

(* Definition new {A : choice_type} {len} : nseq A len := array_new_ default _. *)

(* (* Axiom conv : A -> B. *) *)
(* (* Coercion conv : A >-> B. *) *)
(* (* Check (fun x : A => x : B). *) *)

(* Record mixin_of A := *)
(*   Mixin { *)
(*       as_nseq :> both A ; *)
(*       as_seq :> both A ; *)
(*     }. *)
(* (* Check choice_type_class_of. *) *)
(* Record class_of (A : choice_type) := { *)
(*     base : choice.Choice.sort A ; *)
(*     mixin : mixin_of A *)
(*   }. *)
(* Structure type := Pack {sort : choice_type ; _ : class_of sort }. *)

(* Coercion mixin : class_of >-> mixin_of. *)
(* Coercion sort : type >-> choice_type. *)

Structure array_or_seq A len :=
  { as_nseq :> nseq A len ;
    as_seq :> seq A
  }.
Print as_seq.
Print as_nseq.

Print Graph.

Check (fun x : array_or_seq 'nat 25 => x : (* both_seq *) seq 'nat).
Check (fun x : array_or_seq 'nat 25 => x : (* both_nseq *) (nseq 'nat 25)).

Arguments as_seq {_} {_} {_} {_}. (* array_or_seq. *)
Arguments as_nseq {_} {_} {_} {_}. (* array_or_seq. *)
(* Coercion as_seq : array_or_seq >-> both. *)
(* Coercion as_nseq : array_or_seq >-> both. *)



Check (fun x : array_or_seq 'nat fset0 (fset []) 25 => x : both0 (nseq 'nat 25)).

(* Definition nseq_array_or_seq {A L I len} (a : both L I (nseq A len)) := *)
(*   Build_array_or_seq A L I len (array_to_seq a) a. *)
(* Canonical (* Structure *) nseq_array_or_seq. *)

Definition nseq_array_or_seq {A L I len} (val : both L I (nseq A len)) : array_or_seq A L I len :=
  {| as_seq := array_to_seq val ; as_nseq := val |}.

Arguments nseq_array_or_seq {A} {L} {I} {len}.
Check nseq_array_or_seq.
Coercion nseq_array_or_seq : both >-> array_or_seq.
Canonical Structure nseq_array_or_seq.

Check (fun (x : both0 (nseq 'nat 25)) => x : array_or_seq 'nat fset0 (fset []) 25).

Instance seq_array_or_seq {A : choice_type} {L I} (a : both L I (seq A)) : array_or_seq A _ _ (seq_len a) :=
  { as_seq := a ; as_nseq := array_from_seq _ a ; }.
Coercion seq_array_or_seq : both >-> array_or_seq.
Canonical Structure seq_array_or_seq.

(* Definition seq_array_or_seq {A L I len} (a : both L I (seq A)) := *)
(*   Build_array_or_seq A L I len a (array_from_seq (from_uint_size len) a). *)
(* Canonical (* Structure *) seq_array_or_seq. *)
(* Print Canonical Projections . *)

Definition array_index {A: choice_type} {len : uint_size} {L I} (s: array_or_seq A L I len) {WS} (i : both L I (@int WS)) := array_index (as_nseq s) i.
(* Definition array_index {A: choice_type} {len : uint_size} {L I} (s: both L I (nseq A len)) {WS} (i : both L I (@int WS)) := array_index s i. *)
Notation " x .[ a ]" := (array_index x a) (at level 40).
Definition array_upd {A: choice_type} {len : uint_size} {L I} (s: both L I (nseq A len)) {WS} (i: both L I (@int WS)) (new_v: both L I A) : nseq A len := array_upd s i new_v.
Notation " x .[ i ]<- a" := (array_upd x i a) (at level 40).

(* Definition update {A : Type}  `{Default A} {len slen} (s : nseq A len) {WS} (start : @int WS) (start_a : array_or_seq A slen) : nseq A len := *)
(* array_update (a := A) (len := len) s (unsigned start) (as_seq start_a). *)

(* Definition to_le_U32s {A l} := array_to_le_uint32s (A := A) (l := l). *)
(* Axiom to_le_bytes : forall {ws : wsize} {len}, nseq (@int ws) len -> seq int8. *)
(* Definition from_seq {A : Type}  `{Default A} {len slen} (s : array_or_seq A slen) : nseq A len := array_from_seq _ (as_seq s). *)

Notation Seq_t := seq.
(* Notation len := (fun s => seq_len s : int32). *)

(* Definition array_slice {a: Type} `{Default a} {len : nat} (input: nseq a len) {WS} (start: @int WS) (slice_len: @int WS) : seq a := slice (array_to_seq input) (unsigned start) (unsigned (start .+ slice_len)). *)
(* Notation slice := array_slice. *)
(* Definition seq_new {A: Type} `{Default A} {WS} (len: @int WS) : seq A := seq_new (unsigned len). *)
Notation new_seq := seq_new.
Notation num_exact_chunks := seq_num_exact_chunks.
Notation get_exact_chunk := seq_get_exact_chunk.
(* Definition set_chunk {a: Type} `{Default a} {len} (s: seq a) {WS} (chunk_len: @int WS) (chunk_num: @int WS) (chunk: array_or_seq a len) : seq a := seq_set_chunk s (unsigned chunk_len) (unsigned chunk_num) (as_seq chunk). *)
(* Definition set_exact_chunk {a} `{H : Default a} {len} s {WS} := @set_chunk a H len s WS. *)
Notation get_remainder_chunk := seq_get_remainder_chunk.
Notation "a <> b" := (negb (eqb a b)).

Notation from_secret_literal := nat_mod_from_secret_literal.
(* Definition pow2 {m} (x : @int wsize32) := nat_mod_pow2 m (unsigned x). *)
(* Instance nat_mod_addition {n} : Addition (nat_mod n) := { add a b := a +% b }. *)
(* Instance nat_mod_subtraction {n} : Subtraction (nat_mod n) := { sub a b := a -% b }. *)
(* Instance nat_mod_multiplication {n} : Multiplication (nat_mod n) := { mul a b := a *% b }. *)
(* Definition from_slice {a: Type} `{Default a} {len slen} (x : array_or_seq a slen) {WS} (start: @int WS) (slice_len: @int WS) := array_from_slice default len (as_seq x) (unsigned start) (unsigned slice_len). *)
Notation zero := nat_mod_zero.
Notation to_byte_seq_le := nat_mod_to_byte_seq_le.
Notation U128_to_le_bytes := u128_to_le_bytes.
Notation U64_to_le_bytes := u64_to_le_bytes.
     Notation from_byte_seq_le := nat_mod_from_byte_seq_le.
Definition from_literal {m} := nat_mod_from_literal m.
Notation inv := nat_mod_inv.
Notation update_start := array_update_start.
Notation pow := nat_mod_pow_self.
Notation bit := nat_mod_bit.

(* Definition int_to_int {ws1 ws2} (i : @int ws1) : @int ws2 := repr (unsigned i). *)
(* Coercion int_to_int : int >-> int. *)
Notation push := seq_push.
Notation Build_secret := secret.
Notation "a -Ã— b" :=
(prod a b) (at level 80, right associativity) : hacspec_scope.
Notation Result_t := result.
Axiom TODO_name : Type.
Notation ONE := nat_mod_one.
Notation exp := nat_mod_exp.
(* Notation nat_mod := GZnZ.znz. *)
(* Instance nat_mod_znz_addition {n} : Addition (GZnZ.znz n) := { add a b := a +% b }. *)
(* Instance nat_mod_znz_subtraction {n} : Subtraction (GZnZ.znz n) := { sub a b := a -% b }. *)
(* Instance nat_mod_znz_multiplication {n} : Multiplication (GZnZ.znz n) := { mul a b := a *% b }. *)
Notation TWO := nat_mod_two.
Notation ne := (fun x y => negb (eqb x y)).
Notation eq := (eqb).
Notation rotate_right := (ror).
Notation to_be_U32s := array_to_be_uint32s.
Notation get_chunk := seq_get_chunk.
Notation num_chunks := seq_num_chunks.
Notation U64_to_be_bytes := uint64_to_be_bytes.
Notation to_be_bytes := array_to_be_bytes.
Notation U8_from_usize := uint8_from_usize.
Notation concat := seq_concat.
Notation declassify := id.
Notation U128_from_be_bytes := uint128_from_be_bytes.
Notation U128_to_be_bytes := uint128_to_be_bytes.
Notation slice_range := array_slice_range.
Notation truncate := seq_truncate.
Axiom array_to_be_uint64s : forall {A l}, nseq A l -> seq uint64.
Notation to_be_U64s := array_to_be_uint64s.
Notation classify := id.
Notation U64_from_U8 := uint64_from_uint8.
Fixpoint Build_Range_t (a b : nat) := (a,b). (* match (b - a)%nat with O => [] | S n => match b with | O => [] | S b' => Build_Range_t a b' ++ [b] end end. *)
Notation declassify_eq := eq.
Notation String_t := String.string.
(** end of: Should be moved to Hacspec_Lib.v **)
