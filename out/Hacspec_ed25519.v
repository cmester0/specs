(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_lib.

Require Import Hacspec_sha512.

Require Import Hacspec_edwards25519.

Definition scalar_from_hash (h : Sha512Digest_t) : Scalar_t :=
  let s := (from_byte_seq_le h) : BigScalar_t in
  from_byte_seq_le (slice (to_byte_seq_le s) (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)).

Definition sign (sk : SerializedScalar_t) (msg : Seq_t U8_t) : Signature_t :=
  let '(a,prefix) := (secret_expand sk) : (SerializedScalar_t × SerializedScalar_t) in
  let a := (from_byte_seq_le a) : Scalar_t in
  let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a_p := (compress (point_mul a b)) : CompressedEdPoint_t in
  let r := (scalar_from_hash (sha512 (concat prefix msg))) : Scalar_t in
  let r_p := (point_mul r b) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let r_s := (compress r_p) : CompressedEdPoint_t in
  let h := (scalar_from_hash (sha512 (concat (concat r_s a_p) msg))) : Scalar_t in
  let s := (r.+(h.*a)) : _ in
  let s_bytes := (slice (to_byte_seq_le s) (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : Seq_t U8_t in
  update (update new (@repr WORDSIZE32 0) r_s) (@repr WORDSIZE32 32) s_bytes.

Definition zcash_verify (pk : CompressedEdPoint_t) (signature : Signature_t) (msg : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let b := (unwrap (decompress_non_canonical BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a := (from_residual (ok_or (decompress_non_canonical pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
  let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
  let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
  let _ := (if
      MachineIntegers.not (check_canonical_scalar s_bytes)
    then
      let _ := (Err InvalidSError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let r := (from_residual (ok_or (decompress_non_canonical r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
  let s := (from_byte_seq_le s_bytes) : Scalar_t in
  let k := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
  let sb := (point_mul_by_cofactor (point_mul s b)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let rc := (point_mul_by_cofactor r) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let ka := (point_mul_by_cofactor (point_mul k a)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    point_eq sb (point_add rc ka)
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).

Definition ietf_cofactored_verify (pk : CompressedEdPoint_t) (signature : Signature_t) (msg : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a := (from_residual (ok_or (decompress pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
  let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
  let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
  let _ := (if
      MachineIntegers.not (check_canonical_scalar s_bytes)
    then
      let _ := (Err InvalidSError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let r := (from_residual (ok_or (decompress r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
  let s := (from_byte_seq_le s_bytes) : Scalar_t in
  let k := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
  let sb := (point_mul_by_cofactor (point_mul s b)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let rc := (point_mul_by_cofactor r) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let ka := (point_mul_by_cofactor (point_mul k a)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    point_eq sb (point_add rc ka)
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).

Definition ietf_cofactorless_verify (pk : CompressedEdPoint_t) (signature : Signature_t) (msg : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a := (from_residual (ok_or (decompress pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
  let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
  let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
  let _ := (if
      MachineIntegers.not (check_canonical_scalar s_bytes)
    then
      let _ := (Err InvalidSError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let r := (from_residual (ok_or (decompress r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
  let s := (from_byte_seq_le s_bytes) : Scalar_t in
  let k := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
  let sb := (point_mul s b) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let ka := (point_mul k a) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    point_eq sb (point_add r ka)
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).

Definition is_identity (p : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t)) : bool :=
  point_eq p point_identity.

Definition alg2_verify (pk : CompressedEdPoint_t) (signature : Signature_t) (msg : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a := (from_residual (ok_or (decompress pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
  let _ := (if
      is_identity (point_mul_by_cofactor a)
    then
      let _ := (Err SmallOrderPointError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
  let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
  let _ := (if
      MachineIntegers.not (check_canonical_scalar s_bytes)
    then
      let _ := (Err InvalidSError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let r := (from_residual (ok_or (decompress r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
  let s := (from_byte_seq_le s_bytes) : Scalar_t in
  let k := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
  let sb := (point_mul_by_cofactor (point_mul s b)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let rc := (point_mul_by_cofactor r) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let ka := (point_mul_by_cofactor (point_mul k a)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    point_eq sb (point_add rc ka)
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).

Record BatchEntry : Type :={
  2 : Signature_t;
  1 : Seq_t U8_t;
  0 : CompressedEdPoint_t;
}.
Notation BatchEntry_t := ((BatchEntry)).
Definition BatchEntry : BatchEntry_t -> BatchEntry_t :=
  id.

Definition zcash_batch_verify (entries : Seq_t BatchEntry_t) (entropy : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let _ := (if
      (len entropy)<.?((@repr WORDSIZE32 16).*(len entries))
    then
      let _ := (Err NotEnoughRandomnessError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let s_sum := (zero) : Scalar_t in
  let r_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let '(a_sum,r_sum,s_sum) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len entries))) (a_sum,r_sum,s_sum) (fun i '(a_sum,r_sum,s_sum) =>
      let {|
        0 := pk;
        1 := msg;
        2 := signature;
      |} := (clone (entries.[i])) : BatchEntry_t in
      let a := (from_residual (ok_or (decompress_non_canonical pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
      let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
      let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
      let _ := (if
          MachineIntegers.not (check_canonical_scalar s_bytes)
        then
          let _ := (Err InvalidSError_t) : unit in
          Ok tt
        else
          Ok tt) : unit in
      Ok (let r := (from_residual (ok_or (decompress_non_canonical r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
      let s := (from_byte_seq_le s_bytes) : Scalar_t in
      let c := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
      let z := (slice entropy ((@repr WORDSIZE32 16).*i) (@repr WORDSIZE32 16)) : Seq_t U8_t in
      let z := (from_byte_seq_le (concat z (new_seq (@repr WORDSIZE32 16)))) : Scalar_t in
      let s_sum := (s_sum.+(s.*z)) : _ in
      let r_sum := (point_add r_sum (point_mul z r)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
      (point_add a_sum (point_mul (z.*c) a),r_sum,s_sum)))) : ((Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × _) in
  let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let sb := (point_mul s_sum b) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let check := (point_mul_by_cofactor (point_add (point_neg sb) (point_add r_sum a_sum))) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    is_identity check
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).

Definition ietf_cofactored_batch_verify (entries : Seq_t BatchEntry_t) (entropy : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let _ := (if
      (len entropy)<.?((@repr WORDSIZE32 16).*(len entries))
    then
      let _ := (Err NotEnoughRandomnessError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let s_sum := (zero) : Scalar_t in
  let r_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let '(a_sum,r_sum,s_sum) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len entries))) (a_sum,r_sum,s_sum) (fun i '(a_sum,r_sum,s_sum) =>
      let {|
        0 := pk;
        1 := msg;
        2 := signature;
      |} := (clone (entries.[i])) : BatchEntry_t in
      let a := (from_residual (ok_or (decompress pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
      let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
      let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
      let _ := (if
          MachineIntegers.not (check_canonical_scalar s_bytes)
        then
          let _ := (Err InvalidSError_t) : unit in
          Ok tt
        else
          Ok tt) : unit in
      Ok (let r := (from_residual (ok_or (decompress r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
      let s := (from_byte_seq_le s_bytes) : Scalar_t in
      let c := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
      let z := (slice entropy ((@repr WORDSIZE32 16).*i) (@repr WORDSIZE32 16)) : Seq_t U8_t in
      let z := (from_byte_seq_le (concat z (new_seq (@repr WORDSIZE32 16)))) : Scalar_t in
      let s_sum := (s_sum.+(s.*z)) : _ in
      let r_sum := (point_add r_sum (point_mul z r)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
      (point_add a_sum (point_mul (z.*c) a),r_sum,s_sum)))) : ((Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × _) in
  let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let sb := (point_mul s_sum b) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let check := (point_mul_by_cofactor (point_add (point_neg sb) (point_add r_sum a_sum))) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    is_identity check
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).

Definition ietf_cofactorless_batch_verify (entries : Seq_t BatchEntry_t) (entropy : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let _ := (if
      (len entropy)<.?((@repr WORDSIZE32 16).*(len entries))
    then
      let _ := (Err NotEnoughRandomnessError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let s_sum := (zero) : Scalar_t in
  let r_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let '(a_sum,r_sum,s_sum) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len entries))) (a_sum,r_sum,s_sum) (fun i '(a_sum,r_sum,s_sum) =>
      let {|
        0 := pk;
        1 := msg;
        2 := signature;
      |} := (clone (entries.[i])) : BatchEntry_t in
      let a := (from_residual (ok_or (decompress pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
      let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
      let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
      let _ := (if
          MachineIntegers.not (check_canonical_scalar s_bytes)
        then
          let _ := (Err InvalidSError_t) : unit in
          Ok tt
        else
          Ok tt) : unit in
      Ok (let r := (from_residual (ok_or (decompress r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
      let s := (from_byte_seq_le s_bytes) : Scalar_t in
      let c := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
      let z := (slice entropy ((@repr WORDSIZE32 16).*i) (@repr WORDSIZE32 16)) : Seq_t U8_t in
      let z := (from_byte_seq_le (concat z (new_seq (@repr WORDSIZE32 16)))) : Scalar_t in
      let s_sum := (s_sum.+(s.*z)) : _ in
      let r_sum := (point_add r_sum (point_mul z r)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
      (point_add a_sum (point_mul (z.*c) a),r_sum,s_sum)))) : ((Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × _) in
  let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let sb := (point_mul s_sum b) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let check := (point_add (point_neg sb) (point_add r_sum a_sum)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    is_identity check
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).

Definition alg3_batch_verify (entries : Seq_t BatchEntry_t) (entropy : Seq_t U8_t) : Result_t (unit) (Error_t) :=
  run (let _ := (if
      (len entropy)<.?((@repr WORDSIZE32 16).*(len entries))
    then
      let _ := (Err NotEnoughRandomnessError_t) : unit in
      Ok tt
    else
      Ok tt) : unit in
  Ok (let s_sum := (zero) : Scalar_t in
  let r_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let a_sum := (point_identity) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let '(a_sum,r_sum,s_sum) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len entries))) (a_sum,r_sum,s_sum) (fun i '(a_sum,r_sum,s_sum) =>
      let {|
        0 := pk;
        1 := msg;
        2 := signature;
      |} := (clone (entries.[i])) : BatchEntry_t in
      let a := (from_residual (ok_or (decompress pk) InvalidPublickeyError_t)) : Result_t (unit) (Error_t) in
      let _ := (if
          is_identity (point_mul_by_cofactor a)
        then
          let _ := (Err SmallOrderPointError_t) : unit in
          Ok tt
        else
          Ok tt) : unit in
      let r_bytes := (from_slice signature (@repr WORDSIZE32 0) (@repr WORDSIZE32 32)) : CompressedEdPoint_t in
      let s_bytes := (from_slice signature (@repr WORDSIZE32 32) (@repr WORDSIZE32 32)) : SerializedScalar_t in
      let _ := (if
          MachineIntegers.not (check_canonical_scalar s_bytes)
        then
          let _ := (Err InvalidSError_t) : unit in
          Ok tt
        else
          Ok tt) : unit in
      Ok (let r := (from_residual (ok_or (decompress r_bytes) InvalidRError_t)) : Result_t (unit) (Error_t) in
      let s := (from_byte_seq_le s_bytes) : Scalar_t in
      let c := (scalar_from_hash (sha512 (concat (concat r_bytes pk) msg))) : Scalar_t in
      let z := (slice entropy ((@repr WORDSIZE32 16).*i) (@repr WORDSIZE32 16)) : Seq_t U8_t in
      let z := (from_byte_seq_le (concat z (new_seq (@repr WORDSIZE32 16)))) : Scalar_t in
      let s_sum := (s_sum.+(s.*z)) : _ in
      let r_sum := (point_add r_sum (point_mul z r)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
      (point_add a_sum (point_mul (z.*c) a),r_sum,s_sum)))) : ((Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) × _) in
  let b := (unwrap (decompress BASE)) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let sb := (point_mul s_sum b) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  let check := (point_mul_by_cofactor (point_add (point_neg sb) (point_add r_sum a_sum))) : (Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t × Ed25519FieldElement_t) in
  if
    is_identity check
  then
    Ok tt
  else
    Err InvalidSignatureError_t)).
