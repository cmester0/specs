(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_lib.

Require Import Hacspec_p256.

Require Import Hacspec_sha256.

Inductive Error_t : Type :=
| InvalidScalarError_t
| InvalidSignatureError_t.

Notation P256PublicKey_t := ((P256FieldElement_t × P256FieldElement_t)).

Notation P256SecretKey_t := (P256Scalar_t).

Notation P256Signature_t := ((P256Scalar_t × P256Scalar_t)).

Notation P256SignatureResult_t := (Result_t ((P256Scalar_t × P256Scalar_t)) (Error_t)).

Notation P256VerifyResult_t := (Result_t (unit) (Error_t)).

Notation CheckResult_t := (Result_t (unit) (Error_t)).

Notation ArithmeticResult_t := (Result_t ((P256FieldElement_t × P256FieldElement_t)) (Error_t)).

Definition check_scalar_zero (r : P256Scalar_t) : Result_t (unit) (Error_t) :=
  if
    equal r zero
  then
    Err InvalidScalarError_t
  else
    Ok tt.

Definition ecdsa_point_mul_base (x : P256Scalar_t) : Result_t ((P256FieldElement_t × P256FieldElement_t)) (Error_t) :=
  match p256_point_mul_base x with
  | {|
    0 := s;
  |} => Ok s
  | {|
    0 := _;
  |} => Err InvalidScalarError_t
  end.

Definition ecdsa_point_mul (k : P256Scalar_t) (p : (P256FieldElement_t × P256FieldElement_t)) : Result_t ((P256FieldElement_t × P256FieldElement_t)) (Error_t) :=
  match p256_point_mul k p with
  | {|
    0 := s;
  |} => Ok s
  | {|
    0 := _;
  |} => Err InvalidScalarError_t
  end.

Definition ecdsa_point_add (p : (P256FieldElement_t × P256FieldElement_t)) (q : (P256FieldElement_t × P256FieldElement_t)) : Result_t ((P256FieldElement_t × P256FieldElement_t)) (Error_t) :=
  match point_add p q with
  | {|
    0 := s;
  |} => Ok s
  | {|
    0 := _;
  |} => Err InvalidScalarError_t
  end.

Definition sign (payload : Seq_t U8_t) (sk : P256Scalar_t) (nonce : P256Scalar_t) : Result_t ((P256Scalar_t × P256Scalar_t)) (Error_t) :=
  let _ := (from_residual (check_scalar_zero nonce)) : Result_t ((P256Scalar_t × P256Scalar_t)) (Error_t) in
  let '(k_x,_k_y) := (from_residual (ecdsa_point_mul_base nonce)) : Result_t ((P256Scalar_t × P256Scalar_t)) (Error_t) in
  let r := (from_byte_seq_be (to_byte_seq_be k_x)) : P256Scalar_t in
  let _ := (from_residual (check_scalar_zero r)) : Result_t ((P256Scalar_t × P256Scalar_t)) (Error_t) in
  let payload_hash := (hash payload) : Sha256Digest_t in
  let payload_hash := (from_byte_seq_be payload_hash) : P256Scalar_t in
  let rsk := (r.*sk) : _ in
  let hash_rsk := (payload_hash.+rsk) : _ in
  let nonce_inv := (inv nonce) : P256Scalar_t in
  let s := (nonce_inv.*hash_rsk) : _ in
  Ok (r,s).

Definition ecdsa_p256_sha256_sign (payload : Seq_t U8_t) (sk : P256Scalar_t) (nonce : P256Scalar_t) : Result_t ((P256Scalar_t × P256Scalar_t)) (Error_t) :=
  sign payload sk nonce.

Definition verify (payload : Seq_t U8_t) (pk : (P256FieldElement_t × P256FieldElement_t)) (signature : (P256Scalar_t × P256Scalar_t)) : Result_t (unit) (Error_t) :=
  let '(r,s) := (signature) : (P256Scalar_t × P256Scalar_t) in
  let payload_hash := (hash payload) : Sha256Digest_t in
  let payload_hash := (from_byte_seq_be payload_hash) : P256Scalar_t in
  let s_inv := (inv s) : P256Scalar_t in
  let u1 := (payload_hash.*s_inv) : _ in
  let u1 := (from_residual (ecdsa_point_mul_base u1)) : Result_t (unit) (Error_t) in
  let u2 := (r.*s_inv) : _ in
  let u2 := (from_residual (ecdsa_point_mul u2 pk)) : Result_t (unit) (Error_t) in
  let '(x,_y) := (from_residual (ecdsa_point_add u1 u2)) : Result_t (unit) (Error_t) in
  let x := (from_byte_seq_be (to_byte_seq_be x)) : P256Scalar_t in
  if
    eq x r
  then
    Ok tt
  else
    Err InvalidSignatureError_t.

Definition ecdsa_p256_sha256_verify (payload : Seq_t U8_t) (pk : (P256FieldElement_t × P256FieldElement_t)) (signature : (P256Scalar_t × P256Scalar_t)) : Result_t (unit) (Error_t) :=
  verify payload pk signature.
