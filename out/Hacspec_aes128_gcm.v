(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_lib.

Require Import Hacspec_aes.

Require Import Hacspec_gf128.

Notation AesGcmByteSeqResult_t := (Result_t (Seq_t U8_t) (int8)).

Definition INVALID_TAG : int8 :=
  (@repr WORDSIZE8 1).

Definition pad_aad_msg (aad : Seq_t U8_t) (msg : Seq_t U8_t) : Seq_t U8_t :=
  let laad := (len aad) : uint_size in
  let lmsg := (len msg) : uint_size in
  let pad_aad := (if
      (laad.%(@repr WORDSIZE32 16))=.?(@repr WORDSIZE32 0)
    then
      laad
    else
      laad.+((@repr WORDSIZE32 16).-(laad.%(@repr WORDSIZE32 16)))) : uint_size in
  let pad_msg := (if
      (lmsg.%(@repr WORDSIZE32 16))=.?(@repr WORDSIZE32 0)
    then
      lmsg
    else
      lmsg.+((@repr WORDSIZE32 16).-(lmsg.%(@repr WORDSIZE32 16)))) : uint_size in
  let padded_msg := (new_seq ((pad_aad.+pad_msg).+(@repr WORDSIZE32 16))) : Seq_t U8_t in
  let padded_msg := (update padded_msg (@repr WORDSIZE32 0) aad) : Seq_t U8_t in
  let padded_msg := (update padded_msg pad_aad msg) : Seq_t U8_t in
  let padded_msg := (update padded_msg (pad_aad.+pad_msg) (U64_to_be_bytes ((U64 (cast laad)).*(U64 (@repr WORDSIZE64 8))))) : Seq_t U8_t in
  let padded_msg := (update padded_msg ((pad_aad.+pad_msg).+(@repr WORDSIZE32 8)) (U64_to_be_bytes ((U64 (cast lmsg)).*(U64 (@repr WORDSIZE64 8))))) : Seq_t U8_t in
  padded_msg.

Definition encrypt_aes (key : Seq_t U8_t) (iv : AesNonce_t) (aad : Seq_t U8_t) (msg : Seq_t U8_t) : (Seq_t U8_t × Gf128Tag_t) :=
  let iv0 := (new) : AesNonce_t in
  let mac_key := (unwrap (aes_ctr_key_block key iv0 (secret (@repr WORDSIZE32 0)) KEY_LENGTH ROUNDS KEY_SCHEDULE_LENGTH KEY_LENGTH ITERATIONS)) : Block_t in
  let tag_mix := (unwrap (aes_ctr_key_block key (clone iv) (secret (@repr WORDSIZE32 1)) KEY_LENGTH ROUNDS KEY_SCHEDULE_LENGTH KEY_LENGTH ITERATIONS)) : Block_t in
  let cipher_text := (aes128_encrypt (from_seq key) iv (secret (@repr WORDSIZE32 2)) msg) : Seq_t U8_t in
  let padded_msg := (pad_aad_msg aad cipher_text) : Seq_t U8_t in
  let tag := (gmac padded_msg (from_seq mac_key)) : Gf128Tag_t in
  let tag := (xor_block (from_seq tag) tag_mix) : Block_t in
  (cipher_text,from_seq tag).

Definition encrypt_aes128 (key : Key128_t) (iv : AesNonce_t) (aad : Seq_t U8_t) (msg : Seq_t U8_t) : (Seq_t U8_t × Gf128Tag_t) :=
  encrypt_aes (from_seq key) iv aad msg.

Definition decrypt_aes (key : Seq_t U8_t) (iv : AesNonce_t) (aad : Seq_t U8_t) (cipher_text : Seq_t U8_t) (tag : Gf128Tag_t) : Result_t (Seq_t U8_t) (int8) :=
  let iv0 := (new) : AesNonce_t in
  let mac_key := (from_residual (aes_ctr_key_block key iv0 (secret (@repr WORDSIZE32 0)) KEY_LENGTH ROUNDS KEY_SCHEDULE_LENGTH KEY_LENGTH ITERATIONS)) : Result_t (Seq_t U8_t) (int8) in
  let tag_mix := (from_residual (aes_ctr_key_block key (clone iv) (secret (@repr WORDSIZE32 1)) KEY_LENGTH ROUNDS KEY_SCHEDULE_LENGTH KEY_LENGTH ITERATIONS)) : Result_t (Seq_t U8_t) (int8) in
  let padded_msg := (pad_aad_msg aad cipher_text) : Seq_t U8_t in
  let my_tag := (gmac padded_msg (from_seq mac_key)) : Gf128Tag_t in
  let my_tag := (xor_block (from_seq my_tag) tag_mix) : Block_t in
  let ptxt := (aes128_decrypt (from_seq key) iv (secret (@repr WORDSIZE32 2)) cipher_text) : Seq_t U8_t in
  if
    declassify_eq my_tag (from_seq tag)
  then
    Ok ptxt
  else
    Err INVALID_TAG.

Definition decrypt_aes128 (key : Key128_t) (iv : AesNonce_t) (aad : Seq_t U8_t) (cipher_text : Seq_t U8_t) (tag : Gf128Tag_t) : Result_t (Seq_t U8_t) (int8) :=
  decrypt_aes (from_seq key) iv aad cipher_text tag.
