(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_lib.

Require Import Hacspec_pasta.

Notation CRS_t := ((Seq_t (FpPallas_t × FpPallas_t × bool) × (FpPallas_t × FpPallas_t × bool))).

Definition rotate_polyx (p : Seq_t FpVesta_t) (rotation : FpVesta_t) : Seq_t FpVesta_t :=
  let res := (p) : Seq_t FpVesta_t in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len res))) res (fun i res =>
      let coef := (res.[i]) : FpVesta_t in
      let rot := (pow rotation (cast i)) : FpVesta_t in
      let res := (update_at res i (coef.*rot)) : Seq_t FpVesta_t in
      res)) : Seq_t FpVesta_t in
  res.

Definition commit_polyx (crs : (Seq_t (FpPallas_t × FpPallas_t × bool) × (FpPallas_t × FpPallas_t × bool))) (a : Seq_t FpVesta_t) (blinding : FpVesta_t) : (FpPallas_t × FpPallas_t × bool) :=
  let '(G,W) := (crs) : (Seq_t (FpPallas_t × FpPallas_t × bool) × (FpPallas_t × FpPallas_t × bool)) in
  let '(f1,f2,b) := (W) : (FpPallas_t × FpPallas_t × bool) in
  let lhs := (msm a (clone G)) : (FpPallas_t × FpPallas_t × bool) in
  let rhs := (g1mul_pallas blinding (clone f1,clone f2,clone b)) : (FpPallas_t × FpPallas_t × bool) in
  let res := (g1add_pallas lhs rhs) : (FpPallas_t × FpPallas_t × bool) in
  res.

Definition inner_product (u : Seq_t FpVesta_t) (v : Seq_t FpVesta_t) : FpVesta_t :=
  let res := (zero) : FpVesta_t in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len u))) res (fun i res =>
      res.+((u.[i]).*(v.[i])))) : _ in
  res.

Definition msm (a : Seq_t FpVesta_t) (g : Seq_t (FpPallas_t × FpPallas_t × bool)) : (FpPallas_t × FpPallas_t × bool) :=
  let res := ((zero,zero,true)) : (FpPallas_t × FpPallas_t × bool) in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len a))) res (fun i res =>
      g1add_pallas res (g1mul_pallas (a.[i]) (g.[i])))) : (FpPallas_t × FpPallas_t × bool) in
  res.

Definition compute_vanishing_polynomial (omega : FpVesta_t) (n : uint_size) : Seq_t FpVesta_t :=
  let vanishing_poly := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
  let vanishing_poly := (update_at vanishing_poly zero ONE) : Seq_t FpVesta_t in
  let vanishing_poly := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n)) vanishing_poly (fun i vanishing_poly =>
      let eval_point := (pow omega (cast i)) : FpVesta_t in
      let poly_mul_x := (multi_poly_with_x (clone vanishing_poly)) : Seq_t FpVesta_t in
      let poly_mul_scalar := (mul_scalar_polyx (clone vanishing_poly) (neg eval_point)) : Seq_t FpVesta_t in
      let vanishing_poly := (add_polyx poly_mul_x poly_mul_scalar) : Seq_t FpVesta_t in
      vanishing_poly)) : Seq_t FpVesta_t in
  vanishing_poly.

Definition sigma (i : uint_size) (sigma_list : Seq_t uint_size) (q : Seq_t Seq_t uint_size) : Seq_t uint_size :=
  let idx := (sigma_list.[i]) : uint_size in
  clone (q.[idx]).

Definition calculate_L_or_R (p_part : Seq_t FpVesta_t) (b_part : Seq_t FpVesta_t) (g_part : Seq_t (FpPallas_t × FpPallas_t × bool)) (z : FpVesta_t) (U : (FpPallas_t × FpPallas_t × bool)) (W : (FpPallas_t × FpPallas_t × bool)) (blinding : FpVesta_t) : (FpPallas_t × FpPallas_t × bool) :=
  let p_g_msm := (msm (clone p_part) g_part) : (FpPallas_t × FpPallas_t × bool) in
  let p_b_ip := (inner_product p_part b_part) : FpVesta_t in
  let z_ip := (z.*p_b_ip) : _ in
  let z_ip_U := (g1mul_pallas z_ip U) : (FpPallas_t × FpPallas_t × bool) in
  let multed_W := (g1mul_pallas blinding W) : (FpPallas_t × FpPallas_t × bool) in
  let part_j := (g1add_pallas p_g_msm z_ip_U) : (FpPallas_t × FpPallas_t × bool) in
  let part_j := (g1add_pallas part_j multed_W) : (FpPallas_t × FpPallas_t × bool) in
  part_j.

Definition step_4 (g_prime : Seq_t FpVesta_t) (omega : FpVesta_t) (n : uint_size) : Seq_t FpVesta_t :=
  let vanishing := (compute_vanishing_polynomial omega n) : Seq_t FpVesta_t in
  let '(h,remainder) := (divide_polyx g_prime vanishing) : (Seq_t FpVesta_t × Seq_t FpVesta_t) in
  h.

Definition step_5 (h : Seq_t FpVesta_t) (n : uint_size) (n_g : uint_size) : Seq_t Seq_t FpVesta_t :=
  let h := (trim_polyx h) : Seq_t FpVesta_t in
  let n_g := (n_g) : uint_size in
  let n := (n) : uint_size in
  let index_in_h := ((@repr WORDSIZE32 0)) : uint_size in
  let poly_parts := (create (n_g.-(@repr WORDSIZE32 1))) : Seq_t Seq_t FpVesta_t in
  let '(index_in_h,poly_parts) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(n_g.-(@repr WORDSIZE32 1)))) (index_in_h,poly_parts) (fun i '(index_in_h,poly_parts) =>
      let current_poly_part := (create n) : Seq_t FpVesta_t in
      let '(current_poly_part,index_in_h) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n)) (current_poly_part,index_in_h) (fun j '(current_poly_part,index_in_h) =>
          if
            index_in_h<.?(len h)
          then
            let current_poly_part := (update_at current_poly_part j (h.[index_in_h])) : Seq_t FpVesta_t in
            let index_in_h := (index_in_h.+(@repr WORDSIZE32 1)) : uint_size in
            (current_poly_part,index_in_h)
          else
            (current_poly_part,index_in_h))) : (Seq_t FpVesta_t × uint_size) in
      let poly_parts := (update_at poly_parts i current_poly_part) : Seq_t Seq_t FpVesta_t in
      (index_in_h,poly_parts))) : (uint_size × Seq_t Seq_t FpVesta_t) in
  poly_parts.

Definition step_6 (poly_parts : Seq_t Seq_t FpVesta_t) (crs : (Seq_t (FpPallas_t × FpPallas_t × bool) × (FpPallas_t × FpPallas_t × bool))) (blindings : Seq_t FpVesta_t) : Seq_t (FpPallas_t × FpPallas_t × bool) :=
  let commitment_seq := (create (len poly_parts)) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  let commitment_seq := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len poly_parts))) commitment_seq (fun i commitment_seq =>
      let commitment := (commit_polyx crs (clone (poly_parts.[i])) (blindings.[i])) : (FpPallas_t × FpPallas_t × bool) in
      let commitment_seq := (update_at commitment_seq i commitment) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      commitment_seq)) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  commitment_seq.

Definition step_7 (commitment_seq : Seq_t (FpPallas_t × FpPallas_t × bool)) (x : FpVesta_t) (n : uint_size) : (FpPallas_t × FpPallas_t × bool) :=
  let result := (g1_default_pallas) : (FpPallas_t × FpPallas_t × bool) in
  let result := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len commitment_seq))) result (fun i result =>
      let power := (n.*i) : uint_size in
      let x_raised := (pow x (cast power)) : FpVesta_t in
      let intemidiate := (g1mul_pallas x_raised (commitment_seq.[i])) : (FpPallas_t × FpPallas_t × bool) in
      let result := (g1add_pallas result intemidiate) : (FpPallas_t × FpPallas_t × bool) in
      result)) : (FpPallas_t × FpPallas_t × bool) in
  result.

Definition step_8 (h_parts : Seq_t Seq_t FpVesta_t) (x : FpVesta_t) (n : uint_size) (h_blinds : Seq_t FpVesta_t) : (Seq_t FpVesta_t × FpVesta_t) :=
  let res := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
  let h_prime_blind := (zero) : FpVesta_t in
  let '(h_prime_blind,res) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len h_parts))) (h_prime_blind,res) (fun i '(h_prime_blind,res) =>
      let power := (n.*i) : uint_size in
      let x_raised := (pow x (cast power)) : FpVesta_t in
      let h_i := (clone (h_parts.[i])) : Seq_t FpVesta_t in
      let aux_prod := (mul_scalar_polyx h_i x_raised) : Seq_t FpVesta_t in
      let res := (add_polyx res aux_prod) : Seq_t FpVesta_t in
      let h_prime_blind := (h_prime_blind.+((h_blinds.[i]).*x_raised)) : _ in
      (h_prime_blind,res))) : (_ × Seq_t FpVesta_t) in
  (res,h_prime_blind).

Definition step_9 (r : Seq_t FpVesta_t) (a_prime_seq : Seq_t Seq_t FpVesta_t) (omega : FpVesta_t) (p : Seq_t Seq_t uint_size) (x : FpVesta_t) : (FpVesta_t × Seq_t Seq_t FpVesta_t) :=
  let n_a := (len a_prime_seq) : uint_size in
  let a_seq := (create n_a) : Seq_t Seq_t FpVesta_t in
  let a_seq := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_a)) a_seq (fun i a_seq =>
      let p_i := (clone (p.[i])) : Seq_t uint_size in
      let n_e := (len p_i) : uint_size in
      let a_prime_i := (clone (a_prime_seq.[i])) : Seq_t FpVesta_t in
      let a_i_seq := (create n_e) : Seq_t FpVesta_t in
      let a_i_seq := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_e)) a_i_seq (fun j a_i_seq =>
          let p_i_j := (p_i.[j]) : uint_size in
          let argument := ((pow omega (cast p_i_j)).*x) : _ in
          let a_i_j := (eval_polyx (clone a_prime_i) argument) : FpVesta_t in
          let a_i_seq := (update_at a_i_seq j a_i_j) : Seq_t FpVesta_t in
          a_i_seq)) : Seq_t FpVesta_t in
      let a_seq := (update_at a_seq i a_i_seq) : Seq_t Seq_t FpVesta_t in
      a_seq)) : Seq_t Seq_t FpVesta_t in
  let r_x := (eval_polyx r x) : FpVesta_t in
  (r_x,a_seq).

Definition step_10 (omega : FpVesta_t) (p : Seq_t Seq_t uint_size) (x : FpVesta_t) (a : Seq_t Seq_t FpVesta_t) : Seq_t Seq_t FpVesta_t :=
  let n_a := (len a) : uint_size in
  let s := (create n_a) : Seq_t Seq_t FpVesta_t in
  let s := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_a)) s (fun i s =>
      let a_i := (clone (a.[i])) : Seq_t FpVesta_t in
      let p_i := (clone (p.[i])) : Seq_t uint_size in
      let n_e := (len p_i) : uint_size in
      let points := (create n_e) : Seq_t (FpVesta_t × FpVesta_t) in
      let points := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_e)) points (fun j points =>
          let p_i_j := (p_i.[j]) : uint_size in
          let x_j := ((pow omega (cast p_i_j)).*x) : _ in
          let y_j := (a_i.[j]) : FpVesta_t in
          let points := (update_at points j (x_j,y_j)) : Seq_t (FpVesta_t × FpVesta_t) in
          points)) : Seq_t (FpVesta_t × FpVesta_t) in
      let s_i := (lagrange_polyx points) : Seq_t FpVesta_t in
      let s := (update_at s i s_i) : Seq_t Seq_t FpVesta_t in
      s)) : Seq_t Seq_t FpVesta_t in
  s.

Definition step_11 (n_a : uint_size) (x1 : FpVesta_t) (x2 : FpVesta_t) (H_prime : (FpPallas_t × FpPallas_t × bool)) (R : (FpPallas_t × FpPallas_t × bool)) (a : Seq_t (FpPallas_t × FpPallas_t × bool)) (q : Seq_t Seq_t uint_size) (sigma_list : Seq_t uint_size) : (Seq_t (FpPallas_t × FpPallas_t × bool) × FpVesta_t × FpVesta_t) :=
  let n_q := (len q) : uint_size in
  let qs := (create n_q) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  let qs := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len qs))) qs (fun i qs =>
      update_at qs i g1_default_pallas)) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  let qs := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_a)) qs (fun i qs =>
      let a_i := (a.[i]) : (FpPallas_t × FpPallas_t × bool) in
      let sigma_i := (sigma i (clone sigma_list) (clone q)) : Seq_t uint_size in
      fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len sigma_i))) qs (fun k qs =>
        let j := (sigma_i.[k]) : uint_size in
        let q_sigma_i := (qs.[j]) : (FpPallas_t × FpPallas_t × bool) in
        let product := (g1mul_pallas x1 q_sigma_i) : (FpPallas_t × FpPallas_t × bool) in
        let qs := (update_at qs j (g1add_pallas product a_i)) : Seq_t (FpPallas_t × FpPallas_t × bool) in
        qs))) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  let x1_squared := (x1.*x1) : _ in
  let q0 := (qs.[zero]) : (FpPallas_t × FpPallas_t × bool) in
  let product1 := (g1mul_pallas x1_squared q0) : (FpPallas_t × FpPallas_t × bool) in
  let product2 := (g1mul_pallas x1 H_prime) : (FpPallas_t × FpPallas_t × bool) in
  let sum1 := (g1add_pallas product1 product2) : (FpPallas_t × FpPallas_t × bool) in
  let final_sum := (g1add_pallas sum1 R) : (FpPallas_t × FpPallas_t × bool) in
  let qs := (update_at qs zero final_sum) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  (qs,x1,x2).

Definition step_12 (n_a : uint_size) (x1 : FpVesta_t) (h_prime : Seq_t FpVesta_t) (r : Seq_t FpVesta_t) (a_prime : Seq_t Seq_t FpVesta_t) (q : Seq_t Seq_t uint_size) (sigma_list : Seq_t uint_size) (a_blinds : Seq_t FpVesta_t) (r_blind : FpVesta_t) (h_prime_blind : FpVesta_t) : (Seq_t Seq_t FpVesta_t × Seq_t FpVesta_t) :=
  let n_q := (len q) : uint_size in
  let qs := (create n_q) : Seq_t Seq_t FpVesta_t in
  let q_blinds := (create n_q) : Seq_t FpVesta_t in
  let qs := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len qs))) qs (fun i qs =>
      update_at qs i (create (@repr WORDSIZE32 1)))) : Seq_t Seq_t FpVesta_t in
  let '(q_blinds,qs) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_a)) (q_blinds,qs) (fun i '(q_blinds,qs) =>
      let a_i := (clone (a_prime.[i])) : Seq_t FpVesta_t in
      let a_blind_i := (a_blinds.[i]) : FpVesta_t in
      let sigma_i := (sigma i (clone sigma_list) (clone q)) : Seq_t uint_size in
      fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len sigma_i))) (q_blinds,qs) (fun j '(q_blinds,qs) =>
        let j := (sigma_i.[j]) : uint_size in
        let q_sigma_i := (clone (qs.[j])) : Seq_t FpVesta_t in
        let product := (mul_scalar_polyx (clone q_sigma_i) x1) : Seq_t FpVesta_t in
        let qs := (update_at qs j (add_polyx product (clone a_i))) : Seq_t Seq_t FpVesta_t in
        let q_blinds := (update_at q_blinds j ((x1.*(q_blinds.[j])).+a_blind_i)) : Seq_t FpVesta_t in
        (q_blinds,qs)))) : (Seq_t FpVesta_t × Seq_t Seq_t FpVesta_t) in
  let x1_squared := (x1.*x1) : _ in
  let q0 := (clone (qs.[zero])) : Seq_t FpVesta_t in
  let product1 := (mul_scalar_polyx q0 x1_squared) : Seq_t FpVesta_t in
  let product2 := (mul_scalar_polyx h_prime x1) : Seq_t FpVesta_t in
  let sum1 := (add_polyx product1 product2) : Seq_t FpVesta_t in
  let final_sum := (add_polyx sum1 r) : Seq_t FpVesta_t in
  let qs := (update_at qs zero final_sum) : Seq_t Seq_t FpVesta_t in
  let q_blinds := (update_at q_blinds zero (x1_squared.*(q_blinds.[zero]))) : Seq_t FpVesta_t in
  let q_blinds := (update_at q_blinds zero ((q_blinds.[zero]).+r_blind)) : Seq_t FpVesta_t in
  let q_blinds := (update_at q_blinds zero ((q_blinds.[zero]).+(h_prime_blind.*x1))) : Seq_t FpVesta_t in
  (qs,q_blinds).

Definition step_13 (n : uint_size) (omega : FpVesta_t) (x : FpVesta_t) (x1 : FpVesta_t) (r : FpVesta_t) (s : Seq_t Seq_t FpVesta_t) (q : Seq_t Seq_t uint_size) (sigma_list : Seq_t uint_size) (g_prime_eval_combined_from_a : FpVesta_t) (g_prime : Seq_t FpVesta_t) : (Seq_t Seq_t FpVesta_t × Seq_t Seq_t FpVesta_t) :=
  let n_a := (len s) : uint_size in
  let n_q := (len q) : uint_size in
  let rs := (create n_q) : Seq_t Seq_t FpVesta_t in
  let rs := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len rs))) rs (fun i rs =>
      update_at rs i (create (@repr WORDSIZE32 1)))) : Seq_t Seq_t FpVesta_t in
  let rs := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_a)) rs (fun i rs =>
      let s_i := (clone (s.[i])) : Seq_t FpVesta_t in
      let sigma_i := (sigma i (clone sigma_list) (clone q)) : Seq_t uint_size in
      fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len sigma_i))) rs (fun j rs =>
        let j := (sigma_i.[j]) : uint_size in
        let r_sigma_i := (clone (rs.[j])) : Seq_t FpVesta_t in
        let product := (mul_scalar_polyx (clone r_sigma_i) x1) : Seq_t FpVesta_t in
        let rs := (update_at rs j (add_polyx product (clone s_i))) : Seq_t Seq_t FpVesta_t in
        rs))) : Seq_t Seq_t FpVesta_t in
  let rs_verifier := (clone rs) : Seq_t Seq_t FpVesta_t in
  let rs_prover := (rs) : Seq_t Seq_t FpVesta_t in
  let g_prime_x := (eval_polyx g_prime x) : FpVesta_t in
  let vanishing_poly := (compute_vanishing_polynomial omega n) : Seq_t FpVesta_t in
  let vanishing_poly_x := (eval_polyx vanishing_poly x) : FpVesta_t in
  let h := (div g_prime_x vanishing_poly_x) : _ in
  let x1_squared := (x1.*x1) : _ in
  let r0 := (clone (rs_prover.[zero])) : Seq_t FpVesta_t in
  let product1 := (mul_scalar_polyx r0 x1_squared) : Seq_t FpVesta_t in
  let product2 := (h.*x1) : _ in
  let sum1 := (add_scalar_polyx product1 product2) : Seq_t FpVesta_t in
  let final_sum := (add_scalar_polyx sum1 r) : Seq_t FpVesta_t in
  let rs_prover := (update_at rs_prover zero final_sum) : Seq_t Seq_t FpVesta_t in
  let vanishing_poly := (compute_vanishing_polynomial omega n) : Seq_t FpVesta_t in
  let vanishing_poly_x := (eval_polyx vanishing_poly x) : FpVesta_t in
  let h := (div g_prime_eval_combined_from_a vanishing_poly_x) : _ in
  let x1_squared := (x1.*x1) : _ in
  let r0 := (clone (rs_verifier.[zero])) : Seq_t FpVesta_t in
  let product1 := (mul_scalar_polyx r0 x1_squared) : Seq_t FpVesta_t in
  let product2 := (h.*x1) : _ in
  let sum1 := (add_scalar_polyx product1 product2) : Seq_t FpVesta_t in
  let final_sum := (add_scalar_polyx sum1 r) : Seq_t FpVesta_t in
  let rs_verifier := (update_at rs_verifier zero final_sum) : Seq_t Seq_t FpVesta_t in
  (rs_prover,rs_verifier).

Definition step_14 (crs : (Seq_t (FpPallas_t × FpPallas_t × bool) × (FpPallas_t × FpPallas_t × bool))) (x2 : FpVesta_t) (q_polys : Seq_t Seq_t FpVesta_t) (r_polys : Seq_t Seq_t FpVesta_t) (q : Seq_t Seq_t uint_size) (blinding : FpVesta_t) (omega : FpVesta_t) (x : FpVesta_t) : ((FpPallas_t × FpPallas_t × bool) × Seq_t FpVesta_t × FpVesta_t) :=
  let q_prime := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
  let n_q := (len q) : uint_size in
  let q_prime := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_q)) q_prime (fun i q_prime =>
      let x2_powered := (pow x2 (cast ((n_q.-(@repr WORDSIZE32 1)).-i))) : FpVesta_t in
      let q_poly_i := (clone (q_polys.[i])) : Seq_t FpVesta_t in
      let r_i := (clone (r_polys.[i])) : Seq_t FpVesta_t in
      let q_i_sub_r_i := (sub_polyx q_poly_i r_i) : Seq_t FpVesta_t in
      let q_i := (clone (q.[i])) : Seq_t uint_size in
      let divisor := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
      let divisor := (update_at divisor zero ONE) : Seq_t FpVesta_t in
      let divisor := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len q_i))) divisor (fun j divisor =>
          let q_i_j := (q_i.[j]) : uint_size in
          let scalar := ((pow omega (cast q_i_j)).*x) : _ in
          let divisor_mul_x := (multi_poly_with_x (clone divisor)) : Seq_t FpVesta_t in
          let divisor_mul_scalar := (mul_scalar_polyx (clone divisor) (neg scalar)) : Seq_t FpVesta_t in
          let divisor := (add_polyx divisor_mul_x divisor_mul_scalar) : Seq_t FpVesta_t in
          divisor)) : Seq_t FpVesta_t in
      let '(divided_poly,remainder) := (divide_polyx (clone q_i_sub_r_i) divisor) : (Seq_t FpVesta_t × Seq_t FpVesta_t) in
      let multed_poly := (mul_scalar_polyx divided_poly x2_powered) : Seq_t FpVesta_t in
      let q_prime := (add_polyx q_prime multed_poly) : Seq_t FpVesta_t in
      q_prime)) : Seq_t FpVesta_t in
  let commitment := (commit_polyx crs (clone q_prime) blinding) : (FpPallas_t × FpPallas_t × bool) in
  (commitment,q_prime,blinding).

Definition step_15 (x_3 : FpVesta_t) : FpVesta_t :=
  x_3.

Definition step_16 (n_q : uint_size) (x3 : FpVesta_t) (q_polys : Seq_t Seq_t FpVesta_t) : Seq_t FpVesta_t :=
  let u := (create n_q) : Seq_t FpVesta_t in
  let u := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_q)) u (fun i u =>
      let q_i := (clone (q_polys.[i])) : Seq_t FpVesta_t in
      let u_i := (eval_polyx q_i x3) : FpVesta_t in
      let u := (update_at u i u_i) : Seq_t FpVesta_t in
      u)) : Seq_t FpVesta_t in
  u.

Definition step_17 (x_4 : FpVesta_t) : FpVesta_t :=
  x_4.

Definition step_18 (x : FpVesta_t) (x1 : FpVesta_t) (x2 : FpVesta_t) (x3 : FpVesta_t) (x4 : FpVesta_t) (omega : FpVesta_t) (Q_prime : (FpPallas_t × FpPallas_t × bool)) (Q : Seq_t (FpPallas_t × FpPallas_t × bool)) (u : Seq_t FpVesta_t) (r : Seq_t Seq_t FpVesta_t) (q : Seq_t Seq_t uint_size) : ((FpPallas_t × FpPallas_t × bool) × FpVesta_t) :=
  let n_q := (len q) : uint_size in
  let v := (zero) : FpVesta_t in
  let P_sum := (g1_default_pallas) : (FpPallas_t × FpPallas_t × bool) in
  let P_sum := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_q)) P_sum (fun i P_sum =>
      let Q_i := (Q.[i]) : (FpPallas_t × FpPallas_t × bool) in
      let term := (g1mul_pallas (pow x4 (cast ((n_q.-i).-(@repr WORDSIZE32 1)))) Q_i) : (FpPallas_t × FpPallas_t × bool) in
      g1add_pallas P_sum term)) : (FpPallas_t × FpPallas_t × bool) in
  let first_term := (g1mul_pallas (pow x4 (cast n_q)) Q_prime) : (FpPallas_t × FpPallas_t × bool) in
  let P := (g1add_pallas first_term P_sum) : (FpPallas_t × FpPallas_t × bool) in
  let v_first_sum := (zero) : FpVesta_t in
  let v_first_sum := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_q)) v_first_sum (fun i v_first_sum =>
      let q_i := (clone (q.[i])) : Seq_t uint_size in
      let n_e := (len q_i) : uint_size in
      let u_i := (u.[i]) : FpVesta_t in
      let r_i := (clone (r.[i])) : Seq_t FpVesta_t in
      let r_i_x3 := (eval_polyx r_i x3) : FpVesta_t in
      let numerator := (u_i.-r_i_x3) : _ in
      let product := (ONE) : FpVesta_t in
      let product := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_e)) product (fun j product =>
          let q_i_j := (q_i.[j]) : uint_size in
          let rhs := ((pow omega (cast q_i_j)).*x) : _ in
          let term := (x3.-rhs) : _ in
          let product := (product.*term) : _ in
          product)) : _ in
      let sum_term := ((pow x2 (cast ((n_q.-i).-(@repr WORDSIZE32 1)))).*(div numerator product)) : _ in
      let v_first_sum := (v_first_sum.+sum_term) : _ in
      v_first_sum)) : _ in
  let v_first_sum := (v_first_sum.*(pow x4 (cast n_q))) : _ in
  let v_second_sum := (zero) : FpVesta_t in
  let v_second_sum := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_q)) v_second_sum (fun i v_second_sum =>
      let u_i := (u.[i]) : FpVesta_t in
      let term := ((pow x4 (cast ((n_q.-(@repr WORDSIZE32 1)).-i))).*u_i) : _ in
      let v_second_sum := (v_second_sum.+term) : _ in
      v_second_sum)) : _ in
  let v := (v_first_sum.+v_second_sum) : _ in
  (P,v).

Definition step_19 (x4 : FpVesta_t) (q_prime : Seq_t FpVesta_t) (q_polys : Seq_t Seq_t FpVesta_t) (q_blinds : Seq_t FpVesta_t) (q_prime_blind : FpVesta_t) : (Seq_t FpVesta_t × FpVesta_t) :=
  let p := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
  let n_q := (len q_polys) : uint_size in
  let p_blind := (zero) : FpVesta_t in
  let '(p,p_blind) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)n_q)) (p,p_blind) (fun i '(p,p_blind) =>
      let power := ((n_q.-(@repr WORDSIZE32 1)).-i) : uint_size in
      let x4_powered := (pow x4 (cast power)) : FpVesta_t in
      let q_i := (clone (q_polys.[i])) : Seq_t FpVesta_t in
      let multed_poly := (mul_scalar_polyx q_i x4_powered) : Seq_t FpVesta_t in
      let p := (add_polyx p multed_poly) : Seq_t FpVesta_t in
      let p_blind := (p_blind.+(x4_powered.*(q_blinds.[i]))) : _ in
      (p,p_blind))) : (Seq_t FpVesta_t × _) in
  let x4n_q := (pow x4 (cast n_q)) : FpVesta_t in
  let first_term := (mul_scalar_polyx q_prime x4n_q) : Seq_t FpVesta_t in
  let p := (add_polyx p first_term) : Seq_t FpVesta_t in
  let p_blind := (p_blind.+(x4n_q.*q_prime_blind)) : _ in
  (p,p_blind).

Definition step_20 (s : Seq_t FpVesta_t) (crs : (Seq_t (FpPallas_t × FpPallas_t × bool) × (FpPallas_t × FpPallas_t × bool))) (r : FpVesta_t) : ((FpPallas_t × FpPallas_t × bool) × FpVesta_t) :=
  let S := (commit_polyx crs s r) : (FpPallas_t × FpPallas_t × bool) in
  (S,r).

Definition step_21 (xi : FpVesta_t) (z : FpVesta_t) : (FpVesta_t × FpVesta_t) :=
  (xi,z).

Definition step_22 (p : (FpPallas_t × FpPallas_t × bool)) (g0 : (FpPallas_t × FpPallas_t × bool)) (s : (FpPallas_t × FpPallas_t × bool)) (v : FpVesta_t) (xi : FpVesta_t) : (FpPallas_t × FpPallas_t × bool) :=
  let prod1 := (g1mul_pallas v g0) : (FpPallas_t × FpPallas_t × bool) in
  let prod1_neg := (g1neg_pallas prod1) : (FpPallas_t × FpPallas_t × bool) in
  let prod2 := (g1mul_pallas xi s) : (FpPallas_t × FpPallas_t × bool) in
  let lhs_sum := (g1add_pallas p prod1_neg) : (FpPallas_t × FpPallas_t × bool) in
  let p_prime := (g1add_pallas lhs_sum prod2) : (FpPallas_t × FpPallas_t × bool) in
  p_prime.

Definition step_23 (p : Seq_t FpVesta_t) (s : Seq_t FpVesta_t) (x3 : FpVesta_t) (xi : FpVesta_t) (p_blind : FpVesta_t) (s_blind : FpVesta_t) : (Seq_t FpVesta_t × FpVesta_t) :=
  let p_eval_x3 := (eval_polyx (clone p) x3) : FpVesta_t in
  let xi_mul_s := (mul_scalar_polyx s xi) : Seq_t FpVesta_t in
  let p_prime := (p) : Seq_t FpVesta_t in
  let p_prime := (sub_scalar_polyx p_prime p_eval_x3) : Seq_t FpVesta_t in
  let p_prime := (add_polyx p_prime xi_mul_s) : Seq_t FpVesta_t in
  let p_prime_blind := ((s_blind.*xi).+p_blind) : _ in
  (p_prime,p_prime_blind).

Definition step_24 (p_prime_poly : Seq_t FpVesta_t) (G : Seq_t (FpPallas_t × FpPallas_t × bool)) (x3 : FpVesta_t) (z : FpVesta_t) (U : (FpPallas_t × FpPallas_t × bool)) (W : (FpPallas_t × FpPallas_t × bool)) (n : uint_size) (k : uint_size) (u : Seq_t FpVesta_t) (L_blinding : Seq_t FpVesta_t) (R_blinding : Seq_t FpVesta_t) : (Seq_t FpVesta_t × Seq_t (FpPallas_t × FpPallas_t × bool) × Seq_t FpVesta_t × Seq_t (FpPallas_t × FpPallas_t × bool) × Seq_t (FpPallas_t × FpPallas_t × bool) × Seq_t FpVesta_t × Seq_t FpVesta_t) :=
  let p_prime := (p_prime_poly) : Seq_t FpVesta_t in
  let g_prime := (G) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  let b := (create n) : Seq_t FpVesta_t in
  let L := (create k) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  let R := (create k) : Seq_t (FpPallas_t × FpPallas_t × bool) in
  let b := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len b))) b (fun i b =>
      let x3_powered := (pow x3 (cast i)) : FpVesta_t in
      let b := (update_at b i x3_powered) : Seq_t FpVesta_t in
      b)) : Seq_t FpVesta_t in
  let '(L,R,b,g_prime,p_prime) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)k)) (L,R,b,g_prime,p_prime) (fun j '(L,R,b,g_prime,p_prime) =>
      let p_prime_half := ((len p_prime)./(@repr WORDSIZE32 2)) : uint_size in
      let g_prime_half := ((len g_prime)./(@repr WORDSIZE32 2)) : uint_size in
      let b_half := ((len b)./(@repr WORDSIZE32 2)) : uint_size in
      let p_prime_lo := (slice p_prime (@repr WORDSIZE32 0) p_prime_half) : Seq_t FpVesta_t in
      let p_prime_hi := (slice p_prime p_prime_half p_prime_half) : Seq_t FpVesta_t in
      let g_prime_lo := (slice g_prime (@repr WORDSIZE32 0) g_prime_half) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      let g_prime_hi := (slice g_prime g_prime_half g_prime_half) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      let b_lo := (slice b (@repr WORDSIZE32 0) b_half) : Seq_t FpVesta_t in
      let b_hi := (slice b b_half b_half) : Seq_t FpVesta_t in
      let L_j := (calculate_L_or_R (clone p_prime_hi) (clone b_lo) (clone g_prime_lo) z U W (L_blinding.[j])) : (FpPallas_t × FpPallas_t × bool) in
      let L := (update_at L j L_j) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      let R_j := (calculate_L_or_R (clone p_prime_lo) (clone b_hi) (clone g_prime_hi) z U W (R_blinding.[j])) : (FpPallas_t × FpPallas_t × bool) in
      let R := (update_at R j R_j) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      let u_j := (u.[j]) : FpVesta_t in
      let new_g_prime := (create g_prime_half) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      let new_g_prime := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len new_g_prime))) new_g_prime (fun i new_g_prime =>
          let g_prime_hi_indexed := (g_prime_hi.[i]) : (FpPallas_t × FpPallas_t × bool) in
          let g_prime_lo_indexed := (g_prime_lo.[i]) : (FpPallas_t × FpPallas_t × bool) in
          let rhs_product := (g1mul_pallas u_j g_prime_hi_indexed) : (FpPallas_t × FpPallas_t × bool) in
          let sum := (g1add_pallas g_prime_lo_indexed rhs_product) : (FpPallas_t × FpPallas_t × bool) in
          let new_g_prime := (update_at new_g_prime i sum) : Seq_t (FpPallas_t × FpPallas_t × bool) in
          new_g_prime)) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      let g_prime := (new_g_prime) : Seq_t (FpPallas_t × FpPallas_t × bool) in
      let rhs := (mul_scalar_polyx (clone b_hi) u_j) : Seq_t FpVesta_t in
      let new_b := (add_polyx (clone b_lo) rhs) : Seq_t FpVesta_t in
      let b := (new_b) : Seq_t FpVesta_t in
      let u_j_inv := (inv u_j) : FpVesta_t in
      let rhs := (mul_scalar_polyx (clone p_prime_hi) u_j_inv) : Seq_t FpVesta_t in
      let new_p_prime := (add_polyx (clone p_prime_lo) rhs) : Seq_t FpVesta_t in
      let p_prime := (new_p_prime) : Seq_t FpVesta_t in
      (L,R,b,g_prime,p_prime))) : (Seq_t (FpPallas_t × FpPallas_t × bool) × Seq_t (FpPallas_t × FpPallas_t × bool) × Seq_t FpVesta_t × Seq_t (FpPallas_t × FpPallas_t × bool) × Seq_t FpVesta_t) in
  (p_prime,g_prime,b,L,R,L_blinding,R_blinding).

Definition step_25 (p_prime : Seq_t FpVesta_t) (L_blinding : Seq_t FpVesta_t) (R_blinding : Seq_t FpVesta_t) (p_prime_blind : FpVesta_t) (u : Seq_t FpVesta_t) : (FpVesta_t × FpVesta_t) :=
  let c := (p_prime.[zero]) : FpVesta_t in
  let f := (p_prime_blind) : FpVesta_t in
  let f := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len L_blinding))) f (fun j f =>
      let u_j := (u.[j]) : FpVesta_t in
      let u_j_inv := (inv u_j) : FpVesta_t in
      let L_j_blinding := (L_blinding.[j]) : FpVesta_t in
      let R_j_blinding := (R_blinding.[j]) : FpVesta_t in
      let f := (f.+(L_j_blinding.*u_j_inv)) : _ in
      let f := (f.+(R_j_blinding.*u_j)) : _ in
      f)) : _ in
  (c,f).

Definition step_26 (u : Seq_t FpVesta_t) (L : Seq_t (FpPallas_t × FpPallas_t × bool)) (P_prime : (FpPallas_t × FpPallas_t × bool)) (R : Seq_t (FpPallas_t × FpPallas_t × bool)) (c : FpVesta_t) (G_prime_0 : (FpPallas_t × FpPallas_t × bool)) (b_0 : FpVesta_t) (z : FpVesta_t) (U : (FpPallas_t × FpPallas_t × bool)) (f : FpVesta_t) (W : (FpPallas_t × FpPallas_t × bool)) : bool :=
  let first_sum := (g1_default_pallas) : (FpPallas_t × FpPallas_t × bool) in
  let first_sum := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len u))) first_sum (fun j first_sum =>
      let u_j_inv := (inv (u.[j])) : FpVesta_t in
      let L_j := (L.[j]) : (FpPallas_t × FpPallas_t × bool) in
      let prod_j := (g1mul_pallas u_j_inv L_j) : (FpPallas_t × FpPallas_t × bool) in
      let first_sum := (g1add_pallas first_sum prod_j) : (FpPallas_t × FpPallas_t × bool) in
      first_sum)) : (FpPallas_t × FpPallas_t × bool) in
  let second_sum := (g1_default_pallas) : (FpPallas_t × FpPallas_t × bool) in
  let second_sum := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len u))) second_sum (fun j second_sum =>
      let u_j := (u.[j]) : FpVesta_t in
      let R_j := (R.[j]) : (FpPallas_t × FpPallas_t × bool) in
      let prod_j := (g1mul_pallas u_j R_j) : (FpPallas_t × FpPallas_t × bool) in
      let second_sum := (g1add_pallas second_sum prod_j) : (FpPallas_t × FpPallas_t × bool) in
      second_sum)) : (FpPallas_t × FpPallas_t × bool) in
  let lhs := (g1add_pallas first_sum (g1add_pallas P_prime second_sum)) : (FpPallas_t × FpPallas_t × bool) in
  let rhs_term_1 := (g1mul_pallas c G_prime_0) : (FpPallas_t × FpPallas_t × bool) in
  let cb_0z := ((c.*b_0).*z) : _ in
  let rhs_term_2 := (g1mul_pallas cb_0z U) : (FpPallas_t × FpPallas_t × bool) in
  let rhs_term_3 := (g1mul_pallas f W) : (FpPallas_t × FpPallas_t × bool) in
  let rhs := (g1add_pallas rhs_term_1 (g1add_pallas rhs_term_2 rhs_term_3)) : (FpPallas_t × FpPallas_t × bool) in
  let check := (eq lhs rhs) : bool in
  check.

Notation Polyx_t := (Seq_t FpVesta_t).

Definition add_polyx (p1 : Seq_t FpVesta_t) (p2 : Seq_t FpVesta_t) : Seq_t FpVesta_t :=
  let res := (create (@repr WORDSIZE32 0)) : Seq_t FpVesta_t in
  let short_len := ((@repr WORDSIZE32 0)) : uint_size in
  let '(res,short_len) := (if
      (len p1)>.?(len p2)
    then
      let res := (clone p1) : Seq_t FpVesta_t in
      let short_len := (len p2) : uint_size in
      (res,short_len)
    else
      let res := (clone p2) : Seq_t FpVesta_t in
      let short_len := (len p1) : uint_size in
      (res,short_len)) : (Seq_t FpVesta_t × uint_size) in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)short_len)) res (fun i res =>
      update_at res i ((p1.[i]).+(p2.[i])))) : Seq_t FpVesta_t in
  trim_polyx res.

Definition sub_polyx (p1 : Seq_t FpVesta_t) (p2 : Seq_t FpVesta_t) : Seq_t FpVesta_t :=
  let largest := (len p1) : uint_size in
  let largest := (if
      (len p2)>.?(len p1)
    then
      let largest := (len p2) : uint_size in
      largest
    else
      largest) : uint_size in
  let res := (create largest) : Seq_t FpVesta_t in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len p1))) res (fun i res =>
      update_at res i (p1.[i]))) : Seq_t FpVesta_t in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len p2))) res (fun i res =>
      update_at res i ((res.[i]).-(p2.[i])))) : Seq_t FpVesta_t in
  trim_polyx res.

Definition mul_polyx (a : Seq_t FpVesta_t) (b : Seq_t FpVesta_t) : Seq_t FpVesta_t :=
  let result := (create ((len a).+(len b))) : Seq_t FpVesta_t in
  let result := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len a))) result (fun i result =>
      if
        MachineIntegers.not (equal (a.[i]) default)
      then
        fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len b))) result (fun j result =>
          if
            MachineIntegers.not (equal (b.[j]) default)
          then
            let result := (update_at result (i.+j) ((result.[(i.+j)]).+((a.[i]).*(b.[j])))) : Seq_t FpVesta_t in
            result
          else
            result)
      else
        result)) : Seq_t FpVesta_t in
  trim_polyx result.

Definition mul_scalar_polyx (p : Seq_t FpVesta_t) (s : FpVesta_t) : Seq_t FpVesta_t :=
  let res := (clone p) : Seq_t FpVesta_t in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len res))) res (fun i res =>
      update_at res i ((p.[i]).*s))) : Seq_t FpVesta_t in
  res.

Definition add_scalar_polyx (p : Seq_t FpVesta_t) (s : FpVesta_t) : Seq_t FpVesta_t :=
  let res := (clone p) : Seq_t FpVesta_t in
  let res := (if
      (len res)=.?(@repr WORDSIZE32 0)
    then
      let res := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
      res
    else
      res) : Seq_t FpVesta_t in
  let res := (update_at res zero ((res.[zero]).+s)) : Seq_t FpVesta_t in
  res.

Definition sub_scalar_polyx (p : Seq_t FpVesta_t) (s : FpVesta_t) : Seq_t FpVesta_t :=
  let res := (clone p) : Seq_t FpVesta_t in
  let res := (if
      (len res)=.?(@repr WORDSIZE32 0)
    then
      let res := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
      res
    else
      res) : Seq_t FpVesta_t in
  let res := (update_at res zero ((res.[zero]).-s)) : Seq_t FpVesta_t in
  res.

Definition eval_polyx (p : Seq_t FpVesta_t) (x : FpVesta_t) : FpVesta_t :=
  let res := (zero) : FpVesta_t in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len p))) res (fun i res =>
      res.+((p.[i]).*(exp x (cast i))))) : _ in
  res.

Definition degree_polyx (p : Seq_t FpVesta_t) : uint_size :=
  let len := (len (trim_polyx p)) : uint_size in
  if
    len=.?(@repr WORDSIZE32 0)
  then
    (@repr WORDSIZE32 0)
  else
    len.-(@repr WORDSIZE32 1).

Definition check_not_zero_polyx (p : Seq_t FpVesta_t) : bool :=
  let sum := (zero) : FpVesta_t in
  let all_zero := (false) : bool in
  let all_zero := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len p))) all_zero (fun i all_zero =>
      if
        gt (p.[i]) zero
      then
        let all_zero := (true) : bool in
        all_zero
      else
        all_zero)) : bool in
  all_zero.

Definition trim_polyx (p : Seq_t FpVesta_t) : Seq_t FpVesta_t :=
  let last_val_idx := ((@repr WORDSIZE32 1)) : uint_size in
  let last_val_idx := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len p))) last_val_idx (fun i last_val_idx =>
      if
        ne (p.[i]) zero
      then
        let last_val_idx := (i.+(@repr WORDSIZE32 1)) : uint_size in
        last_val_idx
      else
        last_val_idx)) : uint_size in
  let res := (create last_val_idx) : Seq_t FpVesta_t in
  let res := (if
      (len p)<>(@repr WORDSIZE32 0)
    then
      fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len res))) res (fun i res =>
        update_at res i (p.[i]))
    else
      res) : Seq_t FpVesta_t in
  let res := (if
      (len p)=.?(@repr WORDSIZE32 0)
    then
      let res := (p) : Seq_t FpVesta_t in
      res
    else
      res) : Seq_t FpVesta_t in
  res.

Definition divide_leading_terms (n : Seq_t FpVesta_t) (d : Seq_t FpVesta_t) : Seq_t FpVesta_t :=
  let n := (trim_polyx n) : Seq_t FpVesta_t in
  let d := (trim_polyx d) : Seq_t FpVesta_t in
  let x_pow := ((len n).-(len d)) : uint_size in
  let n_coeff := (n.[((len n).-(@repr WORDSIZE32 1))]) : FpVesta_t in
  let d_coeff := (d.[((len d).-(@repr WORDSIZE32 1))]) : FpVesta_t in
  let coeff := (div n_coeff d_coeff) : _ in
  let res := (create (x_pow.+(@repr WORDSIZE32 1))) : Seq_t FpVesta_t in
  let res := (update_at res x_pow coeff) : Seq_t FpVesta_t in
  res.

Definition divide_polyx (n : Seq_t FpVesta_t) (d : Seq_t FpVesta_t) : (Seq_t FpVesta_t × Seq_t FpVesta_t) :=
  let q := (create (len n)) : Seq_t FpVesta_t in
  let r := (clone n) : Seq_t FpVesta_t in
  let loop_upper_bound := (len d) : uint_size in
  let loop_upper_bound := (if
      (len q)>.?(len d)
    then
      let loop_upper_bound := (len q) : uint_size in
      loop_upper_bound
    else
      loop_upper_bound) : uint_size in
  let '(q,r) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)loop_upper_bound)) (q,r) (fun _ '(q,r) =>
      if
        andb (check_not_zero_polyx (clone r)) ((degree_polyx (clone r))>=.?(degree_polyx (clone d)))
      then
        let t := (divide_leading_terms (clone r) (clone d)) : Seq_t FpVesta_t in
        let q := (add_polyx q (clone t)) : Seq_t FpVesta_t in
        let aux_prod := (mul_polyx (clone d) (clone t)) : Seq_t FpVesta_t in
        let r := (sub_polyx r aux_prod) : Seq_t FpVesta_t in
        (q,r)
      else
        (q,r))) : (Seq_t FpVesta_t × Seq_t FpVesta_t) in
  (trim_polyx q,trim_polyx r).

Definition multi_poly_with_x (p : Seq_t FpVesta_t) : Seq_t FpVesta_t :=
  multi_poly_with_x_pow p (@repr WORDSIZE32 1).

Definition multi_poly_with_x_pow (p : Seq_t FpVesta_t) (power : uint_size) : Seq_t FpVesta_t :=
  let p := (trim_polyx p) : Seq_t FpVesta_t in
  let res := (create ((len p).+power)) : Seq_t FpVesta_t in
  let res := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len p))) res (fun i res =>
      update_at res (i.+power) (p.[i]))) : Seq_t FpVesta_t in
  res.

Definition lagrange_polyx (points : Seq_t (FpVesta_t × FpVesta_t)) : Seq_t FpVesta_t :=
  let poly := (create (len points)) : Seq_t FpVesta_t in
  let poly := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len points))) poly (fun i poly =>
      let x := (fst (points.[i])) : FpVesta_t in
      let y := (snd (points.[i])) : FpVesta_t in
      let basis := (lagrange_basis (clone points) x) : Seq_t FpVesta_t in
      let scaled_basis := (mul_scalar_polyx basis y) : Seq_t FpVesta_t in
      let poly := (add_polyx (clone poly) (clone scaled_basis)) : Seq_t FpVesta_t in
      poly)) : Seq_t FpVesta_t in
  let poly := (trim_polyx poly) : Seq_t FpVesta_t in
  poly.

Definition lagrange_basis (points : Seq_t (FpVesta_t × FpVesta_t)) (x : FpVesta_t) : Seq_t FpVesta_t :=
  let basis := (create (len points)) : Seq_t FpVesta_t in
  let basis := (update_at basis zero ONE) : Seq_t FpVesta_t in
  let devisor := (ONE) : FpVesta_t in
  let '(basis,devisor) := (fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len points))) (basis,devisor) (fun i '(basis,devisor) =>
      let point := (points.[i]) : (FpVesta_t × FpVesta_t) in
      let p_x := (fst point) : FpVesta_t in
      if
        ne p_x x
      then
        let devisor := (devisor.*(x.-p_x)) : _ in
        let poly_mul_x := (multi_poly_with_x (clone basis)) : Seq_t FpVesta_t in
        let poly_mul_scalar := (mul_scalar_polyx (clone basis) (neg p_x)) : Seq_t FpVesta_t in
        let basis := (add_polyx poly_mul_x poly_mul_scalar) : Seq_t FpVesta_t in
        (basis,devisor)
      else
        (basis,devisor))) : (Seq_t FpVesta_t × _) in
  let test := (eval_polyx (clone basis) ONE) : FpVesta_t in
  let division_poly := (create (len points)) : Seq_t FpVesta_t in
  let division_poly := (update_at division_poly zero devisor) : Seq_t FpVesta_t in
  let output := (divide_polyx (clone basis) (clone division_poly)) : (Seq_t FpVesta_t × Seq_t FpVesta_t) in
  let '(final_basis,_) := (output) : (Seq_t FpVesta_t × Seq_t FpVesta_t) in
  final_basis.

Definition gen_zero_polyx : Seq_t FpVesta_t :=
  create (@repr WORDSIZE32 1).

Definition gen_one_polyx : Seq_t FpVesta_t :=
  let poly := (create (@repr WORDSIZE32 1)) : Seq_t FpVesta_t in
  let poly := (update_at poly zero ONE) : Seq_t FpVesta_t in
  poly.

Definition check_equal_polyx (p1 : Seq_t FpVesta_t) (p2 : Seq_t FpVesta_t) : bool :=
  let is_equal := (false) : bool in
  let is_equal := (if
      (len (trim_polyx (clone p1)))=.?(len (trim_polyx (clone p2)))
    then
      let is_equal := (true) : bool in
      fold (into_iter (Build_Range_t (@repr WORDSIZE32 0)(len (trim_polyx (clone p1))))) is_equal (fun i is_equal =>
        let p1_scaler_i := (clone (p1.[i])) : FpVesta_t in
        let p2_scaler_i := (clone (p2.[i])) : FpVesta_t in
        if
          ne p1_scaler_i p2_scaler_i
        then
          let is_equal := (false) : bool in
          is_equal
        else
          is_equal)
    else
      is_equal) : bool in
  is_equal.
